<!doctype html><html lang="ja"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="JSer.infoの情報源となるサイトのRSSフィードをまとめたサイトです。JavaScriptの情報源を集めることを目的としています。"><meta name="author" content="jser"><meta name="robots" content="index, follow"><meta property="og:url" content="https://jser.info/watch-list-rss/"><meta property="og:title" content="azukiazusa のテックブログ2のフィード｜JSer.info Watch List RSS"><meta property="og:image" content="https://jser.info/watch-list-rss/images/og-image.png?hash=c56ba3x"><meta property="og:description" content="JSer.infoの情報源となるサイトのRSSフィードをまとめたサイトです。JavaScriptの情報源を集めることを目的としています。"><meta property="og:type" content="website"><meta property="og:site_name" content="JSer.info Watch List RSS"><meta property="og:locale" content="ja_JP"><meta name="twitter:card" content="summary"><meta property="twitter:domain" content="https://jser.info/watch-list-rss/"><meta property="twitter:url" 
content="https://jser.info/watch-list-rss/"><meta name="twitter:title" content="azukiazusa のテックブログ2のフィード｜JSer.info Watch List RSS"><meta name="twitter:description" content="JSer.infoの情報源となるサイトのRSSフィードをまとめたサイトです。JavaScriptの情報源を集めることを目的としています。"><meta name="twitter:image" content="https://jser.info/watch-list-rss/images/og-image.png?hash=c56ba3x"><meta name="thumbnail" content="https://jser.info/watch-list-rss/images/og-image.png?hash=c56ba3x"><link rel="preload" href="../../styles/bundle.css" as="style"><link rel="shortcut icon" href="../../images/favicon.ico"><link rel="apple-touch-icon" href="../../images/apple-icon.png"><link rel="alternate" type="application/atom+xml" title="Atom Feed" href="../../feeds/atom.xml"><link rel="alternate" type="application/rss+xml" title="RSS2.0" href="../../feeds/rss.xml"><link rel="alternate" type="application/json" href="../../feeds/feed.json"><link rel="stylesheet" type="text/css" href="../../styles/bundle.css"><script async 
src="https://www.googletagmanager.com/gtag/js?id=G-Q66PHF829Y"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-Q66PHF829Y")</script><title>azukiazusa のテックブログ2のフィード｜JSer.info Watch List RSS</title></head><body><header role="banner" class="ui-section-header"><div class="ui-layout-container"><div class="ui-section-header__layout ui-layout-flex"><a href="https://jser.info/watch-list-rss/" role="link" aria-label="#"><img src="../../images/icon.png" alt="サイトロゴ" loading="eager" width="96" height="96"> <span class="ui-section-header__title">JSer.info Watch List RSS</span> </a><a href="https://github.com/jser/watch-list-rss/" role="link" aria-label="#"><img src="../../images/github-mark.png" alt="GitHubロゴ" loading="eager" width="96" height="96"></a></div></div></header><main role="main"><nav class="ui-nav"><div class="ui-layout-container"><div class="ui-section-nav__layout ui-layout-flex"><a 
class="ui-section-nav__link" href="../../">フィード</a> <a class="ui-section-nav__link" href="../../hot/">人気フィード</a> <a class="ui-section-nav__link" href="../../blogs/">ブログ一覧</a></div></div></nav><section class="ui-section-content ui-section-feed"><div class="ui-layout-container"><h2 class="ui-typography-heading">azukiazusa のテックブログ2</h2><div class="ui-container-blog-summary"><div class="ui-blog-summary"><a class="ui-blog-summary__link" href="https://azukiazusa.dev">https://azukiazusa.dev</a><p class="ui-blog-summary__description">azukiazusaのテックブログ2です。週に1回 Web 開発に関する記事をお届けします。フロントエンドに関する分野の記事が中心です。</p></div></div><h3 class="ui-typography-heading">フィード</h3><div class="ui-section-content--feature ui-layout-grid ui-layout-grid-3 ui-container-feed ui-container-feed--no-image"><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/react-to-web-component"><picture><source type="image/webp" 
srcset="../../images/feed-thumbnails/lzlI7Ijs2M-150.webp 150w, ../../images/feed-thumbnails/lzlI7Ijs2M-450.webp 450w" sizes="100vw"><source type="image/jpeg" srcset="../../images/feed-thumbnails/lzlI7Ijs2M-150.jpeg 150w, ../../images/feed-thumbnails/lzlI7Ijs2M-450.jpeg 450w" sizes="100vw"><img alt="記事のアイキャッチ画像" loading="lazy" decoding="async" src="../../images/feed-thumbnails/lzlI7Ijs2M-150.jpeg" width="450" height="236"></picture></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/react-to-web-component">react-to-web-component を使って React コンポーネントを Web Components に変換する</a><div class="ui-feed-item__hatena-count" title="はてなブックマーク数"><img src="../../images/hatenabookmark-icon.png" alt="はてなブックマークアイコン" loading="lazy" width="96" height="96"> <span>42</span></div><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
@r2wc/react-to-web-component は React コンポーネントを Web Components に変換するためのライブラリです。このライブラリを使用することで、React コンポーネントを任意の HTML 要素として使用することが可能になります。</div><div class="ui-feed-item__date" title="2024-10-20 12:06:00">5日前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/declarative-shadow-dom"><picture><source type="image/webp" srcset="../../images/feed-thumbnails/WXD0D-NVji-150.webp 150w, ../../images/feed-thumbnails/WXD0D-NVji-450.webp 450w" sizes="100vw"><source type="image/jpeg" srcset="../../images/feed-thumbnails/WXD0D-NVji-150.jpeg 150w, ../../images/feed-thumbnails/WXD0D-NVji-450.jpeg 450w" sizes="100vw"><img alt="記事のアイキャッチ画像" loading="lazy" decoding="async" src="../../images/feed-thumbnails/WXD0D-NVji-150.jpeg" width="450" height="236"></picture></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/declarative-shadow-dom">HTML だけで Shadow DOM を構築するための宣言型 Shadow DOM</a><div 
class="ui-feed-item__hatena-count" title="はてなブックマーク数"><img src="../../images/hatenabookmark-icon.png" alt="はてなブックマークアイコン" loading="lazy" width="96" height="96"> <span>96</span></div><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">宣言型 Shadow DOM は `` 要素を使用して Shadow DOM を構築する方法です。宣言型 Shadow DOM を使用することで、従来の JavaScript を使用した Shadow DOM の構築方法と比較して、サーバーサイドレンダリング（SSR）に対応しているため、パフォーマンスの向上や SEO 対策に期待されます。</div><div class="ui-feed-item__date" title="2024-10-19 06:45:00">6日前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/chrome-internal-ai-language-detection-api"><picture><source type="image/webp" srcset="../../images/feed-thumbnails/qLGrJaEL_c-150.webp 150w, ../../images/feed-thumbnails/qLGrJaEL_c-450.webp 450w" sizes="100vw"><source type="image/jpeg" srcset="../../images/feed-thumbnails/qLGrJaEL_c-150.jpeg 150w, ../../images/feed-thumbnails/qLGrJaEL_c-450.jpeg 450w" sizes="100vw">
<img alt="記事のアイキャッチ画像" loading="lazy" decoding="async" src="../../images/feed-thumbnails/qLGrJaEL_c-150.jpeg" width="450" height="236"></picture></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/chrome-internal-ai-language-detection-api">Chrome の組み込み AI の Language Detection API で言語を判定する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Language Detection API は Chrome に組み込まれた AI により、クライアントサイドで言語を判定するための提案です。この API を利用することで、テキストの言語を判定することが可能になります。</div><div class="ui-feed-item__date" title="2024-10-14 07:58:00">11日前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/try-chrome-internal-ai-summarization-api"><picture><source type="image/webp" srcset="../../images/feed-thumbnails/dW1LtqNhRC-150.webp 150w, ../../images/feed-thumbnails/dW1LtqNhRC-450.webp 450w" sizes="100vw"><source type="image/jpeg" 
srcset="../../images/feed-thumbnails/dW1LtqNhRC-150.jpeg 150w, ../../images/feed-thumbnails/dW1LtqNhRC-450.jpeg 450w" sizes="100vw"><img alt="記事のアイキャッチ画像" loading="lazy" decoding="async" src="../../images/feed-thumbnails/dW1LtqNhRC-150.jpeg" width="450" height="236"></picture></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/try-chrome-internal-ai-summarization-api">Chrome の組み込み AI の Summarization API を試してみる</a><div class="ui-feed-item__hatena-count" title="はてなブックマーク数"><img src="../../images/hatenabookmark-icon.png" alt="はてなブックマークアイコン" loading="lazy" width="96" height="96"> <span>94</span></div><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Google では大規模言語モデル（LLM）などの AI モデルをブラウザに直接統合するように設計された、Web プラットフォーム API とブラウザ機能を開発しています。これには Gimini Nano という AI モデルが含まれており、デスクトップパソコンにおいてローカルで実行されるように設計されています。この記事では Summarization API を使用して、文章を要約してみます。</div><div class="ui-feed-item__date" 
title="2024-10-13 04:27:00">12日前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/storybook-and-vitest-integration"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/storybook-and-vitest-integration">Storybook と Vitest の統合したコンポーネントテスト</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Storybook v8.3 以降、ストーリーをテストするためのテストランナーとして Vitest を使用できるようになりました。Vitest を使用することで複雑なセットアップが不要になります。また、推奨されているブラウザモードを使用することで、実際のブラウザでの挙動をより正確に再現できます。</div><div class="ui-feed-item__date" title="2024-10-06 06:39:00">19日前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/close-watcher-api"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" 
width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/close-watcher-api">UI を閉じる動作を処理する CloseWatcher API</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">CloseWatcher API は UI を閉じる動作を処理するための API です。キーボードの `Esc` キー、Android の戻るボタンなどのデバイス固有のメカニズムによって閉じるイベントを提供します。</div><div class="ui-feed-item__date" title="2024-09-28 06:08:00">1ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/2fo3q3hxoB0bSvZBDghtCM"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/2fo3q3hxoB0bSvZBDghtCM">ユーザーのカラースキーマ設定を上書きする web preferences API の提案</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
ユーザーのカラーテーマの設定によりスタイルを変更するためには、`prefers-color-scheme` メディアクエリを使用することが一般的です。しかし、多くのウェブサイトでは OS の設定とは独立してカラースキーマを設定する機能が提供されています。この場合、`prefers-color-scheme` メディアクエリを使用せずに、`class` 属性を使ったスタイルの切り替えが行われます。</div><div class="ui-feed-item__date" title="2024-09-21 15:00:00">1ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/customizable-select-element"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/customizable-select-element">スタイルをカスタマイズ可能な新しい `&lt;select&gt;` 要素</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">従来の `` 要素は CSS を利用したスタイルを適用することができないため、多くの開発者にとって課題となっていました。この問題を解決するために新しい既存の `` 要素をカスタマイズする手段が提案されました。この疑似要素を利用することで、開発者は `` 要素のスタイルをカスタマイズをオプトインできるようになります。</div><div class="ui-feed-item__date" 
title="2024-09-21 02:59:00">1ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/calc-size-animation"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/calc-size-animation">`calc-size()` や `interpolate-size: allow-keywords;` で `height: auto;` な要素のアニメーションをサポートする</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">CSS において height プロパティを 0 から auto に変化させた場合に、アニメーションが適用されないのはよく知られた問題です。この記事では calc-size() 関数を使って height: auto; な要素のアニメーションを実装する方法を紹介します。</div><div class="ui-feed-item__date" title="2024-09-14 06:06:00">1ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/react-aria-drag-and-drop"><img src="../../images/alternate-feed-image.png" loading="lazy" 
alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/react-aria-drag-and-drop">アクセシビリティが考慮された React Aria のドラッグアンドドロップ</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">React Aria は Adobe により提供されている React 用のコンポーネントライブラリであり、アクセシビリティを最優先した設計となっています。本記事では、React Aria により提供されているドラッグアンドドロップ機能を紹介します。</div><div class="ui-feed-item__date" title="2024-09-07 06:17:00">2ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/openfeature-react-sdk"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/openfeature-react-sdk">フィーチャーフラグの標準規格 OpenFeature の React SDK を試してみる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div 
class="ui-feed-item__summary">OpenFeature はフィーチャーフラグのオープンな規格です。特定のベンダーに依存しない API や SDK が提供されています。フィーチャーフラグの API の標準化により、ベンダーロックインを回避し、フィーチャーフラグのツールを自由に選択できるようになります。この記事では OpenFeature の React SDK を使ってフィーチャーフラグを評価する方法を紹介します。</div><div class="ui-feed-item__date" title="2024-08-31 07:56:00">2ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/react-aria-accessible-component"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/react-aria-accessible-component">React Aria でアクセシブルなコンポーネントを作成する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
React Aria は Adobe が提供する React 用のコンポーネントライブラリです。スタイルを持たずに UI の機能やロジックのみを提供するいわゆるヘッドレス UI ライブラリであり、特に React Aria はアクセシビリティを最優先した設計となっているのが特徴です。ヘッドレス UI ライブラリを用いて UI コンポーネントを実装することで、開発者はビジネスロジックやデザインに集中することができます。</div><div class="ui-feed-item__date" title="2024-08-25 06:34:00">2ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/axe-core-playwright"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/axe-core-playwright">@axe-core/playwright によるアクセシビリティテストの自動化</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">axe-core は axe というアクセシビリティテストツールのコアエンジンで、オープンソースとして提供されています。この記事では、E2E テストフレームワークの Playwright と axe-core を組み合わせて使用して、アクセシビリティテストを自動化する方法について紹介します。</div><div class="ui-feed-item__date" title="2024-08-18 03:53:00">
2ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/box-shadow-focus-ring-not-visible-in-high-contrast-mode"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/box-shadow-focus-ring-not-visible-in-high-contrast-mode">box-shadow で実装されたフォーカスリングはハイコントラストモードで表示されない</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">フォーカスリングとは、キーボード操作でフォーカスが当たった要素を視覚的に示すための UI デザインのことです。フォーカスリングのカスタマイズに `box-shadow` プロパティを使うことがありますが、ハイコントラストモードではフォーカスリングが表示されない問題があります。この記事では、ハイコントラストモードでフォーカスリングを表示する方法について解説します。</div><div class="ui-feed-item__date" title="2024-08-11 05:42:00">2ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/css-reading-flow-property"><img 
src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/css-reading-flow-property">CSS の `reading-flow` プロパティで要素の読み上げ順を制御する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Flex や Grid コンテナ内では要素の見た目上の順序と DOM 上の順序が異なることがあります。このような状態はキーボード操作やスクリーンリーダーなどの支援技術を使うユーザーにとって混乱を招く可能性があります。CSS の `reading-flow` プロパティ個の問題を解決するためのプロパティです。見た目上の順序に従って読み上げ順を制御することができます。</div><div class="ui-feed-item__date" title="2024-08-03 06:33:00">3ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/css-random-function"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/css-random-function">
CSS でランダムな値を扱う `random()` と `random-item()` 関数</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">`random()` と `random-item()` 関数は CSS でランダムな値を扱うための関数です。`random()` 関数は最小値と最大値を引数に取り、その範囲内のランダムな数値を返します。`random-item()` 関数は引数に渡したリストの中からランダムに 1 つの値を返します。</div><div class="ui-feed-item__date" title="2024-07-28 08:06:00">3ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/new-build-tool-farm"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/new-build-tool-farm">新しいビルドツールの Farm</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
Farm は Rust 製の新しいビルドツールです。パフォーマンスを重視して設計されており、Vite と互換性のある JavaScript プラグインをサポートしているという特徴があります。バンドルの戦略には Partial Bundling というものを採用しており、モジュールのネットワークリクエスト数を削減するため、20 ~ 30 のファイルにバンドルするという特徴があります。</div><div class="ui-feed-item__date" title="2024-07-21 06:44:00">3ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/define-custom-properties-with-css-property-rule"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/define-custom-properties-with-css-property-rule">CSS の `@property` ルールでカスタムプロパティを定義する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
CSS の @property ルールを使うことで、CSS のカスタムプロパティを定義できます。カスタムプロパティを定義することでプロパティの構文チェック、デフォルト値の設定、プロパティが値を継承するかどうかの設定などが可能になります。カスタムプロパティに誤った値が代入されることを防いだり、グラデーションのアニメーションなど、従来は実装が難しかった機能をサポートすることができます。</div><div class="ui-feed-item__date" title="2024-07-13 07:16:00">3ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/scope-rule-in-css"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/scope-rule-in-css">スタイルの適用範囲を限定する CSS の `@scope` ルール</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">`@scope` アットルールは特定のセレクタの範囲に限定したスタイルを適用するためのルールです。`@scope` のルールセットに 1 つの CSS セレクタを指定すると、そのセレクタがスコープのルートとなります。`@scope` ルール内のスタイルはそのセレクタの範囲内でのみ適用されます。</div><div class="ui-feed-item__date" title="2024-07-07 07:46:00">4ヶ月前</div></div></div><div 
class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/manage-styles-structurally-with-css-cascade-layer"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/manage-styles-structurally-with-css-cascade-layer">CSS のカスケードレイヤー `@layer` を使ってスタイルを階層化して管理する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">CSS の `@layer` ルールは、カスケードレイヤーを宣言するために使用されます。カスケードレイヤーとは、スタイルの優先度をレイヤー（階層）に分けて管理する仕組みです。`@layer` ルールを使用することでスタイルの記述順や詳細度に関係なくスタイルを宣言できるため、新しい形式の CSS 設計を実現することができます。</div><div class="ui-feed-item__date" title="2024-06-30 07:47:00">4ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/1I2o5hV41vUHNH8mMXWN9h"><img src="../../images/alternate-feed-image.png" loading="lazy" 
alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/1I2o5hV41vUHNH8mMXWN9h">TypeScript で配列の要素を取得する時 `.at()` メソッドを使うとより安全</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">JavaScript で配列にアクセスする際、配列の長さを超えるインデックスを指定すると `undefined` が返されることがあります。しかし、TypeScript の型定義上では、配列の長さを超えるインデックスを指定しても `undefined` 型が返されることはありません。これはランタイムエラーを引き起こす恐れがあります。</div><div class="ui-feed-item__date" title="2024-06-24 15:00:00">4ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/when-else-rule-in-css"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/when-else-rule-in-css">CSS で条件分岐を行う `@when/@else` ルール</a><div 
class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">`@when/@else` アットルールは条件付きスタイルをまとめて記述するためのルールです。`@media` や `@support` の条件を `@when` にわたすことで、`true` の場合には `@when` ブロック内のスタイルが、`false` の場合には `@else` ブロック内のスタイルが適用されます。このルールを使うことでより簡潔なコードを書くことができます。</div><div class="ui-feed-item__date" title="2024-06-22 06:36:00">4ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/use-mask-image-css-property-to-display-svg-icons"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/use-mask-image-css-property-to-display-svg-icons">SVG アイコンの表示に mask-image CSS プロパティを使用する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
mask-image プロパティは CSS でマスキングを行うためのプロパティであり、SVG アイコンを表示する際に有用です。mask-image プロパティを使用することで、外部の SVG ファイルを読み込みつつ、アイコンの色を CSS で指定することが可能になります。</div><div class="ui-feed-item__date" title="2024-06-15 06:35:00">4ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/try-chrome-internal-ai-gemini-nano"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/try-chrome-internal-ai-gemini-nano">Chrome の 組み込み AI Gemini Nano を試してみる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Chrome 126 から Gemini Nano という AI がデスクトップクライアントに組み込まれる予定です。Gemini Nano は Google の AI モデルの中で最も小さいモデルです。デスクトップクライアントに直接組み込まれることで、ユーザーの手元の環境で AI を利用できることが特徴です。開発者は JavaScript から Chrome に組み込まれた Gemini Nano にアクセスして生成 AI の機能を実装することができます。</div><div 
class="ui-feed-item__date" title="2024-06-11 10:19:00">4ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/starting-style-rule-for-css-transitions"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/starting-style-rule-for-css-transitions">CSS トランジションの開始時のスタイルを定義する `@starting-style` ルール</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">`@starting-style` ルールは、CSS トランジションの開始時のスタイルを定義するためのアットルールです。CSS トランジションの既定のルールでは前回のスタイル変更イベントでレンダリングされていなかった要素では、アニメーションが適用されない、`display: none` から他の値に変更した場合にアニメーションが適用されないといった問題があります。`@starting-style` ルールを使用することでこれらの問題を解決できます。</div><div class="ui-feed-item__date" title="2024-06-09 06:22:00">5ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" 
href="https://azukiazusa.dev/blog/scrollbar-gutter-css-property-to-prevent-screen-jitter-due-to-scroll-bar-switching"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/scrollbar-gutter-css-property-to-prevent-screen-jitter-due-to-scroll-bar-switching">scrollbar-gutter CSS プロパティでスクロールバーの切り替わりによる画面のガタツキを解消する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">子要素が親要素のボックスからはみ出した時、overflow プロパティの値が auto または scroll の場合にスクロールバーが表示されます。スクロールバーがクラシックスクロールバーの場合、スクロールバーの表示・非表示によりボックスの幅が変わるため、画面がガタつくことがあります。scrollbar-gutter プロパティを使うとスクロールバー用のスペースをあらかじめ確保でき、画面のガタツキを解消できます。</div><div class="ui-feed-item__date" title="2024-06-01 06:30:00">5ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/sveltekit-tutorial-create-a-blog-site">
<img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/sveltekit-tutorial-create-a-blog-site">SvelteKit チュートリアル - 記事投稿サイトを作ってみよう</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">SvelteKit は Svelte と Vite で構築たフレームワークです。SvelteKit は Web アプリケーションを開発するために必要な機能を提供します。この記事では、SvelteKit を使用して記事投稿サイトを作成するチュートリアルを紹介します。記事投稿サイトは、記事の一覧表示、記事の詳細表示、記事の投稿、記事の削除の機能を持つシンプルな Web アプリケーションです。</div><div class="ui-feed-item__date" title="2024-05-26 05:28:00">5ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/svelte-v5-snippet-feature"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" 
href="https://azukiazusa.dev/blog/svelte-v5-snippet-feature">Svelte v5 で導入されるスニペット機能</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Svelte v5 ではスニペットと呼ばれる新しい機能が導入されます。スニペットとは、コンポーネント内で使用できる再利用可能なマークアップのことです。`#snippet` ディレクティブを使用してスニペットを定義し、引数を受け取ることができます。スニペットを呼び出す際には `@render` ディレクティブを使用します。またスニペットは単なる値として扱われるため、コンポーネントの Props として渡すことができます。</div><div class="ui-feed-item__date" title="2024-05-19 04:36:00">5ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/react-use-optimistic-hook"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/react-use-optimistic-hook">楽観的更新を行うための React の useOptimistic フック</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
React v19 では楽観的更新を行うための `useOptimistic` フックが導入される予定です。楽観的更新とは、ユーザーの操作に対して非同期処理の完了を待たずに UI を更新する手法のことです。楽観的更新によりユーザーの操作に対して即座にフィードバックを提供できるため、UX の向上につながります。</div><div class="ui-feed-item__date" title="2024-05-12 04:43:00">5ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/svelte-v5-event-handlers"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/svelte-v5-event-handlers">Svelte v5 における イベントハンドラの変更点</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Svelte v5 では、イベントハンドラの書き方が一新され、いくつか非推奨となった書き方があります。この記事では、Svelte v4 と Svelte v5 のイベントハンドラの書き方の違いについて見ていきます。</div><div class="ui-feed-item__date" title="2024-05-05 06:15:00">6ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" 
href="https://azukiazusa.dev/blog/svelte-reactivity-system-with-runes"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/svelte-reactivity-system-with-runes">Svelte v5 で導入された Runes によるリアクティビティシステム</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Svelte v5 で導入された Runes によるリアクティビティシステムについて解説します。従来の Svelte は純粋な JavaScript のコードのみを使用してリアクティビティを実現していましたが、アプリケーションが大規模になると複雑性が増すという問題がありました。Runes は Svelte のリアクティビティシステムをより柔軟にし、アプリケーションの規模が大きくなってもシンプルさを保つことを目指しています。</div><div class="ui-feed-item__date" title="2024-05-04 05:54:00">6ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/typescript-library-for-safer-error-handling-and-async-operations-effect-ts"><img src="../../images/alternate-feed-image.png" loading="lazy" 
alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/typescript-library-for-safer-error-handling-and-async-operations-effect-ts">エラーや非同期処理をより安全に扱うための TypeScript ライブラリ Effect-TS</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Effect-TS は、開発者が複雑なエラーや非同期処理をより安全に開発できるようにすることを目的とした TypeScript ライブラリです。Effect-TS は、TypeScript の型システムを活用して、本番のアプリケーションにおける実用的な問題を解決することを目指しています。</div><div class="ui-feed-item__date" title="2024-04-29 05:54:00">6ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/nextjs-typed-routes"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/nextjs-typed-routes">Next.js 型安全なルーティングを使う</a><div 
class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Next.js では実験的な機能として、型安全なルーティングを利用できます。この機能を使うことでリンク先のパス名を静的に検査できるため、typo などのエラーを事前に防ぐことができます。</div><div class="ui-feed-item__date" title="2024-04-28 06:46:00">6ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/53WOkRFJq2m0UvpiEH4RV8"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/53WOkRFJq2m0UvpiEH4RV8">React v19 から forwardRef が不要になる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">今までの React では `ref` をコンポーネントの Props として渡す際に、`forwardRef` を使ってラップする必要がありました。しかし、React v19 からは `forwardRef` が不要になり、`ref` を直接渡すことができるようになりました。</div><div class="ui-feed-item__date" title="2024-04-27 15:00:00">6ヶ月前</div></div></div>
<div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/single-fetch-in-remix"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/single-fetch-in-remix">Remix v2.9 で導入された Single Fetch</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Remix v2.9 で導入された Single Fetch はクライアントサイドでのページ遷移が行われた際に、サーバーへの複数の HTTP リクエストを並行して行う代わりに、1 つの HTTP リクエストを実行しまとめてレスポンスを返す機能です。Single Fetch は v2.9 ではフィーチャーフラグとして提供されており、v3 以降ではデフォルトの挙動となります。</div><div class="ui-feed-item__date" title="2024-04-27 05:08:00">6ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/6Q3axtdkljrdkl9jiahurP"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div 
class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/6Q3axtdkljrdkl9jiahurP">Math.max() にスプレッド構文で大きな配列を渡すとエラーになる恐れがある</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">`Math.max()` は、引数に渡された数値のうち最大のものを返す JavaScript の組み込み関数です。この関数は任意の数の引数を受け取るので、配列最大値を求めたい場合にはスプレッド構文で展開して渡す使い方が一般的です。しかし、引数の数が多すぎるとエラーになることがあります。</div><div class="ui-feed-item__date" title="2024-04-21 15:00:00">6ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/relative-css-units-based-on-container-elements"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/relative-css-units-based-on-container-elements">コンテナ要素に基づく相対的な CSS の単位（cqw, cqh, cqi, cqb, cqmin, cqmax）</a><div class="ui-feed-item__blog-title">
azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">コンテナクエリ単位とは、コンテナ要素に基づいてスタイルを定義するための相対的な長さを表す単位です。例えば `1cqw` はコンテナ要素の幅の 1% に相当します。</div><div class="ui-feed-item__date" title="2024-04-21 02:22:00">6ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/3xubuPzazJ86RlN8Br7Lm3"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/3xubuPzazJ86RlN8Br7Lm3">CSS でファイルのアップロードボタンをカスタマイズする ::file-selector-button 疑似要素</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">`::file-selector-button` 疑似要素を使用することで、`` 要素のデフォルトのボタンのスタイルをカスタマイズできます。現在すべてのモダンブラウザでサポートされています。</div><div class="ui-feed-item__date" title="2024-04-15 15:00:00">6ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" 
href="https://azukiazusa.dev/blog/css-anchor-positioning"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/css-anchor-positioning">ポップアップが画面内に収まらない場合に自動的に表示位置を調整する CSS Anchor Positioning</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">CSS Anchor Positioning とは、特定の要素を Anchor（基準）としてツールチップなどの要素の位置を決定する機能の総称です。CSS Anchor Positioning を使用することで、Floating UI のように自動で画面内に表示されるツールチップやコンテキストメニューを実装できます。</div><div class="ui-feed-item__date" title="2024-04-13 06:49:00">6ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/promise-context-value-react-hook"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a 
class="ui-feed-item__title" href="https://azukiazusa.dev/blog/promise-context-value-react-hook">Promise や Context から値を読み取る use React フック</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">React の Canary および experimental チャンネルでのみ利用可能な `use` フックについて解説します。`use` フックは Promise や Context から値を読み取るためのフックで、Promise の値を同期的に読み取ることができます。その他の React フックと異なり、`if` 文やループ内で呼び出すことができる点が特徴として挙げられます。</div><div class="ui-feed-item__date" title="2024-04-07 01:33:00">7ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/container-style-query-in-css"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/container-style-query-in-css">親要素のスタイルの基づいてスタイルを適用するコンテナスタイルクエリー CSS</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div 
class="ui-feed-item__summary">CSS の @container ルールは、コンテナ（親要素）の特性に基づいてスタイルを適用するためのルールです。コンテナースタイルクエリーはコンテナサイズクエリーとコンテナスタイルクエリーの 2 種類に分類されます。コンテナスタイルクエリは style() 関数記法で定義されたスタイルを @container ルールで評価し、指定された条件が一致する場合にスタイルが適用されます。</div><div class="ui-feed-item__date" title="2024-03-30 05:12:00">7ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/5DNVLeqAtB5yYui390DNvS"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/5DNVLeqAtB5yYui390DNvS">CSS: ダークモードで値を切り替える light-dark 関数</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">light-dark 関数は CSS のカラー関数で、引数に 2 つのカラー値を取り、ライトモードのときには 1 つ目の値をを、ダークモードのときには 1 つ目の値を返します。`color-scheme` プロパティの値もしくはユーザーの OS のダークモード設定によって切り替わります。</div><div class="ui-feed-item__date" 
title="2024-03-27 15:00:00">7ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/css-to-react-component-with-mistcss"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/css-to-react-component-with-mistcss">CSS から React コンポーネントを生成する MistCSS</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">MistCSS は CSS in JS になぞらえた JS from CSS というコンセプトで、CSS から React コンポーネントを生成するツールです。ピュアな CSS を記述できるので、学習コストが低い、パフォーマンスに影響がないといったメリットがあります。</div><div class="ui-feed-item__date" title="2024-03-23 05:18:00">7ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/unit-test-visual-screen-reader"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" 
width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/unit-test-visual-screen-reader">単体テストでスクリーンリーダーをシミュレートする Virtual Screen Reader</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Virtual Screen Reader は単体テストのためにスクリーンリーダをシミュレートするライブラリです。このライブラリを使うことでマウスやキボードの操作をテストするように、スクリーンリーダーにより期待する読み上げが行われるかどうかをテストできます。なお、Virtual Screen Reader はあくまでスクリーンリーダーの挙動を模倣したものであり、現実で使われているスクリーンリーダーによるテストを代替するものではないことに注意してください。</div><div class="ui-feed-item__date" title="2024-03-16 04:20:00">7ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/2jii12VuEFgjUUEzSDpjEy"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/2jii12VuEFgjUUEzSDpjEy">
TypeScript 5.5 で関数による型の絞り込みが改善される</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">従来までは、TypeScript で関数の引数の型を絞り込んだ結果を返す場合には、ユーザー定義型ガードとして `x is string` のような形式で型ガードを定義する必要がありました。TypeScript 5.5 では自動で型の絞り込みが推論されるようになります。</div><div class="ui-feed-item__date" title="2024-03-15 15:00:00">7ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/form-accessibility"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/form-accessibility">フォームのアクセシビリティを考える</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
今日の Web におけるフォームはユーザーが情報を入力して対話するための重要な要素です。支援技術を利用しているユーザーがフォームの入力を妨げられることは当然避けるべきでしょう。また障害の有無に関わらず、ユーザーに迷いを与えたり、入力ミスを誘発するようなフォームはユーザーがタスクを完了せずに途中で離脱してしまう可能性が高まり、ビジネスの観点からも望ましくありません。この記事ではフォームのアクセシビリティについて考え、実際のフォームの実装においてどのような点に注意すべきかを紹介します。</div><div class="ui-feed-item__date" title="2024-03-10 05:06:00">8ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/75AEHrLoJIw1jQtCgE02Xn"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/75AEHrLoJIw1jQtCgE02Xn">CSS メディアクエリで比較演算子が使える</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">CSS のメディアクエリで比較演算子（``, `=`）が使えます。この記法を Range Syntax と呼びます。この記法は従来の `min-width` や `max-width` といった記法と比べて、より直感的に記述できるため便利です。</div><div class="ui-feed-item__date" 
title="2024-03-02 15:00:00">8ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/react-server-components-minimal-framework-waku"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/react-server-components-minimal-framework-waku">React Server Components を使うためのミニマムなフレームワーク Waku</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Waku は小規模から中規模の React プロジェクトを構築するためのミニマムなフレームワークです。従来は React Server Components を使うためには Next.js のような比較的大規模なフレームワークが必要でした。Waku もまた React Server Components に対応しているため、最小限の構成で React Server Components を使いたい場合に適しています。</div><div class="ui-feed-item__date" title="2024-03-02 07:13:00">8ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" 
href="https://azukiazusa.dev/blog/shorts/1qEr3YBzjVTUbtDrlTdGHG"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/1qEr3YBzjVTUbtDrlTdGHG">1 つの AbortController で複数の fetch をキャンセルできる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">`AbortController` は、fetch API でリクエストをキャンセルするためのオブジェクトです。`AbortController` は複数のリクエストを 1 度にキャンセルできます。</div><div class="ui-feed-item__date" title="2024-02-29 15:00:00">8ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/6TnCzA1HWOiWmIAVx0a3Gx"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" 
href="https://azukiazusa.dev/blog/shorts/6TnCzA1HWOiWmIAVx0a3Gx">CSS の reverse 系の値は可能な限り使わない</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">CSS の reverse 系の値とは、`flex-direction` の `row-reverse` や `column-reverse` などのことです。これらの値は、アクセシビリティの観点からできる限り使用を避けるべきです。</div><div class="ui-feed-item__date" title="2024-02-27 15:00:00">8ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/safetest-a-test-library-offering-a-new-ui-testing-approach"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/safetest-a-test-library-offering-a-new-ui-testing-approach">新しい UI テストの手法を提供するテストライブラリ SafeTest</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
SafeTest は Playwright と Jest/Vitest を組み合わせた UI テストライブラリです。特定のライブラリに依存せず、React, Vue, Angular, Svelte などのフレームワークに対応しています。SafeTest は単体テストと Playwright を使った E2E テストの手法を組み合わせることで、それぞれの手法が抱える欠点を補うことを目指しています。</div><div class="ui-feed-item__date" title="2024-02-25 04:14:00">8ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/write-articles-for-technical-practice"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/write-articles-for-technical-practice">技術の素振りのために記事を書く</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
技術の素振りを、ここではある特定の言語やフレームワークに対する理解を深めるために、その技術を使って何かしらの成果物を作成することと定義します。素振りの目的としては、ドキュメントからは読み取れない Pro/Con を得ること、その技術が実際のプロジェクトで使えるかどうか調査するといった事項があげられるでしょう。ただ素振りするだけではぼんやりと頭に知識が入っている状態になりがちですが、他者への説明というアウトプットを意識することで、コードを書くことによって得られた知見を整理できるようになります。</div><div class="ui-feed-item__date" title="2024-02-20 09:16:00">8ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/beginner-friendly-simple-rules"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/beginner-friendly-simple-rules">初心者向けの単純なルールを作る</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">新しい物事を始めるときは複雑な理屈は抜きにして、単純なルールが規定されていることが初心者にとって大切です。この理屈は開発時の設計やコーディングルールにも当てはまると思います。単純なルールとして lint を設定したり、コンポーネント化して複雑な部分を隠蔽することですべての開発者にとってコードをコミットしやすくなります。</div><div 
class="ui-feed-item__date" title="2024-02-19 09:59:00">8ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/type-safe-and-progressive-enhancement-form-library-conform"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/type-safe-and-progressive-enhancement-form-library-conform">type-safe とプログレッシブエンハンスメント、アクセシビリティヘルパーを備えたフォームライブラリ Conform</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Conform は React 向けのフォームライブラリです。type-safe であること、Web 標準を利用したプログレッシブエンハンスメントや、アクセシビリティヘルパーを特徴としており、Next.js の Server Actions や Remix に対応しています。</div><div class="ui-feed-item__date" title="2024-02-18 04:30:00">8ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" 
href="https://azukiazusa.dev/blog/full-stack-web-framework-honox"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/full-stack-web-framework-honox">フルスタック Web フレームワーク HonoX を使ってみる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">HonoX は Hono と Vite をベースにしたフルスタック Web フレームワークです。Hono が提供するサーバーサイドやクライアントサイドの機能を使いつつ、ファイルベースルーティングや Islands Architecture などの新しい機能を使うことができます。</div><div class="ui-feed-item__date" title="2024-02-10 07:55:00">8ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/tailwind-css-libs"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" 
href="https://azukiazusa.dev/blog/tailwind-css-libs">Tailwind CSS を使う時に一緒に入れたいライブラリ</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Tailwind CSS を使う上でクラス名をスッキリと書くために一緒に入れたいライブラリを紹介します</div><div class="ui-feed-item__date" title="2024-02-03 10:26:00">9ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/hono-streaming-response"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/hono-streaming-response">Hono で Server-Sent Events によるストリーミングを実装する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Server-Sent events（SSE）は、サーバーからクライアントに向けてイベントをストリーミングするための仕組みです。WebSocket と比較すると、サーバーからの単方向の通信、HTTP で通信するという特徴があります。この記事では Hono を使って OpenAI API を使ったテキスト生成をストリーミングする方法を紹介します。
</div><div class="ui-feed-item__date" title="2024-02-01 11:43:00">9ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/5g2wGcIq0uuPn1jn9soemE"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/5g2wGcIq0uuPn1jn9soemE">npm は isntall でもコマンドを実行できる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">npm は install の alias として isntall が用意されているので、typo して isntall と打ってもコマンドが実行されます。</div><div class="ui-feed-item__date" title="2024-01-31 15:00:00">9ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/5KH0RavVHAFFwAHMcLQGSg"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div 
class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/5KH0RavVHAFFwAHMcLQGSg">クラス名の結合をする軽量ライブラリの clsx</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">clsx は、複数のクラス名を結合するための軽量ライブラリです。条件によってクラスを付け替えたり、グルーピングをする際に簡潔に記述できます。</div><div class="ui-feed-item__date" title="2024-01-27 15:00:00">9ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/typescript-like-syntax-for-openapi-schemas"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/typescript-like-syntax-for-openapi-schemas">TypeScript のような構文で OpenAPI のスキーマを定義する TypeSpec</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
TypeSepc は TypeScript にインスパイアされた言語で、開発者が親しみやすい構文で OpenAPI のスキーマを定義できます。モデルを使ってデータの構造を定義し、`@route` デコレーターを使って REST API のエンドポイントを定義します。</div><div class="ui-feed-item__date" title="2024-01-27 04:48:00">9ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/5BUGlsWJn2QzxIgFYvkrds"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/5BUGlsWJn2QzxIgFYvkrds">CSS で絶対に最前面に表示したい要素には z-index:calc(infinity) を指定する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">いつの時代にも z-index の管理には頭を悩ませます。z-index の値には 1 以外の値を許可しないなどの管理方法がありますが、外部のライブラリを使用してる場合に勝つことができません。そこで z-index の値に `calc(infinity)` を指定すると、絶対に最前面に表示させることができます。</div><div class="ui-feed-item__date" title="2024-01-25 15:00:00">9ヶ月前</div></div></div><div 
class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/3YJDVYrF4mHiqMsnmzUQvW"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/3YJDVYrF4mHiqMsnmzUQvW">Node.js esm の dirname と filename</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">commonjs では `__dirname` と `__filename` でファイルのパスを取得できますが ES Modules では使えません。今まで同等の API が存在していなかったのですが、Node.js v20.11.0 で `import.meta.dirname` と `import.meta.filename` が追加されました。</div><div class="ui-feed-item__date" title="2024-01-23 15:00:00">9ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/bun-cross-platform-shell-script"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a>
<div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/bun-cross-platform-shell-script">Bun でクロスプラットフォームなシェルスクリプト</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Bun の `$` を使うと、クロスプラットフォームなシェルスクリプト（Bun Shell）を書くことができます。Bun Shell は macOS (zsh)、Linux (bash)、および Windows (cmd) と OS の違いを気にせずにシェルスクリプトを書ける、JavaScript オブジェクトとのやりとりが可能であることが特徴です。</div><div class="ui-feed-item__date" title="2024-01-20 11:01:00">9ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/73zH9ULSIWeA55tA6corT8"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/73zH9ULSIWeA55tA6corT8">MSW v2 では　Web 標準の Fetch API をサポート</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div 
class="ui-feed-item__summary">Mock Service Worke（MSW） v2 では Web 標準の Fetch API をサポートしました。</div><div class="ui-feed-item__date" title="2024-01-14 15:00:00">9ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/remix-spa-mode"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/remix-spa-mode">Remix の SPA モード</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Remix は React のフルスタックフレームワークで、Web 標準に基づいた API で構築されていることが特徴です。Node.js のようなサーバーサイドの JavaScript 環境で動作することを前提としています。しかし、現実の世界ではサーバーを用意せずに、静的なファイルをホスティングするだけの環境で Web アプリケーションを構築することが有効な場合も多くあります。このような需要を満たすために、Remix v2.5.0 から実験的に SPA モードが導入されました。</div><div class="ui-feed-item__date" title="2024-01-14 02:22:00">9ヶ月前</div></div></div><div class="ui-feed-item"><a 
class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/4Tq3csJ5BwAXPR4OBuJvIo"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/4Tq3csJ5BwAXPR4OBuJvIo">TypeScript で任意の文字列を受け取りつつエディタの補完を効かせる型</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">すべての文字列を受け入れつつ、特定の文字列のみを補完候補に表示させたい場合があります。例えば、CSS の色を指定するプロパティの値には、カラーコードで指定する `#000000` や `#ffffff` などの文字列を受け入れつつ、`red` や `blue` などの特定の文字列を指定します。</div><div class="ui-feed-item__date" title="2024-01-12 10:13:00">9ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/3rHXViGZDvnLN3TGQqZ2TP"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a 
class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/3rHXViGZDvnLN3TGQqZ2TP">React でコンポーネントの Props の型を取得する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">プリミティブな UI を構築するとき、button や input などの HTML 要素をラップしたコンポーネントを作成することがあります。このようなコンポーネントでは、HTML 要素の Props に加えて、コンポーネント固有の Props を定義することが多いです。</div><div class="ui-feed-item__date" title="2024-01-11 15:00:00">9ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/47G6Ncc9VEZ1qOIGaZ9eOx"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/47G6Ncc9VEZ1qOIGaZ9eOx">配列をグループ化する Object.groupBy 静的メソッド</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
Object.groupBy 静的メソッドは、ES2024 で追加された配列をグループ化する関数です。配列の各要素に対してグループ化のキーを指定することで、グループ化されたオブジェクトを返します。</div><div class="ui-feed-item__date" title="2024-01-10 20:00:00">9ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/5VaSPYejGTbfPNm8xK8TqN"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/5VaSPYejGTbfPNm8xK8TqN">TailwindCSS で複数行のテキストを省略するとき</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">TailwindCSS で長いテキストを省略するときには、`truncate` クラスを使用します。しかし、`truncate` クラスは 1 行のテキストにしか対応していません。</div><div class="ui-feed-item__date" title="2024-01-10 17:00:00">9ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/23dS5pxOnX9UmrJFiCERQw"><img 
src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/23dS5pxOnX9UmrJFiCERQw">tabIndex には 0 と -1 だけを指定する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">tabIndex 属性は、フォーカス可能な要素を指定するための属性です。この属性自由な数値を指定できますが、これはアクセシビリティの観点から推奨されていません。</div><div class="ui-feed-item__date" title="2024-01-10 16:00:00">9ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/7hqTwjmQ3nlA7Nt8W6eceS"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/7hqTwjmQ3nlA7Nt8W6eceS">Svelte の Props 省略記法</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div 
class="ui-feed-item__summary">Svelte ではコンポーネントに Props を渡す際に省略記法が使えます。</div><div class="ui-feed-item__date" title="2024-01-10 15:00:00">9ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/4byw2Sh9S0AQfqL9Tyz08q"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/4byw2Sh9S0AQfqL9Tyz08q">GitHub Copilot Chat の inline chat のキーボードショートカットを無効にする</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">GitHub Copilot Chat を VSCode で使用していると、エディタ上で ⌘ + i を押すと inline chat が表示されます。しかし、このショートカットはコードの補完を表示するためにも使われていました。このショートカットに慣れていた人にとっては、inline chat が表示されるのは意図しない動作でしょう。</div><div class="ui-feed-item__date" title="2024-01-09 16:00:00">9ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" 
href="https://azukiazusa.dev/blog/shorts/1BPeVzWipcnv9IIopiScEd"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/1BPeVzWipcnv9IIopiScEd">details 要素の name 属性による排他的アコーディオン</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">`details` 要素は、開閉可能なコンテンツをマークアップするための要素です。`details` 要素に新たに `name` 属性が追加され排他的アコーディオンとして利用できるようになりました。</div><div class="ui-feed-item__date" title="2024-01-09 15:00:00">9ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/5LiIo1l7qCJN5ptnXUjl8u"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/5LiIo1l7qCJN5ptnXUjl8u">
GitLens で特定のコミットを除外する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">GitLens の使用時に、機械的にフォーマットされたコミットがあるとコードの変更履歴を確認する際に邪魔になってしまいます。この記事では、GitLens で特定のコミットを除外する方法を紹介します。</div><div class="ui-feed-item__date" title="2024-01-08 16:00:00">10ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/48N6K7RZKQhKT83zsu1AMS"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/48N6K7RZKQhKT83zsu1AMS">大きさが自動で変わる textarea を CSS だけで実現</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">テキストの入力量に応じて自動で高さが変わる textarea をよく見かけると思います。Slack や X の入力欄がそうですね。</div><div class="ui-feed-item__date" title="2024-01-08 15:00:00">10ヶ月前</div></div></div><div class="ui-feed-item"><a 
class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/PQPy2VKlf5RDNssDCgdnP"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/PQPy2VKlf5RDNssDCgdnP">TailwindCSS の data 属性</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">TailwindCSS v3.2 からは data 属性を使って、条件付きでスタイルを適用できます。</div><div class="ui-feed-item__date" title="2024-01-07 15:00:00">10ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/static-site-search-engine-and-ui-library-pagefind"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" 
href="https://azukiazusa.dev/blog/static-site-search-engine-and-ui-library-pagefind">静的サイト向けの全文検索エンジンと UI ライブラリの Pagefind</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Pagefind は、静的サイト向けの全文検索エンジンと UI ライブラリです。特定のフレームワークに依存しない JavaScript ライブラリとして実装されており、静的サイトジェネレーターで生成された HTML ファイルに対して検索機能を追加できます。</div><div class="ui-feed-item__date" title="2024-01-06 06:52:00">10ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/books-i-read-in-2023"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/books-i-read-in-2023">2023 年に読んでよかった本</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
年末なので 2023 年のまとめっぽい記事を書きたくなりました。今年は 1 年間でおおよそ 300 冊の本をよんだようです（そのうち 3 割ほどはラノベなのですが...）。その中でも特に印象に残った本を紹介します。</div><div class="ui-feed-item__date" title="2023-12-30 10:22:00">10ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/input-type-checkbox-switch"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/input-type-checkbox-switch">input[type=checkbox] 要素に switch 属性を指定することによる HTML 標準のスイッチ UI の提案</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">スイッチは多くのウェブサイトで使われているものの、HTML の標準要素としては存在していませんでした。そのため多くの開発者は、スイッチを実装するために独自の実装を行っていましたが、このような独自の実装はアクセシビリティの問題を引き起こす可能性がありました。この問題を解決するために、WHATWG により `input[type=&quot;checkbox&quot;]` 要素に `switch` 属性を追加することが提案されました。この属性を指定することで、チェックボックスをスイッチとして利用できます。</div><div 
class="ui-feed-item__date" title="2023-12-23 07:31:00">10ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/custom-build-opentelemetry-collector"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/custom-build-opentelemetry-collector">OpenTelemetry Collector をカスタムビルドする</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">本番環境では OpenTelemetry Collector Contrib を使用せず、必要なコンポーネントのみを含むようにカスタムビルドすることが推奨されています。この記事では、OpenTelemetry Collector をカスタムビルドする方法について紹介します。</div><div class="ui-feed-item__date" title="2023-12-20 11:49:00">10ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/scroll-driven-animation"><img src="../../images/alternate-feed-image.png" 
loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/scroll-driven-animation">CSS だけで動くスクロールドリブンアニメーション</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Google Chrome 115 で追加されたスクロールドリブンアニメーションを使うことで、今まで JavaScript を使わなれけば実装できなかったようなスクロールと連動するアニメーションを CSS だけで実装できるようになりました。スクロールの進行状況に応じてバーを伸縮させるようなアニメーションや、要素が画面内に入ったタイミングでアニメーションを開始するようなことが実装できます。</div><div class="ui-feed-item__date" title="2023-12-17 04:29:00">10ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/storybook-v8-react-server-components"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/storybook-v8-react-server-components">
Storybook v8 の React Server Components サポート</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Storybook v8 では `experimentalNextRSC` オプションにより React Server Components をサポートしています。しかし、このオプションは React Server Components としての動作を再現しているわけではありません。サーバーサイドで Storybook が動作してるわけではなく、非同期コンポーネントをクライアントでレンダリングしているに過ぎないことに留意すべきです。</div><div class="ui-feed-item__date" title="2023-12-09 09:17:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/msw-v2-httpresponse-json-type-error"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/msw-v2-httpresponse-json-type-error">MSW v2 で `HttpResponse.json()` の型がおかしいときの対処法</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
MSW v2 の `HttpResponse.json()` の第 2 引数の型は `Response` オブジェクトの初期化時に渡すオプションを指定できます。しかし、tsconfig.json の設定によっては、この型がおかしくなることがあります。その場合には、`tsconfig.json` の `compilerOptions.lib` に `dom` を追加するのが一時的な対処法です。</div><div class="ui-feed-item__date" title="2023-12-02 08:42:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/server-components-testing"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/server-components-testing">React Server Components のテスト手法</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
現代におけるコンポーネントのテストは Testing Library を用いてテストを行うことが一般的です。しかし、2023 年 11 月現在、Testing Library はまだ Server Components のテストを十分にサポートしていません。そのため、Server Components のテストを行うには、別の方法を用いる必要があります。この記事では、Testing Library を用いずに Server Components のテストを行う方法について説明します。</div><div class="ui-feed-item__date" title="2023-11-26 05:21:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/combobox-element"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/combobox-element">HTML 標準でコンボボックスを実現する `&lt;combobox&gt;` 要素の提案</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">コンボボックスとは、テキストボックスとドロップダウンリストを組み合わせた UI コンポーネントです。コンボボックスはユーザーがテキストボックスに入力した文字列に基づいて、ドロップダウンリストのアイテムをフィルタリングできます。`` 要素は、HTML の標準でコンボボックスを実現することを目的としています。</div><div 
class="ui-feed-item__date" title="2023-11-18 11:47:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/why-use-server-actions"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/why-use-server-actions">なぜ Server Actions を使うのか</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Next.js 14 の Server Actions の stable リリースに発表は大きな反響を呼びました。特に `` の `formAction` 属性内で直接 SQL クエリを実行するコードは多くの人に衝撃を与えていました。Server Actions の是非について語る時、導入の背景にユーザー体験の向上があるという観点を忘れてはいけません。また、セキュリティ上の観点についてどのように考えるべきでしょうか？</div><div class="ui-feed-item__date" title="2023-11-12 05:10:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" 
href="https://azukiazusa.dev/blog/use-the-npm-install-package-lock-only-command-when-migrating-package-managers-to-npm"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/use-the-npm-install-package-lock-only-command-when-migrating-package-managers-to-npm">パッケージマネージャーを npm に移行するときには `npm install --package-lock-only` コマンドを使うとよい</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">既存のプロジェクトで npm に移行する際に `npm install --package-lock-only` を使うことで、依存パッケージのバージョンを変更することなく lock ファイルを移行できます。</div><div class="ui-feed-item__date" title="2023-11-07 10:40:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/server-actions-return-jsx"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" 
height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/server-actions-return-jsx">Server Actions の戻り値には JSX を使える</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Server Actions の戻り値には、シリアライズ可能なデータ型を返す必要があります。ドキュメントでは Server Actions の戻り値に JSX を使うことはサポートされていないと記述されていますが、実際には Server Actions の戻り値に JSX を使うことができます。ただし、公式にサポートされている仕様ではないので、思わぬバグを踏む、将来追加される機能に対応しないおそれがあることを理解した上で、使うかどうかを判断する必要があります。</div><div class="ui-feed-item__date" title="2023-11-04 05:45:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/use-form-state-to-display-error-messages-in-server-actions-forms"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" 
href="https://azukiazusa.dev/blog/use-form-state-to-display-error-messages-in-server-actions-forms">Server Actions のフォームバリデーションにおいて useFormState でエラーメッセージを表示する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Next.js の Server Actions でフォームを作成する際に、どのような方法でバリデーションを行い、エラーメッセージを表示する際にどのような手段が考えられるでしょうか。プログレッシブエンハンスメントの恩恵を受けるために、サーバーサイドでバリデーションを行いその結果を表示する方法が効果的です。`useFormStatus` フックはこの一連の動作を行うために使用します。</div><div class="ui-feed-item__date" title="2023-10-31 10:16:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/exclude-specific-commits-from-github-history"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/exclude-specific-commits-from-github-history">GitLens で特定のコミットを除外する</a><div class="ui-feed-item__blog-title">
azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">GitLens の使用時に、機械的にフォーマットされたコミットがあるとコードの変更履歴を確認する際に邪魔になってしまいます。この記事では、GitLens で特定のコミットを除外する方法を紹介します。</div><div class="ui-feed-item__date" title="2023-10-28 01:30:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/invokers-to-add-interactions-without-javascript"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/invokers-to-add-interactions-without-javascript">JavaScript なしでインタラクションを追加する Invokers</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Invokers は JavaScript なしでインタラクションを追加するための提案です。`` 要素に `invoketarget` 属性を指定することで、値として指定した id を持つ `` などの要素の開閉状態を切り替えることが可能となります。</div><div class="ui-feed-item__date" title="2023-10-22 01:37:00">1年前</div></div></div>
<div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/url-canparse-method"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/url-canparse-method">URL が有効かどうかを判定する `URL.canParse()` メソッド</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">`URL.canParse()` メソッドは与えられた URL 文字列が有効であるかどうかを判定します。URL 文字列が有効であれば `true` を、無効であれば `false` を返します。これは URL コンストラクターを用いた `try...catch` 文による判定よりも簡潔に記述できます。</div><div class="ui-feed-item__date" title="2023-10-15 05:28:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/user-valid-and-user-invalid-pseudo-classes"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div 
class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/user-valid-and-user-invalid-pseudo-classes">:user-valid、:user-invalid 擬似クラスでユーザーの操作の後に検証を行う</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">ユーザーの操作の後にフォームの検証に基づき有効か無効かを示すために使用できる :user-valid、:user-invalid 擬似クラスを紹介します。従来の :valid、:invalid 擬似クラスと異なり、ユーザーがフォームに入力するまではスタイルを適用されません。</div><div class="ui-feed-item__date" title="2023-10-13 11:16:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/focusgroup-arrow-key-focus-navigation"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/focusgroup-arrow-key-focus-navigation">forcusgroup で矢印キーによるフォーカスナビゲーションを実装する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div>
<div class="ui-feed-item__summary">カスタム UI ウィジェットを実装する際には、ウィジェットのロールに応じたキーボード操作によるフォーカスナビゲーションを実装することが求められています。従来このようなキーボード操作は JavaScript を用いて実装する必要がありました。`focusgroup` の提案は、このようなキーボード操作を独立して使用できるプリミティブとして提案されています。この機能を利用することで、開発者は JavaScript を用いることなく一貫したフォーカスナビゲーションを実装できます。</div><div class="ui-feed-item__date" title="2023-10-09 05:22:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/details-name-attribute-accordion"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/details-name-attribute-accordion">`&lt;details&gt;` 要素の `name` 属性による排他的なアコーディオンの実装</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">`` 要素の `name` 属性を利用してグループ化することにより、排他的なアコーディオンを JavaScript なしで実装できます。</div><div class="ui-feed-item__date" 
title="2023-10-08 06:00:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/selectlist-element-for-a-more-customizable-select-box"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/selectlist-element-for-a-more-customizable-select-box">よりカスタマイズ可能なセレクトボックスを実現する `selectlist` 要素</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">`` 要素は、デザインをカスタマイズできなかった従来の `` 要素の問題を解決するために Open UI グループにより提案されている要素です。`` の構成要素の多くはスロットとして提供されていて、高いカスタマイズ性を備えているのが特徴です。</div><div class="ui-feed-item__date" title="2023-10-07 07:46:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/history-replacestate-rate-limit"><img src="../../images/alternate-feed-image.png" 
loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/history-replacestate-rate-limit">`history.replaceState()` にはブラウザによって呼び出し回数制限がある</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">`history.replaceState()` は、ブラウザの履歴を変更するための API です。使用例としてユーザーのアクションによる UI の状態の変更に合わせて、URL のクエリパラメータを変更することが挙げられます。この API はブラウザにより呼び出し回数に制限が設けられており、使い方を誤ると予期せぬ挙動が発生するおそれがあります。</div><div class="ui-feed-item__date" title="2023-10-01 04:11:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/manage-modal-state-with-url"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/manage-modal-state-with-url">モーダルの開閉状態を URL で管理する</a><div 
class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">モーダルの開閉状態を URL で管理することで、状態を復元したり、状態を共有できるなどのメリットがあります。この記事では、Next.js を例に URL でモーダルの開閉状態を管理する方法を紹介します。</div><div class="ui-feed-item__date" title="2023-09-24 07:38:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/elysiajs-tutorial"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/elysiajs-tutorial">Bun の Web フレームワーク ElysiaJS のチュートリアル</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">ElysiaJS は Bun の Web フレームワークです。高いパフォーマンスと、シンプルな API や厳格な型チェックにより生産性に優れているという特徴があります。また柔軟性が高く、多くのプラグインを組み合わせて利用できます。この記事では、ElysiaJS を使って簡単なタスク管理アプリの Web API を作成してみます。</div><div class="ui-feed-item__date" title="2023-09-16 02:34:00">1年前
</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/bun-workspace"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/bun-workspace">Bun workspace で始めるモノレポ生活</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Bun では `package.json` の `workspaces` を使用することでモノレポの管理が可能です。この記事では Bun によるモノレポを試してみます。</div><div class="ui-feed-item__date" title="2023-09-15 11:53:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/use-bun-macro-to-differentiate-new-features"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" 
href="https://azukiazusa.dev/blog/use-bun-macro-to-differentiate-new-features">Bun のマクロを使ってフィーチャートグルを実装する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Bun にはマクロはビルド時に実行される関数です。関数が返す値がインラインにバンドルファイルに埋め込まれます。マクロには、実行してインライン化した後に、デッドコードを削除するという特徴があります。この機能を使ってフィーチャートグルを実装してみましょう。</div><div class="ui-feed-item__date" title="2023-09-14 11:50:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/import-css-file-directly-in-bun-plugin"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/import-css-file-directly-in-bun-plugin">Bun の Plugins で CSV ファイルを直接 import する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
Bun の Plugins API を使用することで、任意の拡張子のファイルのサポートを追加できます。例えば Bun の公式の動画では、Plugins API を使用して Rust ファイル（.rs）を直接 import できる仕組みも作れることが紹介されています。</div><div class="ui-feed-item__date" title="2023-09-13 12:11:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/convert-logs-to-metrics-with-opentelemetry-collector-connector"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/convert-logs-to-metrics-with-opentelemetry-collector-connector">OpenTelemetry Collector の Connector を使ってログをメトリックに変換する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
OpenTelemetry には、メトリック、トレース、ログの 3 つの形式があります。これらの形式はそれぞれ別のパイプラインで処理されます。ある形式のデータを別の形式に変換し、あたかも 1 つのパイプライン上でデータを処理したい場合に Connector を使用します。例えば、あるパイプラインはログのパイプラインのエクスポーターとメトリックのパイプラインのレシーバーとして動作します。このような場合、Connector はログをメトリックに変換する役割を担います。</div><div class="ui-feed-item__date" title="2023-09-09 03:51:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/start-with-the-ugliest-code-that-works"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/start-with-the-ugliest-code-that-works">最小限のコードで動く最も汚いコードから始める</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
コードを書く際の重要な要点は、読みやすく他人に理解される「良いコード」を書くことです。しかし、完璧を目指して最初から書こうとすると行き詰まります。代わりに、荒削りながらも動くコードを作成し、徐々にリファクタリングして完成度を高めます。型エラーやリントエラーを無視しても構わないので、まずは動くものを作成しましょう。それからリファクタリングして「良いコード」を作成できます。</div><div class="ui-feed-item__date" title="2023-09-02 23:57:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/instrumenting-Node-js-applications-with-open-telemetry"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/instrumenting-Node-js-applications-with-open-telemetry">OpenTelemetry を使用して Node.js アプリケーションを計装する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
OpenTelemetry は Observability のフレームワークであり、トレース・メトリクス・ログなどのテレメトリーデータを作成、管理するためのツールキットです。OpenTelemetry はベンダーに依存しない形で標準化されたプロトコルとツールを提供していることが特徴です。この記事では Node.js アプリケーションを計装して Prometheus にデータを送信する方法を紹介します。</div><div class="ui-feed-item__date" title="2023-08-26 08:38:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/await-is-not-only-for-promise"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/await-is-not-only-for-promise">await は Promise 以外のオブジェクトでも値を取り出せる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">await キーワードは `then()` という名前のメソッドを持つオブジェクトに対して使用できます。このようなオブジェクトを thenable object と呼びます。await キーワードが Promise オブジェクトではなく thenable オブジェクトを対象としているのは、ライブラリの相互運用のためです。</div><div class="ui-feed-item__date" 
title="2023-08-20 08:41:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/react-memoized-component-children"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/react-memoized-component-children">【React】メモ化したコンポーネントに children を渡すと効果がなくなる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">React.memo は Props が変更されないかぎり、コンポーネントを再レンダリングしないようにする関数です。この関数はコンポーネントの余分なレンダリングを防ぎ、パフォーマンスを向上させる目的で使用されます。しかし、React.memo の使い方を誤ると意図しない再レンダリングが発生してしまうことがあります。ここではメモ化したコンポーネントに children を渡すと効果がなくなるというケースについて説明します。</div><div class="ui-feed-item__date" title="2023-08-13 04:25:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" 
href="https://azukiazusa.dev/blog/prefers-reduced-motion-or-application-settings"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/prefers-reduced-motion-or-application-settings">アニメーションの無効設定は prefers-reduced-motion に任せるか、アプリケーションの設定で制御するか</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">prefers-reduced-motion とは、ユーザーの環境設定によって余計な動きを抑制することを要求したことを検出するメディアクエリです。この設定は各 OS ごとに設定できます。ユーザーがアニメーションを無効にできることは、アクセシビリティの観点で重要です。prefers-reduced-motion によりアニメーションを無効にするのでも十分ですが、アプリケーションの設定として持たせるべきだと考えています。</div><div class="ui-feed-item__date" title="2023-08-06 05:25:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/rust-wasm-game-dev-book"><img src="../../images/alternate-feed-image.png" loading="lazy" 
alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/rust-wasm-game-dev-book">【書評】RustとWebAssemblyによるゲーム開発は Rust 開発における設計を学べる良書</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">本のタイトルは「Rust と WebAssembly によるゲーム開発」となっていますが、反して WebAssembly についての話題はほとんど出てきません。主に Rust における開発の設計についての話題が中心となっています。</div><div class="ui-feed-item__date" title="2023-07-30 13:39:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/graph-accessibility"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/graph-accessibility">グラフのアクセシビリティについて考える</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
`` や `` 要素で描画されたグラフは、スクリーンリーダーを使用するユーザーにとって内容を正しく理解することが難しいです。この記事では、グラフの内容をスクリーンリーダーを使用するユーザーに伝える方法について考えてみます。</div><div class="ui-feed-item__date" title="2023-07-29 08:19:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/react-memo-mocked-component-cannot-use-mock-function"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/react-memo-mocked-component-cannot-use-mock-function">React.memo でメモ化したコンポーネントはモック関数が使えない</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">テストにおいて子コンポーネントをモックしたい場合には通常のテストと同様に jest.mock() を使います。しかし、React.memo() でメモ化したコンポーネントはモック自体には成功するものの、mockImplementation のようなモック関数が使えません。</div><div class="ui-feed-item__date" title="2023-07-22 12:15:00">1年前</div></div></div><div class="ui-feed-item"><a 
class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/document-picture-in-picuture-any-element"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/document-picture-in-picuture-any-element">Document Picture in Picture で任意の要素を Picture in Picture する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Document Picture-in-Picture は、`` 要素に限らず任意の要素を PiP できるようにする提案です。これにより、動画以外の要素を PiP できるようになります。主なユースケースとして、カスタムのメディア・コントロールを使用したり、プレイリストとともに動画を PiP することが挙げられます。</div><div class="ui-feed-item__date" title="2023-07-16 05:38:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/snapshot-test-vs-assertion-test"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256">
</a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/snapshot-test-vs-assertion-test">スナップショットテストとアサーションテスト</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">この記事では、スナップショットテストとアサーションテストの違いを説明します。また、それぞれのアプローチでテストを書いたときのメリットとデメリットを見ていき、どちらのアプローチを採用すべきか考えていきます。</div><div class="ui-feed-item__date" title="2023-07-08 06:10:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/pnpm-patch"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/pnpm-patch">pnpm でパッケージにパッチを当てる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">`pnpm patch` コマンドを使うと、依存パッケージのコードを直接書き換えることができます。</div><div class="ui-feed-item__date" 
title="2023-07-01 05:37:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/do-not-use-aria-label-too-much"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/do-not-use-aria-label-too-much">aria-label を使いすぎない</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">aria-label 属性はコンテンツに対してアクセシブルな名前を与えるために使用します。aria-label 属性を使用する代表例として、中身がアイコンのボタンがあげられます。aria-label 属性は手軽に使えますが、できる限り一般的な形式でテキストを提供することが望ましいです。</div><div class="ui-feed-item__date" title="2023-06-25 04:17:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/screen-reader-friendly-text-notation"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" 
height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/screen-reader-friendly-text-notation">スクリーンリーダーに配慮したテキスト表記</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">文字を機械的に判断するスクリーンリーダーでは、人間の目によって判断できる文字について異なる解釈をするおそれがあります。そのような場合、利用者に正しい文章の意図を伝えられません。スクリーンリーダーに配慮したテキストの表記法を紹介します。</div><div class="ui-feed-item__date" title="2023-06-18 03:15:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/popover-api"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/popover-api">ポップオーバー API で JavaScript を使わずにポップアップを表示する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
Chrome 114 から追加されたポップオーバー API を使うと、JavaScript を使わずに簡単にポップアップを表示することができます。</div><div class="ui-feed-item__date" title="2023-06-11 05:12:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/vue-generic-component"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/vue-generic-component">Vue.js でジェネリックコンポーネントを使う</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Vue.js 3.3 から `` 構文を使用してコンポーネントを記述する際に、型引数を指定することができるようになりました。TypeScript で関数に型引数を指定するのと同じように、コンポーネントの props の型を指定することができます。</div><div class="ui-feed-item__date" title="2023-06-04 05:16:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/avoid-using-gif-animation"><img 
src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/avoid-using-gif-animation">GIF アニメーションの使用を控える</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">技術記事を書く際に、GIF アニメーションを使用することがあるかと思います。しかし、GIF アニメーションを使用することはアクセシビリティ上問題となります。この記事では、GIF アニメーションを使用することを避けるべき理由を説明します。</div><div class="ui-feed-item__date" title="2023-05-28 05:34:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/list-style-none-styled-ul-element-should-have-a-list-role"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/list-style-none-styled-ul-element-should-have-a-list-role">
list-style: none スタイルを指定した ul 要素には list ロールを指定すべき</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">WAI-ARIA における role 属性を使用する際のプラクティスとして、暗黙のロールを明示しないというものがあります。しかし、`` 要素は暗黙のロールとして `list` ロールを持っていますが、明示的に `list` ロールを宣言するべきです。</div><div class="ui-feed-item__date" title="2023-05-21 05:13:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/vitest-browser-test"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/vitest-browser-test">Vitest のブラウザテスト</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Vitest は実験的な機能として、ブラウザモードをサポートしています。ブラウザテストは Node.js 上で jsdom を用いてテストを実効するよりも信頼性の高い方法ですが、テストのセットアップに時間がかかるといったデメリットも存在します。</div><div class="ui-feed-item__date" 
title="2023-05-14 05:04:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/nextjs-server-action"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/nextjs-server-action">Next.js の Server Actions について</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Next.js の Server Actions はサーバーサイドのデータのミューテーション、クライアント JavaScript の削減、プログレッシブエンハンスメントなフォームを実現します。</div><div class="ui-feed-item__date" title="2023-05-06 05:13:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/sveltekit-form-action"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a 
class="ui-feed-item__title" href="https://azukiazusa.dev/blog/sveltekit-form-action">SvelteKit のフォーム操作</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">SvelteKit のフォームは Web 標準の機能のみで完結しています。つまり、クライアントサイドでは JavaScript を一切使用せずにサーバーにデータを送信できるのです。さらに、JavaScript を利用できる環境であるならばリッチなユーザー体験を追加できます。例えば、フォームを送信した後ページ全体の再読み込みを行わずに、フォームの送信結果を表示することができたり、バリデーションメッセージを即座に表示できたりします。</div><div class="ui-feed-item__date" title="2023-04-30 04:59:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/what-is-array-prototype-with"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/what-is-array-prototype-with">Array.prototype.with() とは</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
`Array.prototype.with()` は、非破壊的に配列の要素を置き換えるためのメソッドです。非破壊的とは、元の配列を変更せずに新しい配列を返すということです。`arr` に対して `with()` を実行しても、`arr` は変更されず、新しい配列のコピーが返されます。</div><div class="ui-feed-item__date" title="2023-04-23 03:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/tailwind-css-dark-mode-system-light-dark"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/tailwind-css-dark-mode-system-light-dark">Tailwind CSS のダークモードで System, Light, Dark を切り替える</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">ダークモードの設定では、OS の設定と同期させるか、ライトモードまたはダークモードに手動で切り替えるかの 3 つの選択肢が用意されていることがあります。手動でライトモードとダークモードを切り替える場合に比べて、OS の設定を自動で反映できるメリットがあります。</div><div class="ui-feed-item__date" title="2023-04-16 01:49:00">2年前</div></div></div><div 
class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/nextjs-interception-routes"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/nextjs-interception-routes">Next.js の Interception Routes について</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Intercepting routes は Next.js 13.3 から追加された機能で、App Router（app ディレクトリ）において使用できます。Intercepting routes ではブラウザの URL を遷移先のものに上書きしつつ、現在のレイアウトに新しいページを表示できます。これは例えば Instagram のように、ユーザーのプロフィールから写真をクリックすると、写真をモーダルを開き、ページを更新したり共通したりするとデフォルトのレイアウトで表示する場合などに便利です。</div><div class="ui-feed-item__date" title="2023-04-09 04:38:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/tried-superflare-a-full-stack-toolkit-for-cloudflare-workers"><img 
src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/tried-superflare-a-full-stack-toolkit-for-cloudflare-workers">Cloudflare Workers のためのフルスタックツールキット Superflare を試してみた</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Superflare は Cloudflare Workers 用のフルスタックツールキットです。D1 Database 向けの ORM や R2 Storage 向けのユーティリティなどの機能を提供しています。Superflare 自体はフレームワークを謳っておりません。実際に、Superflare は Remix、Next.js、Nuxt.js などのフレームワークと組み合わせることで効果を発揮します。</div><div class="ui-feed-item__date" title="2023-04-02 02:23:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/the-search-element-has-been-added-to-the-html-specification"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div 
class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/the-search-element-has-been-added-to-the-html-specification">HTML の仕様に search 要素が追加された</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">HTML Standardに新しい``要素が追加された。これまで、ARIAには``に相当するHTML要素がなかったため、``しか代替要素がなかった。新たに``要素を使用することにより、WAI-ARIA を使用せずともsearchランドマークを定義できるようになった。通常、``要素は少なくとも1つの入力要素を含んでおり、検索を開始するためのボタンもあることが期待されている。</div><div class="ui-feed-item__date" title="2023-03-26 07:50:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/it-may-be-helpful-to-provide-an-example-when-you-want-to-fix-the-output-format-in-chatgpt3"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" 
href="https://azukiazusa.dev/blog/it-may-be-helpful-to-provide-an-example-when-you-want-to-fix-the-output-format-in-chatgpt3">ChatGPT3 で出力の形式を固定したい場合には例を提示してあげるとよさそう</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">ChatGPT は毎回異なる出力を返すことがあるため、APIやアプリ開発にとって不都合が生じる。そこで、出力の例を提示することで固定した形式の回答を得やすくすることができる。提示するためのプロンプトは区切り文字を使用して区切ることが推奨され、回答は通常、「例」に基づいた形式で得られる。</div><div class="ui-feed-item__date" title="2023-03-19 04:13:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/exhaustive-checks-in-typescript"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/exhaustive-checks-in-typescript">TypeScript で網羅性をチェックする</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
パターンマッチを備えている言語では、コンパイル時に網羅性が検査され、網羅的でない場合にはコンパイルエラーとなります。例えば Rust では match 式は網羅性を検査します。列挙型が取りうる値をすべて網羅していない場合にはコンパイルエラーとなります。TypeScript にはパターンマッチがないため、網羅性の検査は行われません。ですが、TypeScript では `never` 型を利用することで網羅性の検査を行うことができます。</div><div class="ui-feed-item__date" title="2023-03-11 05:37:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/using-environment-variables-with-sveltekit"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/using-environment-variables-with-sveltekit">SvelteKit で環境変数を使う</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">SvelteKit プロジェクトは Vite を使用しているので、`import.meta.env` から環境変数を参照できます。単に環境変数を参照するだけならば十分です。ですが SvelteKit により提供されている環境変数の仕組みを使用すると、型安全に環境変数を参照できる、公開してはいけない値をクライアントから参照できなくなるなどのメリットを得られます。
</div><div class="ui-feed-item__date" title="2023-03-04 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/react-javascript-xss"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/react-javascript-xss">React は javascript スキームを使った XSS を防ぐことができない</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">React を使用していた場合に引き起こす可能性がある XSS 脆弱性の例として、javascript スキームを使った XSS があります。この記事では、javascript スキームを使った XSS についての説明とその対策について紹介します。</div><div class="ui-feed-item__date" title="2023-02-25 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/web-accessibility-basics-every-web-application-engineer-needs-to-know"><img 
src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/web-accessibility-basics-every-web-application-engineer-needs-to-know">Web アプリケーションエンジニアのためのウェブアクセシビリティの基礎</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">ウェブアプリケーションエンジニアを対象に、アクセシビリティの対応について解説した記事。アクセシビリティを向上させるためには、正しいHTMLの書き方が必要である。HTML要素には、アクセシビリティに関する機能が元々備わっているため、適切なHTMLを選択し使用することが大切だ。複雑なUIの場合はWAI-ARIAを使用し、ARIA Authoring Practices Guideに基づき適切に実装する必要がある。UIライブラリ選びの際には、WAI-ARIAに従った実装を行っているかが基準の1つとなる。</div><div class="ui-feed-item__date" title="2023-02-18 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/typescript-esmodules"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div 
class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/typescript-esmodules">TypeScript + ESModules の開発環境をシュッと作る</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">ほぼ設定なしで TypeScript + ESModules の開発環境をシュッと作る時のレシピです。</div><div class="ui-feed-item__date" title="2023-02-18 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/react-hook-form-zod-5-patterns"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/react-hook-form-zod-5-patterns">React Hook Form で Zod を使う時の 5 つパターン</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">React Hook Form で Zod を使用する時によくあるバリデーションのパターンを 5 つ紹介します</div><div class="ui-feed-item__date" 
title="2023-02-11 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/sveltekit-navigate-progressbar"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/sveltekit-navigate-progressbar">SvelteKit でページ遷移時のプログレスバーを表示する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">SPA で画面遷移をする場合、MPA の場合と違い、ブラウザがローディングの表示を行ってくれません。リンクをクリックしてから画面遷移が完了するまで何も表示されないので、ユーザーからすると何も反応していないように感じてしまいます。 SPA で画面遷移した時にプログレスバーを表示したい場合には NProgress が最適です。コンパクトな JavaScript ライブラリでフレームワークを選ばず利用できます。この記事では SvelteKit で NProgress を使用する方法を紹介します。</div><div class="ui-feed-item__date" title="2023-02-05 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/accessible-tooltip">
<img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/accessible-tooltip">アクセシビリティに考慮したツールチップを実装する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">ツールチップとは、ある要素に対する補足情報を与える UI です。通常ある要素に対してマウスホバーまたはキーボードでフォーカスした時少しのディレイの後に、ユーザーの操作によらず自動的にポップアップして表示されます。このポップアップはユーザーの操作をブロッキングするものではありません。ユーザーがマウスのホバー外すかフォーカスが外れた場合にツールチップは非表示となります。</div><div class="ui-feed-item__date" title="2023-02-04 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/focus-css-focus-visible"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/focus-css-focus-visible">
focus() メソッドで CSS の :focus-visible 擬似クラスが適用されるかどうかは最後の操作によって異なる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">:focus-visible 擬似クラスはユーザーの入力方法によって異なるフォーカス表示をしたい時に便利です。この擬似クラスはキーボード操作によりフォーカスされた場合に適用されますが、マウス操作によりフォーカスした場合には適用されません。 それでは、JavaScript の focus()メソッドによりフォーカスされた場合には、`:focus-visible` 擬似クラスは適用されるのでしょうか？実はこれは最後 `focus()` メソッドが呼ばれる前に要素にフォーカスがあったかどうかにより異なります。</div><div class="ui-feed-item__date" title="2023-01-28 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/avoid-writing-conditional-branches-in-the–test-code"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/avoid-writing-conditional-branches-in-the–test-code">テストコード内では条件分岐を書かないようにする</a><div class="ui-feed-item__blog-title">
azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">誰でも読める愚直なコードであることの 1 つの目安として、テストコードの中に if 文や三項演算子などの条件分岐が入り込んでいていないことが上げられます。if 文が存在するコードはアンチパターンであるといえます。実際に if 文がテストコードの中に入り込んだ例を見てみましょう。</div><div class="ui-feed-item__date" title="2023-01-21 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/use-aria-disabled-to-give-focus-to-disabled-button"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/use-aria-disabled-to-give-focus-to-disabled-button">無効にしたボタンにフォーカスさせたいときには aria-disabled を使う</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
例えばフォームの項目になにか入力されるまで、送信ボタンを無効にしたい状況があるかと思います。このような場合には `` に `disabled` 属性を与えることでフォームの送信を無効にできます。`disabled` 属性はデフォルトでコントロールを無効にする一般的に期待されるすべての機能を提供するため、多くの場合はこの属性を使用するべきです。しかし `disabled` 属性には 1 つ問題点が存在します。それは Tab キーによるフォーカスができなくなるという点です。</div><div class="ui-feed-item__date" title="2023-01-14 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/the-unit-of-unit-testing-is-behavior-not-code"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/the-unit-of-unit-testing-is-behavior-not-code">単体テストの単位はコードではなく振る舞いである</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
単体テストの目的は、ソフトウェア開発プロジェクトを持続可能なものにすることです。この目的を達成するための単体テストの機能の 1 つにリファクタリングに対する耐性が上げられます。これは内部のコードを変更した前後でも、外部の振る舞いから見た振る舞いが壊れていないことを保証してくれる度合いです。この耐性が高ければ、開発者は安全にコードを変更できます。 この記事では、単体テストをコード単位で書いた場合と振る舞い単位で書いた場合をそれぞれ提示して、リファクタリングに対する耐性がどのように異なるのかを見ていきます。</div><div class="ui-feed-item__date" title="2023-01-07 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/accessibility-improvements-you-can-make-now"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/accessibility-improvements-you-can-make-now">今すぐできる Web アクセシビリティ改善</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
アクセシビリティの対応は、要件定義段階から設計したりなど大変そうなイメージはあります。実際に本格的に対応するにはどの達成基準を目標にするか決めたり、入念なテストが必要になるなど確かに一朝一夕で対応できるわけではないでしょう。 ですが、完璧な対応を目指すのではなく、少しづづ改善できるところから進めることこともできます。実際にやってみると、簡単な HTML や CSS のコードの修正でもよい改善を得られたりします。 この記事では比較的低コストで実践入門できるアクセシビリティの改善を紹介します。</div><div class="ui-feed-item__date" title="2022-12-30 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/do-not-compromise-html-functionality-in-your-web-front-end-implementation"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/do-not-compromise-html-functionality-in-your-web-front-end-implementation">Web フロントエンドの実装において本来の機能を損なってはいけない</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
データの取得・ルーティング・フォームの値の管理に至るまで JavaScript で制御するようになった結果、本来備わっていた機能を損なう形で実装されるような間違いが起きるケースも発生してしまいました。見た目上操作に不都合がないのですが、修飾キーが有効でなかったりと、とある要素が当然に持っているべき機能が失われていることがよくあります。</div><div class="ui-feed-item__date" title="2022-12-24 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/satori-sveltekit-ogp-image"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/satori-sveltekit-ogp-image">Satori + SvelteKit で OGP 画像を自動生成する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Satori とは Vercel が公開している OGP 画像生成ライブラリです。OGP 画像を表示したい場合、記事ごとに対応する OGP 画像が必要になるわけで、新しい記事を投稿するたびに新たな画像を生成しなければいけません。都度画像を生成する手間は取れないわけで、このOGP 画像を生成する工程を自動化する仕組みが必要となります。Satori は記事のタイトルなどをもとに動的 OGP 画像を生成するユースケースのために使用できます。</div><div 
class="ui-feed-item__date" title="2022-12-17 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/what-to-do-when-tailwindcss-is-momentarily-displayed-in-light-mode-in-dark-mode"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/what-to-do-when-tailwindcss-is-momentarily-displayed-in-light-mode-in-dark-mode">TailwindCSS のダークモードでページ読み込み時に一瞬ライトモードで表示されてしまうときの対応法</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">ユーザーの OS の設定や LocalStorage の値をもとにダークモードかどうか判定する場合、コンテンツが読み込まれる前にスクリプトの実行が完了している必要があります。</div><div class="ui-feed-item__date" title="2022-12-10 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/pa11y-ci-githubactions"><img 
src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/pa11y-ci-githubactions">Pa11y CI でアクセシビリティテストを GitHub Actions で実行する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Pa11y とは Web Content Accessibility Guidelines (WCAG) をベースに HTML のアクセシビリティを検査するツールです。適合レベル AA を対象にテストします。Pa11y にはいくつかの種類がありますが、その中でも Pa11y CI は CI 上で実行することにフォーカスしています。</div><div class="ui-feed-item__date" title="2022-12-03 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/monorepo-github-actions-jest-coverage-report-action"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" 
href="https://azukiazusa.dev/blog/monorepo-github-actions-jest-coverage-report-action">モノレポで GitHub Actions の jest coverage report を動かす</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">jest coverage reportは GitHuba Actions のワークフローの1つで Jest で実行したテストのコードカバレッジをプルリクエスト上にコメントしてくれます。 この記事では yarn workspaces 使用して作成したモノレポ構築のレポジトリで jest coverage report を動かしてみます。</div><div class="ui-feed-item__date" title="2022-11-26 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/typescript-4-9-in"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/typescript-4-9-in">TypeScript 4.9 で in 演算子による型の絞り込みが改善された</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
TypeScript において `in` 演算子を `unknown` 型に対して使用した際の挙動が改善されました。</div><div class="ui-feed-item__date" title="2022-11-19 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/react-router-defer"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/react-router-defer">React Router の defer で重要なデータを先に描画する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">あるページの中で重要ではない付随的なデータの取得を待たずに、重要なデータの取得が完了したタイミングでページを表示させたい場合があります。例えば、ブログの記事のページを遷移する場合、ユーザーにとって記事のコンテンツは重要なデータですが、それに付随するコメントやいいねの数はそれほど重要ではないので、それらのデータの取得を待つ必要がありません。 この記事では React Router の loaderを使用して重要なデータの完了のみを待機する方法を試してみます。</div><div class="ui-feed-item__date" title="2022-11-11 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a 
class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/react-accessible-tab"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/react-accessible-tab">【React】アクセシビリティに考慮したタブを実装する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">タブとは、ページ内でコンテンツを切り替えるために使用する UI です。タブ初期表示ではいずれか一つのタブパネルが表示されており、関連するタブがアクティブなスタイルで表示されます。それぞれのタブには関連するタブパネルがあり、タブを選択することで表示されるタブパネルがタブに関連するものに切り替わります。</div><div class="ui-feed-item__date" title="2022-11-05 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/react-accessible-accordion"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" 
href="https://azukiazusa.dev/blog/react-accessible-accordion">【React】アクセシビリティに考慮したアコーディオンを実装する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">アコーディオンは見出しであるヘッダーとコンテンツであるパネルから構成された UI が垂直に積み重ねられたセットです。ユーザーはヘッダーをクリックすることで、ヘッダーに関連付けられたパネルの表示・非表示を切り替えることができます。 アコーディオンは1つのページ内で複数のセクションのコンテンツを表示する際に、スクロールを減らすためによく 使用されます。例えば、「よくある質問」のようなページで使われていることを見たことがあるかと思います</div><div class="ui-feed-item__date" title="2022-10-28 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/Implement-accessibil-listbox-in-react"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/Implement-accessibil-listbox-in-react">【React】アクセシビリティに考慮したリストボックスを実装する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div 
class="ui-feed-item__summary">リストボックスにアクセシビリティ上求められる要件を確認した後に、React で実際に要件に従った実装をおこないます。</div><div class="ui-feed-item__date" title="2022-10-22 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/qwik-city-blog-app"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/qwik-city-blog-app">Qwik City でブログアプリを作る</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Qwik City は Qwik のメタフレームワークです。React における Next.js、Vue.js における Nuxt.js のような関係と同等です。</div><div class="ui-feed-item__date" title="2022-10-15 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/event-bubbling-follows-the-react-tree-not-the-dom-tree"><img 
src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/event-bubbling-follows-the-react-tree-not-the-dom-tree">イベントのバブリングは DOM ツリーではなく React ツリーに従う</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">イベントのバブリングとは、ある要素で発生したイベントがその親要素まで伝播することです。React でポータルを使用した場合、DOM ツリー状親子関係でなかったとしても、React ツリー上親子関係であればイベントがバブリングされます。</div><div class="ui-feed-item__date" title="2022-10-08 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/react-state"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/react-state">【React】state のリフトダウンパターン</a><div 
class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">React において不要な再レンダリングを避けるためのいくつかのパターンを紹介します</div><div class="ui-feed-item__date" title="2022-10-01 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/jest-beforeunload"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/jest-beforeunload">Jest で beforeunload イベントをテストする</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">beforeunload イベントをテストする方法を紹介します</div><div class="ui-feed-item__date" title="2022-09-24 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/css-pseudo-class-focus-within"><img src="../../images/alternate-feed-image.png" 
loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/css-pseudo-class-focus-within">CSS 擬似クラス「:focus-within」</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">:focus-within は CSS の擬似クラスであり、その要素または子孫要素にフォーカスがある場合に一致します。</div><div class="ui-feed-item__date" title="2022-09-17 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/dialog-accessibility"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/dialog-accessibility">アクセシブルなダイアログに必要なこと</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">ダイアログをアクセシビルに実装するための要件を確認しましょう。</div><div 
class="ui-feed-item__date" title="2022-09-10 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/sanitizer-api-html"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/sanitizer-api-html">Sanitizer API で HTML を安全に使用する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">ユーザーが入力した情報をそのまま表示するとクロスサイトスクリプティング（XSS）脆弱性につながる問題があることはよく知られています文字列の無害化はこのようにライブラリの実装に頼っている状況でしたが、WING により Sanitizer API という仕様が策定されました。Sanitizer API により外部ライブラリの依存無しで XSS の対策が可能となります。</div><div class="ui-feed-item__date" title="2022-09-03 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/hono-cloudflare-workers-rest-api"><img src="../../images/alternate-feed-image.png" 
loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/hono-cloudflare-workers-rest-api">Hono + Cloudflare Workers で REST API を作ってみよう</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Hono は TypeScript/JavaScript のシンプルな Web フレームワークです。Hono という名前は日本語の「炎」に由来します。 Hono の特徴としては以下の点が挙げられています。 - ウルトラファスト - 依存関係なし - ミドルウェア - TypeScript - マルチプラットフォーム</div><div class="ui-feed-item__date" title="2022-08-27 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/fetch-upload-streaming"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/fetch-upload-streaming">Fetch Upload Streaming でチャットアプリを作ってみる</a><div 
class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Fetch Upload Streaming とは、ブラウザの JavaScript の POST リクエストで HTTP のストリーミングを行える機能です。より具体的には、Fetch API の `body` に ReadableStream を渡せるようになります。</div><div class="ui-feed-item__date" title="2022-08-20 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/angularjs-react-3"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/angularjs-react-3">AngularJS のチュートリアルを React にリプレイスしてみた③</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">それではいよいよ、AnguarJS のルーティングモジュールである `ngRoute` を置き換えましょう。この置き換えが完了したら AngularJS を完全に取り除くことができます。</div><div class="ui-feed-item__date" title="2022-08-13 15:00:00">2年前</div></div></div><div 
class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/angularjs-react-2"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/angularjs-react-2">AngularJS のチュートリアルを React にリプレイスしてみた②</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">AngularJS のチュートリアルを React にリプレイスします。今回の記事では AngularJS のコンポーネントをすべてリプレイスして、angular-resorce の代わりに API クライアントを実装します。</div><div class="ui-feed-item__date" title="2022-08-06 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/angularjs-react"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" 
href="https://azukiazusa.dev/blog/angularjs-react">AngularJS のチュートリアルを React にリプレイスしてみた①</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">AngularJS のチュートリアルを React にリプレイスします。</div><div class="ui-feed-item__date" title="2022-07-30 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/pnpm-npm"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/pnpm-npm">pnpm は npm と何が違うのか</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">pnpm は npm、yarn と並ぶ JavaScript のパッケージマネージャーです。pnpm と言う名前は「performant npm」に由来します。</div><div class="ui-feed-item__date" title="2022-07-23 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" 
href="https://azukiazusa.dev/blog/examples-of-msw-practice-Applications"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/examples-of-msw-practice-Applications">MSW の実践活用例</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">msw の実践で活用する例を紹介します</div><div class="ui-feed-item__date" title="2022-07-16 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/volar-vuetify2-x"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/volar-vuetify2-x">Volar で Vuetify2.x の補完を効かせる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div 
class="ui-feed-item__summary">Volar + Vuetify 2.x を利用する場合、型定義ファイルを作成してグローバルコンポーネントを定義する必要があります。</div><div class="ui-feed-item__date" title="2022-07-09 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/schema-declaration-and-validation-in-zod"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/schema-declaration-and-validation-in-zod">【TypeScript】Zod でスキーマ宣言とバリデーションを実施する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">[Zod](https://github.com/colinhacks/zod) は TypeScript first でスキーマ宣言とバリデーションを実施するためのライブラリです。 一度バリデータを宣言すれば、Zod が自動的に TypeScript の型を推論してくれるという特徴があります。このおかげで重複した型宣言を排除できます。 また、Zod はエコシステムも多く存在しており、OpenApi、Nest.js、Prisma、react-hook-form などと組み合わせて使うことができます。</div><div class="ui-feed-item__date" 
title="2022-07-02 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/typescript-no-unchecked-indexed-access"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/typescript-no-unchecked-indexed-access">おまえら禁じられたインデックスアクセスを平気で使ってんじゃねえか！わかってんのか？『ランタイムエラー』が生まれたのは人間がコンパイラオプションに甘えたせいだろうがよ！</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">TypeScript 4.1 から noUncheckedIndexedAccess オプションが追加されました。このオプションは上記のような配列のアクセスやオブジェクトのプロパティのアクセスをより厳密にします。 具体的には、配列に対するインデックスアクセスやインデックスシグネチャを通じたプロパティのアクセスは常に `undefined` とのユニオン型となります。</div><div class="ui-feed-item__date" title="2022-06-25 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/fresh-tutorial">
<img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/fresh-tutorial">Deno Web フレームワーク Fresh チュートリアル</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Fresh は Deno 製の Web フレームワークです。事前のビルドを必要せず、エッジでレンダリングを提供するという特徴があります。また、Islands Architecture を採用しており、デフォルトではクライアントに JavaScript が配信されることがありません。</div><div class="ui-feed-item__date" title="2022-06-18 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/atomic-css-engine-unocss"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/atomic-css-engine-unocss">Atomic CSS エンジン - UnoCSS</a><div 
class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">UnoCSS はフレームワークではなく、Atomic CSS エンジンです。全ては柔軟性とパフォーマンスを考慮して設計されています。UnoCSS にはコアユーティリティはなく、すべての機能はプリセットで提供されます。</div><div class="ui-feed-item__date" title="2022-06-10 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/histoire-a-ui-component-cataloging-tool-from-Vite"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/histoire-a-ui-component-cataloging-tool-from-Vite">Vue 向けの Vite 製の UI コンポーネントカタログツール Histoire</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Histoireはフランス語で「Story」という意味の単語であり、Storybook のように UI コンポーネントのカタログを作成するツールです。Vite にネイティブ対応、Vue の SFC 形式で Story を書けるといった特徴があります。</div><div 
class="ui-feed-item__date" title="2022-06-04 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/jest-preview"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/jest-preview">Jest Preview がけっこーすごい</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Jest Preview とは Jest で実行中のテストに debug() 関数を仕込むことで、実行中のテストが作成した HTML をブラウザでプレビューしながらデバッグできるライブラリです。</div><div class="ui-feed-item__date" title="2022-05-28 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/playwright-component-testing"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a 
class="ui-feed-item__title" href="https://azukiazusa.dev/blog/playwright-component-testing">Playwright でコンポーネントテスト</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Playwright は E2E テストのための Node.js フレームワークです。v1.22.0 から React,Vue.js,Svelte のコンポーネントに対してテストを実行できるようになりました。つまりもともと備えていた E2E レベルのテストに加えて、結合レベルのテストまでカバーできるようになったということです。</div><div class="ui-feed-item__date" title="2022-05-21 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/tailwind-css-ui-library-option"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/tailwind-css-ui-library-option">Tailwind CSS ベースの UI フレームワークという選択肢</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
この記事を読んでいるみなさんも、Vuetify や MUI のような UI フレームワークを使用したことがあるでしょう。これらの UI フレームワークは Web アプリケーションでよく使われる UI パーツを非常に高機能で提供しており、多大な工数の削減に貢献しています。 その一方で、細かなスタイルの調整に手間取り余分に時間を取られ苦労を経験している方も多いのではないでしょうか？</div><div class="ui-feed-item__date" title="2022-05-14 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/node-js-api"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/node-js-api">Node.js の標準 API にテストランナーが追加された</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">JavaScript のテストランナーといえば、Jest がデファクトスタンダードと言えるでしょう。最近は Vitest と呼ばれる新たなテストランナーも登場していますが、しばらくは Jest が使われ続けられることでしょう。 そんな中、Node.js 18 から標準 API としてテストランナーが組み込まれました。まだ実験的な機能ではありますが、サードパーティのライブラリを使用せずに扱えることもあって注目を集めています。</div><div class="ui-feed-item__date" 
title="2022-05-07 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/what-i-found-attractive-aboutr-rust"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/what-i-found-attractive-aboutr-rust">Rust の魅力に感じた点</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">最近は [Rust](https://www.rust-lang.org/) と呼ばれるプログラミング言語を趣味として触っています。[SWC](https://swc.rs/) や [Rome](https://rome.tools/) のように Rust で作成されたフロントエンドツールが増えていることから興味を持ったのですが、実際に触ってみて Rust が高い人気を誇る理由がよく分かるようになりました。 この記事では私が Rust を触ってみて魅力に感じた点を列挙していきます。</div><div class="ui-feed-item__date" title="2022-04-30 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" 
href="https://azukiazusa.dev/blog/start-syntax-checking-with-markuplint"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/start-syntax-checking-with-markuplint">markuplint で構文チェックを始めよう</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">HTML の構文チェックを実施するには適切なツールを導入するのがよいでしょう。この記事では markuplint と呼ばれる HTML の静的解析ツールを紹介します。markuplint は JSX(React),Vue,Svlete のようなテンプレートエンジンにも対応しています。</div><div class="ui-feed-item__date" title="2022-04-23 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/node-js-volta"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" 
href="https://azukiazusa.dev/blog/node-js-volta">Node.js のバージョン管理には Volta がよい</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">皆さん Node.js のバージョン管理ツールには何を使っておりますでしょうか？上記の中でも私がオススメするのは [volta](https://volta.sh/) です。volta は 1.0 がリリースされたのが2020年12月と比較的新しいツールです。</div><div class="ui-feed-item__date" title="2022-04-16 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/Starting--monorepol-with-npm-workspace"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/Starting--monorepol-with-npm-workspace">npm workspace で始めるモノレポ生活</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">workspace は複数のパッケージ（`package.json`）をレポジトリを管理するために使用されます。このようなレポジトリは**モノレポ**として知られています。</div>
<div class="ui-feed-item__date" title="2022-04-09 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/return-await-return"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/return-await-return">君は return と await return の違いを理解して使っているか</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">`Promise` を返す非同期関数を扱う時 `Promise` をそのまま返す書き方と `Promise` を `await` してから返す二通りの方法があります。これらは一見同じように動作するように見えますが異なる点が存在します。</div><div class="ui-feed-item__date" title="2022-04-02 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/import-type-from-module"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256">
</a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/import-type-from-module">import type { ... } from &quot;./module&quot; とは何者何か</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">TypeScript のプロジェクトにおいて `import type { ... } from &quot;./module&quot;` という記述を見たことはないでしょうか？ これは Type-Only imports and export と呼ばれる機能で TypeScript3.8 より導入されました。これは名前の通りモジュールから型情報のみをインポートするために使用されます。これは通常の利用用途ではあまり考慮する必要はないのですが、特定の問題に立ち向かうために利用されることがあります。</div><div class="ui-feed-item__date" title="2022-03-26 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/anonymous-default-export"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/anonymous-default-export">
anonymous default export はやめたほうがいいかもね</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">`anonymous default export` とは名前の通り匿名でデフォルトエクスポートを宣言することです。必ず名前を付与しなければいけない名前付きエクスポートと異なり、以下はすべて有効な構文です。</div><div class="ui-feed-item__date" title="2022-03-19 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/msw-request-assertions"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/msw-request-assertions">msw でリクエストを検証する方法</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">msw 使ってテストを記述した時期待したリクエストが送信されているのか検査したくなるかもしれません。リクエストを検証する方法と、それを回避する方法を紹介します。</div><div class="ui-feed-item__date" title="2022-03-12 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a 
class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/storybook-testing"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/storybook-testing">Storybook 単体でインタラクションテストを実施する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Storybook の Component Story Format 3.0 では新機能として play() 関数が追加されました。 `play()` 関数は Storybook 上で ユーザーのインタラクションな操作を表現することができます。 以前は composeStories() 関数により Storybook 上で作成したストーリーを Jest で再利用する方法を書いたのですが、どうやら Storybook のみで完結してテストを実行することができるようですのでこちらを試してみます。</div><div class="ui-feed-item__date" title="2022-03-05 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/web-rust"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div 
class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/web-rust">Web フロントエンドエンジニアなら当然 Rust も書けますよね？？</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">本記事では Yew を利用して Web アプリケーションを作成してみたいと思います。Yew は React や Vue などと同じくコンポーネントベースのフレームワークでインタラクティブな UI を作成できます。</div><div class="ui-feed-item__date" title="2022-02-26 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/v-for-key-as-index"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/v-for-key-as-index">Q：v-for の key に 配列のインデックスを使うのは犯罪ですか？#Shorts</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
結論： - `v-for` ディレクティブに渡す配列要素が決して変わらないことがわかっているのであれば使っても良い。 - `id` 属性を持っているのであれば常に `id` 属性を `key` に使用するべき。</div><div class="ui-feed-item__date" title="2022-02-19 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/q-typescript-shorts"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/q-typescript-shorts">Q：TypeScript の関数の返り値の型を明示的に書かないのは犯罪ですか？#Shorts</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">TypeScript において関数の返り値の型は推論させることは可能ですが、これはコードベース全体に意図しない型の変更による影響が広がる可能性があります。</div><div class="ui-feed-item__date" title="2022-02-12 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/node-js-fetch"><img 
src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/node-js-fetch">Node.js に fetch がやってきた</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Node.js で fetch が使えるようになる</div><div class="ui-feed-item__date" title="2022-02-05 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/vue-a11y-testing"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/vue-a11y-testing">アクセシビリティを自動で検査する仕組みを整える</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">様々な方法でアクセシビリティを自動で検査します</div><div class="ui-feed-item__date" 
title="2022-01-29 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/compose-storybook-interaction-testing-jest"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/compose-storybook-interaction-testing-jest">Storybook の interaction testing と jest を組み合わせる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Storybook の Component Story Format 3.0 では新機能として `play()` 関数が追加されました。 `play()` 関数は Storybook 上で ユーザーのクリックやフォーム入力のようなインタラクションな操作を表現することができます。 `play()` 関数の大きな特徴としては Component Story Format の移植性の高さを利用して Storybook 上で定義したインタラクションを `Jest` など他の領域においても再利用できることです。</div><div class="ui-feed-item__date" title="2022-01-22 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" 
href="https://azukiazusa.dev/blog/vite-require"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/vite-require">Vite だと require() が使えないよ〜</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">皆様はすでにプロジェクトに Vite は導入されていらっしゃいますでしょうか？私はできていません。 Vite はフロントエンドのビルディングツールであり、従来の Webpack 等と比較して高速に動作するといった特徴があります。Vue.js を開発した Evan You 氏によって開発ツールではありますが Vue.js に限らず React や Svelte にも対応しています。</div><div class="ui-feed-item__date" title="2022-01-15 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/using-msw-to-mock-front-end-tests-seems-to-be-the-latest-trend"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a 
class="ui-feed-item__title" href="https://azukiazusa.dev/blog/using-msw-to-mock-front-end-tests-seems-to-be-the-latest-trend">フロントエンドのテストのモックには msw を使うのが最近の流行りらしい</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">最近のテスト手法として API コールをモックする際に Jest ではなく [Mock Service Worker](https://mswjs.io/) (以下 `msw` ）を使用する手法が注目されています。実施にどのように使用されているのか見ていきましょう。</div><div class="ui-feed-item__date" title="2022-01-08 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/vue-js-ref-vs-reactive"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/vue-js-ref-vs-reactive">【Vue.js】ref vs reactive</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
さて、そんな Compositon API ですがリアクティブなデータを定義する際に `reactive` と `ref` の2つの方法が用意されています。 `reactive` と `ref` どちらを使用するのがよいのか公式からも推奨する方法がありませんので、どちらを使用するべきか迷ってしまうところです。 `reactive` と `ref` のそれぞれのメリット・デメリットを確認してみましょう。</div><div class="ui-feed-item__date" title="2022-01-01 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/testingframework-vitest"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/testingframework-vitest">Vitest と呼ばれるテスティングフレームワークがめちゃくちゃ早いらしいな</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Vitest は Vite ベースの JavaScript のテスティングフレームワークです。</div><div class="ui-feed-item__date" title="2021-12-25 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" 
href="https://azukiazusa.dev/blog/vuetify-3-alpha-mejar-changes"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/vuetify-3-alpha-mejar-changes">Vuetify 3 Alpha の主な変更点</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">[Vuetify](https://vuetifyjs.com/) は Vue.js で多く使われている UI コンポーネントです。現在のバージョンは Vue 3 には対応していません。 現在 Vue 3 に対応する Alpha 版の Vuetify 3 が公開されています。開発スケジュールは以下のとおりになっています。</div><div class="ui-feed-item__date" title="2021-12-18 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/nuxt3-new-features"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" 
href="https://azukiazusa.dev/blog/nuxt3-new-features">Nuxt3 の新しい機能いろいろ</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">現在 Nuxt.js は バージョン3がパブリックベータ版として提供されています。 Nuxt.js が 2 → 3 に移行するにあたってたくさんの新機能が追加されました。</div><div class="ui-feed-item__date" title="2021-12-11 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/css-print-style"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/css-print-style">CSS で印刷用のスタイルを設定できる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
大抵のブラウザでは Web ページを印刷することができます。 しかし Web ページをそのまま印刷しようとすると改ページがおかしくなったりレイアウトがおかしくなってしまうことがあるでしょう。そもそも Web ページはディスプレイで表示することを目的としているので印刷には不向きなものです。 とはいえ Web ページを印刷したいというニーズは少なからずあるとは思います、そのようば場合には `@media print` などのような印刷用の CSS を利用することで見た目を整えることができます</div><div class="ui-feed-item__date" title="2021-12-04 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/fucus-trap-accessible-modal"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/fucus-trap-accessible-modal">フォーカストラップとは? 〜アクセシブルなモーダル〜</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">フォーカストラップ(またはループ)とは、ウェブページをキーボードで操作する際にフォーカスをとある領域からはみ出さないようにすることです。フォーカス可能な要素を抽出してその中をループすることで実現ができます。 登場シーンとしてはモーダルで使われることが多いです。実際に例を交えて確認してみましょう。</div><div 
class="ui-feed-item__date" title="2021-11-27 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/webpack5-module-federation"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/webpack5-module-federation">Webpack5 Module Federation ではじめるマイクロフロントエンド</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Webpack5 の Module Federation を使用してマイクロフロントエンドを作成します。</div><div class="ui-feed-item__date" title="2021-11-20 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/youtube-trick"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a 
class="ui-feed-item__title" href="https://azukiazusa.dev/blog/youtube-trick">Youtube すごい裏ワザ！！！</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Tab キーでページを操作した時のみ表示される「ナビゲーションをスキップ」は一般にスキップリンクと呼ばれるものであり、ウェブアクセシビリティのガイドライン (W3C 勧告) である WCAG 2.0にあるブロックスキップと呼ばれる達成基準を達成する方法として上げられています。</div><div class="ui-feed-item__date" title="2021-11-13 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/npm-coa-rc-embded-malware"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/npm-coa-rc-embded-malware">npm の人気パッケージ 「coa」と「rc」にマルウェアが埋め込まれた</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
2021/11/5 npm パッケージ 「coa」と「rc」がハイジャックされ、パスワードを盗むマルウェアが埋め込まれました。現在の時点では問題のあったバージョンはすべて取り除かれています。</div><div class="ui-feed-item__date" title="2021-11-06 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/css-box-model"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/css-box-model">ボックスモデル</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">CSS にはボックスという概念があります。ブラウザは文書をレイアウトする際に、それぞれの要素を CSS のボックスモデルに基づいた長方形の箱（ボックス）として表現します。つまりは、HTMLの個々の要素はすべてボックスにからできており、それらのボックスが組み合わさることによってページ全体が表現されます。 ボックスは CSS において最も基本的な概念であり、ボックスを理解することは CSS でレイアウトを構成したり要素同士を揃えるための手助けとなることでしょう。</div><div class="ui-feed-item__date" title="2021-10-30 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a 
class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/typescript-type-challenges"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/typescript-type-challenges">【TypeScript】type-challenges 中級編</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">[type-challengs](https://github.com/type-challenges/type-challenges) の medium レベルをやります。</div><div class="ui-feed-item__date" title="2021-10-23 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/typescript-type-challenges-advanced-types"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" 
href="https://azukiazusa.dev/blog/typescript-type-challenges-advanced-types">【TypeScript】type-challenges で学ぶ高度な型</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">type-challengesを知っていますか？ これは TypeScript の型についての問題集で、問題文の条件を満たす独自のユーティリティ型を作るチャレンジです。いわゆる「型パズル」ってやつですね。 問題の回答はPlayground上で行えるので実際に手を動かしながら問題を解くことができます。型パズルを通じてTypeScript の高度な型について学んでいきましょう。</div><div class="ui-feed-item__date" title="2021-10-16 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/lodash-es-lodash"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/lodash-es-lodash">lodash-es lodash 違い</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
[lodash-es](https://www.npmjs.com/package/lodash-es) とは [lodash](https://lodash.com/) を `ES module` 形式で提供しているライブラリです。</div><div class="ui-feed-item__date" title="2021-10-09 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/q-typescript-readonly-shorts"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/q-typescript-readonly-shorts">Q: TypeScript を使っているのに関数の引数のオブジェクトや配列に `readonly` を付与しないのは犯罪ですか？ #Shorts</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">質問来てた👉 Q: TypeScript を使っているのに関数の引数のオブジェクトや配列に `readonly` を付与しないのは犯罪ですか？ 結論：犯罪になる場合がある。 まず、配列の引数に `readonly` を付与しておけば以下の利点を得られます。 - うっかり関数の内部で引数の値を変更してしまうコードを書いてしまったときにコンパイルエラーが得られる - 関数の利用者が安心して関数を呼び出せる</div><div class="ui-feed-item__date" 
title="2021-10-02 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/vuex-5"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/vuex-5">Vuex 5 でどのように変わるのか。</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">現在リリースされている最新のバージョンは Vuex 4 です。 これは Vuex 3 と互換性のあるバージョンで Vue 3 で使用するためのものであり、 Vuex 3 と同じ API となっています。 Vuex 5 は Vue 3 において Composition API による Reactivity API が登場したことにより Reactivitty API によってどのように Vuex をどうさせるか再考されたバージョンとなっています。</div><div class="ui-feed-item__date" title="2021-09-25 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/vue-js-script-setup"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" 
width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/vue-js-script-setup">【Vue.js】script setup 構文がすごくすごい</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Vue.js 3.x から script setup 構文が使えるようになりました。これは単一ファイルコンポーネント(SFC)内で Composition API を使用している際に使える糖衣構文です。下記のようなメリットを得ることができ、公式からも使用が推奨されています。</div><div class="ui-feed-item__date" title="2021-09-25 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/vue3-2-style-javascript"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/vue3-2-style-javascript">【Vue3.2】styleタグ内でJavaScript変数をバインドできる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
Vue.js3.2からは、JavaScriptの変数をCSS変数としてバインドできるようになりました。 つまりは、CSSの値を動的に設定できるということです。 ものは試しのやってみましょう。</div><div class="ui-feed-item__date" title="2021-09-18 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/vue2-vue3"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/vue2-vue3">Vue2のプロジェクトをVue3へマイグレーションsする</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Vue 3が正式リリースされてから約1年が経過しました。 Vuetifyのリリース目標である2021年Q3も近づく中でそろそろVue3へのアップデートを検討されている方もいらっしゃることでしょうか？ この記事ではVue 2からVue 3への移行手順を記述していきます。</div><div class="ui-feed-item__date" title="2021-09-11 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/vue-js-mixin"><img 
src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/vue-js-mixin">【Vue.js】Mixinを使うのはもうやめよう</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">禁止まで言ってしまうとなんだか強い言葉のように聞こえてしまいますが、mixinは基本的にあまり良いアプローチとは考えられません。 実際に、Reactにも過去にはMixinが存在していましたが現在は廃止されています。</div><div class="ui-feed-item__date" title="2021-09-04 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/axios"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/axios">あの日見たaxiosの機能を僕達はまだ知らない。</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
axiosは、JavaScriptにおけるHTTPクライアントのデファクトスタンダードといえるでしょう。 Promiseベースで非同期通信を行えるHTTPクライアントとして、ブラウザ標準のfatchやjQuery.ajaxなどがありますが、特にaxiosがよく使われているのには豊富なオプションや設定に理由付けられるでしょう。 axiosの機能について私のように詳しくなくても直感的にHTTPリクエストを送れるのも良い点の1つですが、せっかくなのでaxiosでどのようなことができるのがを見ていきましょう。</div><div class="ui-feed-item__date" title="2021-08-28 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/vuetify-theme-css-variables"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/vuetify-theme-css-variables">VuetifyのテーマをCSS変数として使用する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">VuetifyのテーマをCSSの変数として生成して使用します。</div><div class="ui-feed-item__date" title="2021-08-21 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a 
class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/jsdoc-typescript"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/jsdoc-typescript">青春JSDocはTypeScript先輩の夢を見ない</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">時には、TypeScriptという概念が存在しない退屈な世界で開発を行わなけらばならない状況はあるでしょう。私はもはやキーボードでタイピングすることすらままなりません。 そんなJavaScriptしか利用できない状況で代替手段となるのが、JSDocです。JSDocのアノテーションによって型を付与することによって最低限の支援を受けることができます。</div><div class="ui-feed-item__date" title="2021-08-14 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/typescript-dry-type-definition"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a 
class="ui-feed-item__title" href="https://azukiazusa.dev/blog/typescript-dry-type-definition">【TypeScript】型定義をする際にもDRY原則を守る</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">DRY原則は非常に有名な原則ですし、普段から特に考えずとも自然と重複をさけるようなコードを書いている方も多いことでしょう。 とはいえ、TypeScriptにおいて`interface`や`type`などを用いて型定義を行う際に重複した型定義を行ってしまうことはないでしょうか？ TypeScriptには型定義をする際に重複を抑える手段は確かに存在します。そのようないくつかの方法を紹介します。</div><div class="ui-feed-item__date" title="2021-08-07 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/jest-timer-test"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/jest-timer-test">Jest setTimeout()のようなでタイマー関数をテストする</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
JavaScriptには、setTimeout()のような時間に関する便利な機能が用意されています。しかし、これらの関数はユニットテストを記述する際に厄介です。Jestのタイマーモックはこのような場合に利用できる便利な機能です。</div><div class="ui-feed-item__date" title="2021-07-31 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/typescript-type-annotation-vs-type-assetion"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/typescript-type-annotation-vs-type-assetion">【TypeScript】型アノテーションと型アサーションの違い</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">型アノテーションと型アサーションによる変数宣言は、一見同じ結果ををもたらすように見えます。しかし、型アサーションには明確な欠点が存在します。</div><div class="ui-feed-item__date" title="2021-07-23 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" 
href="https://azukiazusa.dev/blog/mongoose-group-by-hour-count"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/mongoose-group-by-hour-count">【mongoose】日付のカラムで時間ごとにグループ化してドキュメント数をカウントする</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">タイトルのとおりです</div><div class="ui-feed-item__date" title="2021-07-17 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/mongoose-cannot-overwrite-model-model-once-compiled-error-handling"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/mongoose-cannot-overwrite-model-model-once-compiled-error-handling">
【mongoose】Cannot overwrite &#39;Model&#39; model once compiled. エラーの直し方</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">mongooseで遭遇するCannot overwrite &#39;Model&#39; model once compiled. エラーの解消方法です</div><div class="ui-feed-item__date" title="2021-07-10 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/json-object"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/json-object">JSONオブジェクトのあれこれ</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">`JSON`オブジェクトはJavaScriptにおいて、JSONをパースしたり値をJSONに変換するためにもっぱら使われます。 普段使っている`JSON.stringify()`や`JSON.parse()`にはオプショナルな引数を渡すことによってその振る舞いを変更することができます。</div><div class="ui-feed-item__date" title="2021-07-03 15:00:00">3年前
</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/javascript-object"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/javascript-object">【JavaScript】Objectがプリミティブに変換されるとき</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">JavaScriptがプリミティブな値に変換されるとき、string型に変換されようとするか、number型に変換されようとするかで挙動が変化する</div><div class="ui-feed-item__date" title="2021-06-26 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/react-errorboundary"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" 
href="https://azukiazusa.dev/blog/react-errorboundary">ReactのErrorBoundaryで内部のエラーをキャッチする</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Error Boundaryとは、自身の子コンポーネントツリーで発生したJavaScriptのエラーをキャッチ・記録しフォールバックのUIを表示するコンポーネントです。 例えるなら、`try/catch`構文を行うコンポーネントのようなものと言えます。</div><div class="ui-feed-item__date" title="2021-06-19 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/useful-minor-html5"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/useful-minor-html5">仕事で役に立つかもしれないHTML5のマイナー要素</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
HTMLは書いたことがありますか？プログラミング初心者が最初の一歩として書き出すのに好まれる言語ですが、セマンティクスを追求すると奥深い言語だとわかります。タグの種類も数多くあり、全てを把握している人はそう多くなないでしょう。 今回は、そんなHTMLの普段の仕事では余り見かけないであろう要素を紹介していきます。</div><div class="ui-feed-item__date" title="2021-06-12 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/nuxt-sentry-user-feedback"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/nuxt-sentry-user-feedback">Nuxt Sentryでユーザーフィードバックを受け取る</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Sentryでは、エラーが発生した際に簡単にユーザーフォードバックを求めるダイアログを表示することができます。 Nuxt.jsでは、エラーが発生した際には`layouts/error.vue`へ遷移させることでエラーページを表示するので、このエラーコンポーネントにダイアログを表示させる処理を書いていきます。</div><div class="ui-feed-item__date" title="2021-06-05 15:00:00">3年前</div></div></div><div class="ui-feed-item">
<a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/node-js-express-csv"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/node-js-express-csv">Node.js(Express)でcsvを生成してダウンロード</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Node.js(Express)でCSVファイルを生成してダウンロードさせます。</div><div class="ui-feed-item__date" title="2021-05-29 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/also-passed-ckad"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/also-passed-ckad">CKADにも合格した</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div>
<div class="ui-feed-item__summary">開発者向けのK8sの試験であるCKADにも合格したので同様に合格体験記を記載したいと思います。 といっても、大枠の部分はCKAのときとあまり変わらないのでCKAと異なる部分を中心に記載したいと思います。</div><div class="ui-feed-item__date" title="2021-05-22 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/vue-cli-vite"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/vue-cli-vite">Vue CLIで作成したプロジェクトをViteに置き換える</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Viteは、一言でいうとフロントエンドのめっちゃ早いビルドツールです。Vue CLIで作成したプロジェクトをViteに置き換えるためにvue-cli-plugin-viteをというプラグインを使います。</div><div class="ui-feed-item__date" title="2021-05-15 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/kubernetes-apiversion"><img 
src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/kubernetes-apiversion">KubernetesのapiVersion</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Kubernetesのマニフェストを作成するときには、`apiVersion`フィールドを指定する必要があります。 例えば`Pod`の場合には`v1`を、`Deployment`の場合には`apps/v1`を指定しますが、これらはどのようなルールで記述するのでしょうか。</div><div class="ui-feed-item__date" title="2021-05-08 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/etcd-backup-restore"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/etcd-backup-restore">etcdのバックアップとリストア</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2
</div><div class="ui-feed-item__summary">etcdは、kubernetesのクラスターの情報を保存するkey-valueストアです。</div><div class="ui-feed-item__date" title="2021-05-01 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/kubectl-jsonpath"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/kubectl-jsonpath">kubectl JSONpath</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">kubectlはアウトプットの形式としてJSONPathをサポートしています。</div><div class="ui-feed-item__date" title="2021-04-24 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/vue-js-for-ie11"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div 
class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/vue-js-for-ie11">Vue.jsでIE11対応</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">人生でときにはIE11に対応させなければいけない時があるでしょう。Vue.jsでIE11に対応しなけらばいけなくなったときに読むものを記載しておきます。</div><div class="ui-feed-item__date" title="2021-04-17 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/e2e-cypress"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/e2e-cypress">e2eテスティングフレームワークCypress</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Cypressは、JavaScript製のE2Eテスティングフレームワークです。 実行速度が早い、HTTPリクエストの実行を待つなどテストが壊れにくい仕組みが整っています</div><div class="ui-feed-item__date" title="2021-04-10 15:00:00">4年前
</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/kubernetes-tips"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/kubernetes-tips">Kubernetes Tips</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">知っていると時間を短縮できるようなkubectlコマンドのtipsです。</div><div class="ui-feed-item__date" title="2021-04-03 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/basic-sass-syntax"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/basic-sass-syntax">Sassの基礎文法</a><div class="ui-feed-item__blog-title">
azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">SassはCSSのメタ言語です。CSSに比べてコード量が減り、保守性が優れるといった開発体験を向上させてくれる特徴があります。</div><div class="ui-feed-item__date" title="2021-03-27 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/what-is-kustomize"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/what-is-kustomize">Kustomizeとは</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Kustomizeとは、Kuberbetsコミュニティのsig-cliが提供しているマニフェストのテンプレーティングツールです。環境ごとにマニフェストを生成したり特定のフィールドを上書きするといった機能が提供されています。</div><div class="ui-feed-item__date" title="2021-03-20 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/kubernetes-helm"><img 
src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/kubernetes-helm">KubernetesのパッケージマネージャーHelm</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Helmは、Kubernetsのパッケージマネージャーです。 例えば、npmを利用して第三者が作成したパッケージをレポジトリで管理して検索・インストールするように、Helmではチャート(Chart)と呼ばれる設定ファイルをレポジトリで管理しています。</div><div class="ui-feed-item__date" title="2021-03-13 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/kubernetes-glossary"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/kubernetes-glossary">Kubernetes用語集</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div 
class="ui-feed-item__summary">仕事上kubernetesを学ぶ必要が出てきました。 筆者のレベルは、Docker・kubernetesの概念・必要性をやんわりと理解している状態です。 勉強をすすめる上で、わからない用語が次々と出てきたて頭の中がパンクしそうになったので、簡潔に随時まとめることとしました。</div><div class="ui-feed-item__date" title="2021-03-06 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/deno-rest-api"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/deno-rest-api">DenoでREST API</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">この記事では、Denoを使い簡単なCRUD操作を行うREST APIを構築します。</div><div class="ui-feed-item__date" title="2021-02-27 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/tailwindcss-dark-mode"><img src="../../images/alternate-feed-image.png" 
loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/tailwindcss-dark-mode">TailwindCSSでダークモード</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">昨今のアプリケーションでは、ダークモードを提供しているのがもはや当たり前になってきました。 OSのレベルでダークモードを設定することができ、ダークモードが提供されていないサイトは眩しく感じしてしまって敬遠してしまうなんて経験はあるのではないでしょうか？ そんな一般化されたダークモードの提供をTailwind CSSで実装します。</div><div class="ui-feed-item__date" title="2021-02-20 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/what-is-graphql"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/what-is-graphql">はじめてのGraphQL</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div 
class="ui-feed-item__summary">GraphQLとは、Facebookが開発したAPI向けのクエリ言語です。RESTに変わるサーバーとクライアントの通信手段として注目を集めています。 リクエスト・レスポンスの型の定義ができる、フロント側から取得するデータを選択することができるなどの特徴があります。 GraphQL自体はSQLのようなクエリ言語としての位置づけなので、Java、Node.js、Ruby、JavaScript、Pythonなど様々な言語で利用することができます。</div><div class="ui-feed-item__date" title="2021-02-16 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/sapper-contentful-vercel-jamstack-blog"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/sapper-contentful-vercel-jamstack-blog">Sapper + contentful + VercelのJamstackで高速なブログを構築する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
JamstackのJamはJavaScript/APIs/Markupの頭文字です。 従来の手法と比較して、高速化・堅牢なセキュリティ。より簡単なスケーラブル・開発体験の向上という特徴を持っています。実行時にAPIから取得したデータを動的にレンダリングせずに、ビルド時にAPIから取得して静的なHTMLとして出力されます。</div><div class="ui-feed-item__date" title="2021-02-13 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/svelte-typescript-tailwindcss-book-search-app-tutorial"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/svelte-typescript-tailwindcss-book-search-app-tutorial">【Svelte + TypeScript + tailwindcss】本検索サイト チュートリアル</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">この記事でははSvelte + TypeScript + tailwindcssで本検索サイトを作成します。 Svelteを使ってアプリケーションを作成1から作成することができます。 以下のことが学べます。 - Svelteの基礎文法 - Svelteのルーティング - Svelteのストア HTML・CSS・JavaScriptの基礎的な理解がある人が対象です。
</div><div class="ui-feed-item__date" title="2021-02-06 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/vue3-test-components"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/vue3-test-components">Vue3 コンポーネントのテスト</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">コンポーネントのテストをするのフレームワークとしてJest、vue-test-utils 2を利用します。Vue2系をターゲットにしているvue-test-utils 1とは一部APIが異なります。</div><div class="ui-feed-item__date" title="2021-02-02 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/what-is-tailwindcss"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div 
class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/what-is-tailwindcss">TailWindCSSとは</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">TailWindCSSはBootStrap・Materialize CSSなどに代表するCSSフレームワークの一つです。 その特徴として、**Utility First**を掲げています。</div><div class="ui-feed-item__date" title="2021-01-30 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/what-is-svelte"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/what-is-svelte">JavaScriptライブラリ Svelteとは</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
Svelteとは、ReactやVue.jsのような宣言的UIライブラリの一種です。その最大の特徴は、ReactやVue.js・Angularと異なりSvelteはコンパイラであることを謳っているところです。Svelteによってコンパイルされたコードは、すべてVanilla JS - ネイティブのJavaScript- にで生成されます。 そのため、コンパイル後のファイルサイズも小さくパフォーマンス上での利点が期待されています。</div><div class="ui-feed-item__date" title="2021-01-23 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/firebase-functions-https-oncall"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/firebase-functions-https-oncall">Firebase Functions https.onCall()トリガーでアプリから簡単に呼び出す</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
Firebase Functionsとは、Firebaseの提供するサーバレスフレームワークです。HTTPSリクエストによって関数を実行したり、FireStore・Cloud Storage・AuthenticationのCRUDイベントをトリガーに関数を実行することができます。使用できる言語はJavaScript・TypeScriptに限られているというデメリットはあるものの、手軽にデプロイでき簡単にプロジェクトの他のFirebaseの機能と統合できるメリットがあります。</div><div class="ui-feed-item__date" title="2021-01-09 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/jest-mock"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/jest-mock">JavaScript テストフレームワークのJestのモックがすごくすごい</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Jestは、JavaScriptのシンプルなテスティングフレームワークです。ゼロコンフィグを謳っており、細かい設定なしに動作させることが可能です。 Jestの中でも特に強力な機能がモッキングです。Jestのモックを利用すれば、外部ライブラリであろうとモジュール外のオブジェクトを簡単にモック化することができます。 実際に、テストコードの例を見ていきましょう。</div><div 
class="ui-feed-item__date" title="2020-12-15 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/vue-js-composition-api-todo-app"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/vue-js-composition-api-todo-app">Vue.js Composition APIでTODOアプリ作成</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Vue3 Composition APIを使って、ハンズオン形式でTODOアプリを作成していきます。</div><div class="ui-feed-item__date" title="2020-12-12 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/how-to-write-javascript-in-the-modern-world"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div 
class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/how-to-write-javascript-in-the-modern-world">イマドキのJavaScriptの書き方</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">JavaScriptはES2015以降から言語自体が大きく変化しました。 ES2015以降も、毎年JavaScriptはアップデートが行われており、最新の使用はES2020となっています。 このように、JavaScriptという言語は日々進化を遂げています。ES2015より前の書き方の多くが非推奨となっており、過去のWebや本の情報は現在ではあまり役に立たなくなっています。 そんなJavaScriptのイマドキの書き方を見ていきましょう。</div><div class="ui-feed-item__date" title="2020-12-04 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/javascript-array-operations"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/javascript-array-operations">すぐに使える！JavaScriptの華麗な配列操作</a><div class="ui-feed-item__blog-title">
azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">JavaScriptで配列操作をする際には、まずはJavascriptが持つ配列のメソッドを眺めて見るとよいでしょう。JavaScriptはライブラリに頼らなくとも自前で高度な操作を可能にしてくれます。 組み込みの配列メソッドはたくさんありますが、その中で私がよく使うメソッドを紹介します。</div><div class="ui-feed-item__date" title="2020-11-28 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/go-test"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/go-test">Go言語 テスト</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Go言語の提供するテストはシンプルです。テストのために覚えることは多くはありません。 Go言語の単体テスト用の機能は`testing`という標準パッケージとして提供されています。ベンチマークやカバレッジ、標準出力のテストなどをカバーしています。 また、テストは`go test`コマンドによって実行されます。サードパーティのツールなどは必要ありません。まずはこの`testing`パッケージの内容を見ていきます。</div><div class="ui-feed-item__date" title="2020-11-14 15:00:00">4年前
</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/go-http"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/go-http">Go 言語　標準パッケージでHTTPサーバー</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Go言語は、標準パッケージでHTTPサーバーと基本的なHTTPクライアントを提供します。 使用するのは、net/httpというパッケージです。</div><div class="ui-feed-item__date" title="2020-11-07 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/go-pointer"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/go-pointer">Go言語 ポインター</a><div 
class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Go言語には、ポインタがあります。 ポインタとは、メモリのアドレスのことです。アドレスは`0xc0000b4008`のような16進数で表されます。</div><div class="ui-feed-item__date" title="2020-10-31 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/go-struct-interface"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/go-struct-interface">Go言語 構造体・インターフェース</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">構造体(Struct)とは、フィールドの集まりです。JavaScriptのオブジェクトよく似ており、データをまとめて1つの集まりの値として表現します。 例えば、座標を表すには緯度と経度がフィールドとして必要になるでしょう。緯度と経度をそれぞれ別の変数として宣言することはできますが、間違いが生じやすく面倒な処理になってしまいます。</div><div class="ui-feed-item__date" title="2020-10-24 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a 
class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/go-collection"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/go-collection">Go言語　コレクション（配列・スライス・マップ）</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">配列は決まった長さを持つ要素を並べた順序のあるコレクションです。 Go言語の配列は固定長になっており、宣言時に長さと要素型を指定します。 長さは後から変更することはできません。 Go言語の配列は柔軟性に欠けるため、実際にはあまり使用されません。可変長であるスライスがよく使われます。 マップはキーと値によって宣言されます。これは、連想配列のようなものです。</div><div class="ui-feed-item__date" title="2020-10-17 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/go-type-function-method"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" 
href="https://azukiazusa.dev/blog/go-type-function-method">Go言語　型・関数・メソッド</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Go言語は静的型付け言語であり、全ての変数は何らかの型に属し、異なる型同士の演算といった問題点の多くはコンパイル時に検出されます。 関数の宣言にはfuncキーワードを使用します。関数の引数と戻り値には型を指定します。戻り値を複数持たせられる、戻り値に名前をつけることができるといった特徴があります。 クラスやオブジェクトはないですが、メソッドはあります。メソッドは型に紐付けられます。</div><div class="ui-feed-item__date" title="2020-10-03 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/what-is-go"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/what-is-go">Go言語基礎文法</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
Go言語(Golang）は、2009年にGoogleによって開発されたオープンソースの静的型付け、コンパイルされるプログラミング言語です。Go言語はコンパイルされるプログラミング言語です。 Go言語はシンプルで、信頼性が高く、効果的なソフトウェアを構築します。</div><div class="ui-feed-item__date" title="2020-09-26 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/css-design"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/css-design">CSSの設計</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">今この文章を読んでいる人ならば、少なくともCSSには触れたことがあると思います。CSSはとても簡単に記述できますが、それゆえにCSSは「壊れやすい」のです。なぜCSSは壊れやすくなってしまうのでしょうか。CSSには「すべてがグローバルスコープ」「複雑化するWeb開発」といった問題点があげられます。そのような状態に対する解決策として、CSSの設計が誕生しました。</div><div class="ui-feed-item__date" title="2020-09-12 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" 
href="https://azukiazusa.dev/blog/express-typescript-mondodb"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/express-typescript-mondodb">Express + TypeScript + MondoDBでやる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Expressは、Node.jsのWebアプリケーションでもっとも利用されているフレームワークです。Expressは、HTTPによるWeb上の相互作用とNOde.jsプラットフォームの中間に位置するので、ある種のミドルウェアと言えます。 Expressを利用して、MVCモデルのアプリケーションを開発してみます。 データベースにはMongoDBを利用し、さらにTypeScriptで書いてみます。</div><div class="ui-feed-item__date" title="2020-06-13 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/node-js"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a 
class="ui-feed-item__title" href="https://azukiazusa.dev/blog/node-js">Node.js - サーバーサイドのJavaScript</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Node.jsは、V8 Javascriptエンジン上に構築されたJavaScriptの実行環境です。サーバーサイドのJavaScript環境であり、非同期、イベント駆動といった特徴があります。</div><div class="ui-feed-item__date" title="2020-06-06 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/firebase-cloud-firestore-query"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/firebase-cloud-firestore-query">Firebase④ Cloud FireStore - クエリ</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Firebase4回目の記事です。 前回は、Firebaseにおける単一のドキュメントに対するCRUD操作までを取り扱いました。 今回は複数のコレクションから取得するためのクエリについて説明していきます。</div><div 
class="ui-feed-item__date" title="2020-05-23 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/what-is-deno"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/what-is-deno">Denoとはなにか - 実際に使ってみる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Denoは、Node.jsの製作者であるRyan Dahlによって作られた、新しいJS/TSランタイムです。簡単に説明すると、Node.jsのイケてなかったところを改良したものがDenoになります。</div><div class="ui-feed-item__date" title="2020-05-16 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/firebase-cloud-storage"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a 
class="ui-feed-item__title" href="https://azukiazusa.dev/blog/firebase-cloud-storage">Firebase③ Cloud Storage</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Firebase3週目の記事です。 今回は、主に画像などのデータを保存するストレージ機能を提供するCloud Storageを取り扱います。 Vue.jsを利用したブログにサムネイル画像を設定する機能をもとに説明していきます。</div><div class="ui-feed-item__date" title="2020-05-02 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/javascript-ecmascript-babel"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/javascript-ecmascript-babel">JavaScript ECMAScriptとかBabelとか</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">JavaScript ECMAScriptとかBabelとか</div><div class="ui-feed-item__date" 
title="2020-04-30 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/firebase-cloud-firestore"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/firebase-cloud-firestore">Firebase④ Cloud FireStore</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Cloud FireStore(以下FireStore)とは、FireBaseの提供するドキュメント指向型 のNoSQLデータベースです。 NoSQLとしての特徴としてのスキーマレス、スケーラブルといった特徴のほかにリアルタイムアップデート、セキュリティルール、オフラインサポートといった独自の特徴を備えており、特にバックエンドを介さずにクライントサイドから直接操作できるという点が大きなポイントです。 また、β版から正式リリースされたのが2019年2月ということもあり、比較的新しい技術です。</div><div class="ui-feed-item__date" title="2020-04-25 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/firebase-firebase-authentication"><img 
src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/firebase-firebase-authentication">Firebase② Firebase Authentication</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Firebase第二弾です。 Firebase Authenticationのメールアドレスによるログインと、FireStorageについて説明していきます。</div><div class="ui-feed-item__date" title="2020-04-18 15:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/what-is-firebase"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/what-is-firebase">firebaseとは</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
Firebaseは、Googleが提供するバックエンドサービスです。 Firebaseは、バックエンドのサービスを担ってくれるので、開発者はアプリケーションの開発に専念することができ、バックエンドで動くサービスを作成、管理する必要はありません。 そのため、素早くアプリケーションをリリースるることができます。 Firebaseは、iOS/AndroidアプリからWebサービスまで幅広く使えます。 認証、データベース、ストレージなどたくさんの機能が使用できます。</div><div class="ui-feed-item__date" title="2020-04-11 15:00:00">5年前</div></div></div></div></div></section></main><footer role="contentinfo" class="ui-section-footer"><div class="ui-layout-container"><div class="ui-layout-column-6 ui-layout-column-center"><div class="ui-component-cta ui-layout-flex ui-section-footer__site-info"><p class="ui-text-note">このサイトはJSer.infoの情報源となるサイトの更新を一覧できる目的で作成されたものです。<br>一つのRSSフィードを購読するだけで、複数のサイトの更新情報を取得できます。</p><p class="ui-text-note">このサイトの仕組みは、<a href="https://github.com/jser/watch-list-rss/">GitHubのREADME</a>で公開されています。</p></div></div></div><div class="ui-layout-container"><div class="ui-section-footer__layout ui-layout-flex"><p class="ui-section-footer--copyright ui-text-note"><a class="ui-text-note" 
href="https://github.com/jser/"><small>@jser</small></a></p><a href="https://github.com/jser/watch-list-rss/" role="link" aria-label="#" class="ui-text-note"><small>GitHub</small></a></div></div></footer></body></html>