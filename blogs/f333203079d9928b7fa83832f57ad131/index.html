<!doctype html><html lang="ja"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="JSer.infoの情報源となるサイトのRSSフィードをまとめたサイトです。JavaScriptの情報源を集めることを目的としています。"><meta name="author" content="jser"><meta name="robots" content="index, follow"><meta property="og:url" content="https://jser.info/watch-list-rss/"><meta property="og:title" content="azukiazusa のテックブログ2のフィード｜JSer.info Watch List RSS"><meta property="og:image" content="https://jser.info/watch-list-rss/images/og-image.png"><meta property="og:description" content="JSer.infoの情報源となるサイトのRSSフィードをまとめたサイトです。JavaScriptの情報源を集めることを目的としています。"><meta property="og:type" content="website"><meta property="og:site_name" content="JSer.info Watch List RSS"><meta property="og:locale" content="ja_JP"><meta name="twitter:card" content="summary"><meta property="twitter:domain" content="https://jser.info/watch-list-rss/"><meta property="twitter:url" 
content="https://jser.info/watch-list-rss/"><meta name="twitter:title" content="azukiazusa のテックブログ2のフィード｜JSer.info Watch List RSS"><meta name="twitter:description" content="JSer.infoの情報源となるサイトのRSSフィードをまとめたサイトです。JavaScriptの情報源を集めることを目的としています。"><meta name="twitter:image" content="https://jser.info/watch-list-rss/images/og-image.png"><meta name="thumbnail" content="https://jser.info/watch-list-rss/images/og-image.png"><link rel="preload" href="../../styles/bundle.css" as="style"><link rel="shortcut icon" href="../../images/favicon.ico"><link rel="apple-touch-icon" href="../../images/apple-icon.png"><link rel="alternate" type="application/atom+xml" title="Atom Feed" href="../../feeds/atom.xml"><link rel="alternate" type="application/rss+xml" title="RSS2.0" href="../../feeds/rss.xml"><link rel="alternate" type="application/json" href="../../feeds/feed.json"><link rel="stylesheet" type="text/css" href="../../styles/bundle.css"><title>azukiazusa のテックブログ2のフィード｜JSer.info Watch List RSS</title>
</head><body><header role="banner" class="ui-section-header"><div class="ui-layout-container"><div class="ui-section-header__layout ui-layout-flex"><a href="https://jser.info/watch-list-rss/" role="link" aria-label="#"><img src="../../images/icon.png" alt="サイトロゴ" loading="eager" width="96" height="96"> <span class="ui-section-header__title">JSer.info Watch List RSS</span></a><div class="ui-section-header__links"><a href="https://github.com/jser/watch-list-rss/" role="link" aria-label="#" target="_blank"><img src="../../images/icon-github.png" alt="GitHubロゴ" loading="eager" width="96" height="96"> </a><a href="https://x.com/jser_info" role="link" aria-label="#" target="_blank"><img src="../../images/icon-x.png" alt="Xロゴ" loading="eager" width="96" height="96"></a></div></div></div></header><main role="main"><nav class="ui-nav"><div class="ui-layout-container"><div class="ui-section-nav__layout ui-layout-flex"><a class="ui-section-nav__link" href="../../">フィード</a> <a 
class="ui-section-nav__link" href="../../hot/">人気フィード</a> <a class="ui-section-nav__link" href="../../blogs/">ブログ一覧</a></div></div></nav><section class="ui-section-content ui-section-feed"><div class="ui-layout-container"><h2 class="ui-typography-heading">azukiazusa のテックブログ2</h2><div class="ui-container-blog-summary"><div class="ui-blog-summary"><a class="ui-blog-summary__link" href="https://azukiazusa.dev">https://azukiazusa.dev</a><p class="ui-blog-summary__description">azukiazusaのテックブログ2です。週に1回 Web 開発に関する記事をお届けします。フロントエンドに関する分野の記事が中心です。</p></div></div><h3 class="ui-typography-heading">フィード</h3><div class="ui-section-content--feature ui-layout-grid ui-layout-grid-3 ui-container-feed ui-container-feed--no-image"><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/build-tui-with-opentui"><picture><source type="image/avif" srcset="../../images/feed-thumbnails/3XUZzVJI_I-256.avif 256w, ../../images/feed-thumbnails/3XUZzVJI_I-512.avif 512w" 
sizes="(min-width: 75rem) 16rem, (min-width: 64rem) 19rem, (min-width: 48rem) 19rem, 8rem"><img alt="記事のアイキャッチ画像" loading="lazy" src="../../images/feed-thumbnails/3XUZzVJI_I-256.jpeg" width="512" height="268" srcset="../../images/feed-thumbnails/3XUZzVJI_I-256.jpeg 256w, ../../images/feed-thumbnails/3XUZzVJI_I-512.jpeg 512w" sizes="(min-width: 75rem) 16rem, (min-width: 64rem) 19rem, (min-width: 48rem) 19rem, 8rem"></picture></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/build-tui-with-opentui">TUI を構築するための Typescript ライブラリ OpenTUI</a><div class="ui-feed-item__hatena-count" title="はてなブックマーク数"><img src="../../images/hatenabookmark-icon.png" alt="はてなブックマークアイコン" loading="lazy" width="96" height="96"> <span>6</span></div><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
AI コーディングエージェントの普及により、ターミナルベースの TUI アプリケーションの需要が高まっています。OpenTUI は Typescript で TUI アプリケーションを簡単に構築できるライブラリです。この記事では OpenTUI の特徴と基本的な使い方を紹介します。</div><div class="ui-feed-item__date" title="2026-01-18 02:17:00">11時間前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/agent-browser-for-ai-agents"><picture><source type="image/avif" srcset="../../images/feed-thumbnails/UGnxRPMVLV-256.avif 256w, ../../images/feed-thumbnails/UGnxRPMVLV-512.avif 512w" sizes="(min-width: 75rem) 16rem, (min-width: 64rem) 19rem, (min-width: 48rem) 19rem, 8rem"><img alt="記事のアイキャッチ画像" loading="lazy" src="../../images/feed-thumbnails/UGnxRPMVLV-256.jpeg" width="512" height="268" srcset="../../images/feed-thumbnails/UGnxRPMVLV-256.jpeg 256w, ../../images/feed-thumbnails/UGnxRPMVLV-512.jpeg 512w" sizes="(min-width: 75rem) 16rem, (min-width: 64rem) 19rem, (min-width: 48rem) 19rem, 8rem"></picture></a><div class="ui-feed-item__content"><a 
class="ui-feed-item__title" href="https://azukiazusa.dev/blog/agent-browser-for-ai-agents">AI エージェントのために CLI でブラウザを操作する agent-browser</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">agent-browser は Vercel が開発した CLI でブラウザを操作するツールであり、AI エージェントにブラウザ操作能力を提供するために設計されています。この記事では agent-browser のインストール方法、基本的な使い方、AI エージェントからの利用方法について紹介します。</div><div class="ui-feed-item__date" title="2026-01-12 06:25:00">6日前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/claude-code-ccstatusline"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/claude-code-ccstatusline">Claude Code のステータスラインを TUI でカスタマイズできる ccstatusline</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
Claude Code のステータスラインは oh-my-zsh のターミナルプロンプトのようにカスタマイズ可能です。これにより現在のブランチやトークンの使用量などを一目で確認できるようになります。この記事では TUI で簡単にステータスラインをカスタマイズできる ccstatusline の使い方を紹介します。</div><div class="ui-feed-item__date" title="2026-01-10 01:30:00">9日前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/motia-backend-framework"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/motia-backend-framework">1 つの Step で完結するバックエンドフレームワーク Motia を試してみた</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Motia はバックエンド開発をシンプルにすることを目指したコードファーストのバックエンドフレームワークです。この記事では Motia を使用して簡単な TODO REST API を構築する方法を紹介します。</div><div class="ui-feed-item__date" title="2026-01-05 10:23:00">13日前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" 
href="https://azukiazusa.dev/blog/using-figma-mcp-to-provide-design-system-for-ai-coding-agents"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/using-figma-mcp-to-provide-design-system-for-ai-coding-agents">Figma MCP でデザインシステムを提供して AI コーディングエージェントに一貫したフロントエンドコードを書かせる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">AI コーディングエージェントにフロントエンドのコードを書かせる際、Figma MCP を使用してデザインコンテキストやデザイントークンを提供することで、一貫したデザインガイドラインを遵守させる方法を紹介します。</div><div class="ui-feed-item__date" title="2026-01-03 01:27:00">16日前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/enable-claude-code-tool-search-to-reduce-mcp-token-usage"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div 
class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/enable-claude-code-tool-search-to-reduce-mcp-token-usage">Claude Code のツール検索ツールを有効にして MCP のトークン使用量を削減する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Claude Code のツール検索ツールを有効にすることで、MCP ツールの定義を事前にコンテキストウィンドウに読み込まず、必要に応じて動的にツールを検索・呼び出しできます。これにより、多数の MCP ツールをインストールしている場合でもトークン使用量を大幅に削減できる可能性があります。この記事では Claude Code のツール検索ツールの概要と使用方法を紹介します。</div><div class="ui-feed-item__date" title="2025-12-30 05:32:00">19日前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/books-i-liked-in-2025"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/books-i-liked-in-2025">2025 年に読んでよかった本</a><div class="ui-feed-item__blog-title">
azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">AI を活用するための技術というのはとりわけ新しいものではなく、過去の知見を基盤として構築されていることが多いです。それゆえに、AI 時代だからこそ基礎的な知識を体系的に学ぶことができる書籍に学ぶことに価値を求めるのです。この記事では 2025 年に読んで特に印象に残った本をいくつか紹介します。</div><div class="ui-feed-item__date" title="2025-12-27 02:10:00">22日前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/claude-code-lsp-support"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/claude-code-lsp-support">Claude Code の LSP サポート</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Claude Code のバージョン 2.0.74 から LSP（Language Server Protocol）サポートが追加されました。LSP サポートにより、Claude Code はコードベースに対してシンボルの定義検索、参照検索、ホバー情報の取得などの操作が可能になります。この記事では Claude Code の LSP サポートの概要と使用方法を紹介します。</div><div class="ui-feed-item__date" 
title="2025-12-20 06:12:00">1ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/try-react-grab-for-agents"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/try-react-grab-for-agents">ブラウザから要素を選択してエージェントにコンテキストを提供する React Grab を試してみた</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">React Grab はブラウザ上で要素を選択し、その要素に対応するコードコンテキストをコーディングエージェントに提供するライブラリです。この記事では React Grab のセットアップ方法と使用方法を紹介します。</div><div class="ui-feed-item__date" title="2025-12-14 01:47:00">1ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/try-tanstack-start"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div 
class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/try-tanstack-start">フルスタックフレームワーク TanStack Start を試してみた</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">TanStack Start は TanStack Router と Vite をベースにしたフルスタック React フレームワークです。型安全なルーティング、サーバーサイドレンダリング、ストリーミング、サーバー関数、API ルートなどの機能を提供します。この記事では TanStack Start の概要と基本的な使い方を紹介します。</div><div class="ui-feed-item__date" title="2025-12-13 05:30:00">1ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/try-tanstack-ai"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/try-tanstack-ai">TypeScript 向けの AI フレームワーク TanStack AI を試してみた</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
TanStack AI は TanStack チームが開発する TypeScript 向けの軽量な AI フレームワークです。LLM プロバイダーのインターフェイスを抽象化し、ツール呼び出しやチャット機能を提供します。この記事では TanStack AI の概要と基本的な使い方を紹介します。</div><div class="ui-feed-item__date" title="2025-12-07 06:26:00">1ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/claude-programmatic-tool-calling"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/claude-programmatic-tool-calling">Claude のプログラミングによるツール呼び出し</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">MCP ツールの呼び出しはコンテキスト汚染や推論のオーバーヘッドなどの課題があります。Claude のプログラムによるツール呼び出し機能を利用することで、これらの課題を解決する方法について解説します。</div><div class="ui-feed-item__date" title="2025-12-07 02:42:00">1ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" 
href="https://azukiazusa.dev/blog/trying-claude-tool-finder"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/trying-claude-tool-finder">Claude のツール検索ツールを試してみた</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">MCP では多くのツール定義が LLM のコンテキストを圧迫する問題があります。Claude のツール検索ツールを使用すると、必要に応じて関連するツールのみを LLM に提供でき、コンテキスト圧迫を軽減できます。この記事では Claude の TypeScript クライアントを使用して、ツール検索ツールを実際に使用した例を紹介します。</div><div class="ui-feed-item__date" title="2025-11-30 06:11:00">2ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/claude-code-plan-mode-improved"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" 
href="https://azukiazusa.dev/blog/claude-code-plan-mode-improved">Claude Code のプランモードがより正確な計画を立てられるようになっていた</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Claude Code のプランモードはリリース当初から定期的に改善が加えられており、より正確な計画を立てられるようになっています。この記事では最近の改善点について紹介します。</div><div class="ui-feed-item__date" title="2025-11-30 05:39:00">2ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/my-reading-techniques-300-books-a-year"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/my-reading-techniques-300-books-a-year">読んだ本は忘れていい ― 年間300冊読む私の読書術</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
以前 YAPC::Fukuoka 2025 で発表した探求の技術では「良いアウトプットを出すためには良いインプットが必要」であるという主張を裏付けるために、私が年間 300 冊の本を読む読書習慣があることを紹介しました。この記事では私がどのような目的で本を読み、どのように本を選び、どのように読書時間を確保し、そして読んだ内容をどのように扱っているのかについて紹介します。</div><div class="ui-feed-item__date" title="2025-11-25 12:17:00">2ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/mcp-standard-ui-extension"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/mcp-standard-ui-extension">MCP におけるインタラクティブな UI を標準化する拡張機能 MCP Apps の提案</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">MCP Apps は MCP の拡張機能として、AI エージェントがインタラクティブな UI コンポーネントを返すための標準化された方法を提供します。この記事では MCP Apps の概要と実装方法について解説します。</div><div class="ui-feed-item__date" title="2025-11-22 06:09:00">2ヶ月前</div></div></div><div 
class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/urlpattern-web-api"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/urlpattern-web-api">標準の Web API で URL のパターンマッチングを処理する URLPattern</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Web アプリケーションにおけるルーティングは重要な要素です。URL Pattern API は URL のパターンマッチングを標準化するための Web API であり、ブラウザやサーバーサイド環境で一貫した方法で URL パターンを処理できます。この記事では、URLPattern API の基本的な使い方とパターン構文について解説します。</div><div class="ui-feed-item__date" title="2025-11-13 12:33:00">2ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/mcp-tool-context-overflow"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div 
class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/mcp-tool-context-overflow">MCP ツールのコンテキスト圧迫の問題とその解決策</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">MCP の普及に伴い、多数のツール定義が LLM のコンテキストを圧迫する課題が浮上しています。本記事では Progressive disclosure（段階的開示）による最小限の情報提供、MCP を使ったコード実行によるツール呼び出しの効率化、単一の検索ツールによるコンテキスト削減など、実践的な解決策を Claude Skills や Cloudflare Code Mode の事例とともに解説します。</div><div class="ui-feed-item__date" title="2025-11-09 01:38:00">2ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/claude-code-sandbox-feature"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/claude-code-sandbox-feature">Claude Code のサンドボックス機能を試してみた</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div>
<div class="ui-feed-item__summary">Claude Code をはじめとする AI コーディングエージェントは、コマンドを実行するたびにユーザーの承認を求める仕組みが備わっていますが、これには開発サイクルの低下や承認疲れといった問題があります。Claude Code のサンドボックス機能は、ファイルシステムやネットワークへのアクセスを制限し、安全に動作させるための仕組みです。この記事では、Claude Code のサンドボックス機能の仕組みと利用方法について解説します。</div><div class="ui-feed-item__date" title="2025-11-01 05:47:00">3ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/claude-skills-custom-skills-for-claude"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/claude-skills-custom-skills-for-claude">Claude Skills でエージェントに専門的なタスクを実行させる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Claude Skills は Claude が特定のタスクを実行するためのカスタムスキルを作成・共有できる新しい機能です。この記事では、Claude Skills の仕組みと作成方法、MCP ツールとの違いについて解説します。</div><div 
class="ui-feed-item__date" title="2025-10-26 01:23:00">3ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/try-remix-v3"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/try-remix-v3">Remix v3 を実際に動かして試してみた</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">2025 年 10 月に発表された Remix v3 は React から独立し、Web 標準技術を活用した新しいフレームワークへと進化しました。この記事では、Remix v3 のセットアップ手順と新機能を実際に動かして試してみた内容を紹介します。</div><div class="ui-feed-item__date" title="2025-10-18 06:10:00">3ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/playwright-agents"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div 
class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/playwright-agents">Playwright Agents によるテストの自動生成を試してみた</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Playwright v1.56 で導入された Playwright Agents は、Planner、Generator、Healer の 3 つのエージェントで構成されており、アプリケーションコードを解析してテストケースの計画、テストコードの生成、失敗したテストの修正を自動化できます。この記事では、Claude Code から Playwright Agents を呼び出して、シンプルなカンバンアプリのテストコードを自動生成する手順を紹介します。</div><div class="ui-feed-item__date" title="2025-10-12 02:39:00">3ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/chatgpt-apps-sdk"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/chatgpt-apps-sdk">ChatGPT 内でアプリを直接操作する Apps SDK に自作のアプリを接続する</a><div class="ui-feed-item__blog-title">
azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Apps in ChatGPT は ChatGPT のチャット内で会話の流れに応じて外部のアプリを呼び出し、インタラクティブな操作を可能にする機能です。アプリごとに独自の UI コンポーネントを提供し、ユーザーはチャット画面からシームレスな体験でアプリを操作できます。この記事では Apps SDK を使用して、実際に ChatGPT 内で動作するシンプルなアプリを作成する手順を紹介します。</div><div class="ui-feed-item__date" title="2025-10-11 02:31:00">3ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/claude-code-plugins"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/claude-code-plugins">Claude Code の設定をプラグインで共有する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Claude Code は強力なコーディング支援ツールですが、効果的に活用するためには適切な設定が必要です。プラグインを使用することで、スラッシュコマンド、サブエージェント、MCP サーバー、フックなどの設定をパッケージ化し、他のユーザーと簡単に共有できます。この記事では、Claude Code のプラグインの作成方法と利用方法について解説します。</div>
<div class="ui-feed-item__date" title="2025-10-10 10:32:00">3ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/mcp-tool-annotations"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/mcp-tool-annotations">MCP のツールアノテーションでユーザーにヒントを提供する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">MCP ではツールアノテーションを使用して、ユーザーにツールの動作に関するヒントを提供できます。例えば `readOnlyHint` を設定することで、ツールがデータを変更しないことを示すことができます。この記事では TypeScript SDK を使用して MCP サーバーでツールアノテーションを設定し、Claude Code クライアントでどのように表示されるかを確認します。</div><div class="ui-feed-item__date" title="2025-10-04 01:18:00">3ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/chrome-devtools-mcp"><img 
src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/chrome-devtools-mcp">Chrome DevTools MCP で AI エージェントのフロントエンド開発をサポートする</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">自律的な AI エージェントを利用したコーディングでは、生成したコードを実行した結果からフィードバックを得て、コードを改善していく反復的なプロセスが重要です。しかし、フロントエンド開発では、生成したコードはブラウザ上で実行されるため、AI エージェントが直接コードを実行したり、ブラウザのコンソールログを取得したりすることは困難です。Chrome DevTools MCP はこの課題を解決するためのツールです。</div><div class="ui-feed-item__date" title="2025-09-27 01:46:00">4ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/yaml-file-defined-ai-agent-cagent"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" 
href="https://azukiazusa.dev/blog/yaml-file-defined-ai-agent-cagent">YAML ファイルで AI エージェントを構築する cagent</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">cagent は Docker 社が開発した AI エージェントフレームワークです。YAML ファイルでエージェントの振る舞い・役割・使用するツールを宣言的に定義でき、コードを 1 行も書かずにエージェントを構築できます。この記事では cagent の概要とインストール方法、YAML ファイルの書き方、実際にエージェントを動作させるまでの手順を解説します。</div><div class="ui-feed-item__date" title="2025-09-23 01:05:00">4ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/56oQ43Wsd5tNqdkjVx962C"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/56oQ43Wsd5tNqdkjVx962C">browserslist で Baseline を設定できるようになった</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
browserslist は、フロントエンド開発において、どのブラウザをサポートするかを指定するためのツールです。これにより、開発者はターゲットとするブラウザの範囲を簡単に定義でき、CSS や JavaScript のトランスパイルやポリフィルの適用を自動化できます。</div><div class="ui-feed-item__date" title="2025-09-22 15:00:00">4ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/2fhsF5dtyd30gLbArJnkb1"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/2fhsF5dtyd30gLbArJnkb1">GitHub Actions で YAML アンカーを使う</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">GitHub Actions のワークフローで YAML アンカーがサポートされました。YAML アンカーを使用すると、ワークフロー内でコードの重複を避け、共通の設定を再利用できます</div><div class="ui-feed-item__date" title="2025-09-20 15:00:00">4ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" 
href="https://azukiazusa.dev/blog/trying-agent-payments-protocol-ap2"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/trying-agent-payments-protocol-ap2">AI エージェントのための Agent Payments Protocol (AP2) を試してみた</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">現状の決済システムでは人間が信頼できる画面上で直接購入ボタンをクリックすることを前提としており、自立型の AI エージェントがユーザーに代わって決済することは想定されていません。そこで Google により Agent Payments Protocol (AP2) と呼ばれる新しいプロトコルが提案されました。プラットフォーム間でエージェント主導の決済を安全に開始・処理することを可能にします。この記事では AP2 のサンプルコードを実際に試してみた手順を紹介します。</div><div class="ui-feed-item__date" title="2025-09-20 05:30:00">4ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/4vvHYJCCU0KH7hIajLRkVL"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" 
width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/4vvHYJCCU0KH7hIajLRkVL">pnpm の minimumReleaseAge オプションでサプライチェーン攻撃を防ぐ</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">最近は npm パッケージのサプライチェーン攻撃が増えています。幸いほとんどの場合悪意のあるパッケージは公開から 1 週間以内に削除されるため、公開から一定期間が経過したパッケージのみをインストールすることでリスクを軽減できます。</div><div class="ui-feed-item__date" title="2025-09-13 15:00:00">4ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/natural-language-ci-cd-with-agentic-workflows"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/natural-language-ci-cd-with-agentic-workflows">自然言語で CI/CD パイプラインを定義する Agentic Workflows</a><div class="ui-feed-item__blog-title">
azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Agentic Workflows は自然言語で CI/CD パイプラインを定義できるツールとして GitHub Next が開発しています。自然言語で定義されたワークフローは GitHub CLI の拡張機能として提供される gh aw コマンドでコンパイルして実行できます。これは継続体なAI（Continuous AI）を実現するためのツールです。</div><div class="ui-feed-item__date" title="2025-09-13 02:26:00">4ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/spec-driven-development-with-spec-kit"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/spec-driven-development-with-spec-kit">仕様駆動開発を支える Spec Kit を試してみた</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
仕様駆動開発（Specification-Driven Development, SDD）は、AI コーディングエージェントを活用した新しいソフトウェア開発スタイルです。GitHub が提供する Spec Kit は、仕様駆動開発を支援するためのツールキットであり、AI との対話を通じて正確な受け入れ基準の定義とコード生成を支援します。この記事では Spec Kit を使用して仕様駆動開発を試してみます。</div><div class="ui-feed-item__date" title="2025-09-07 01:58:00">4ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/coding-agent-management-vibe-kanban"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/coding-agent-management-vibe-kanban">AI コーディングエージェントの管理を行う Vibe Kanban を試してみた</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Vibe Kanban は、AI コーディングエージェントの管理を支援するためのツールです。カンバン方式の UI でタスク管理を行い、各タスクに対して AI エージェントを割り当てて人間がその進捗を管理できます。この記事では Vibe Kanban を使用して AI コーディングエージェントの管理を実際に試してみます。</div><div 
class="ui-feed-item__date" title="2025-08-30 05:19:00">5ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/claude-code-learning-mode"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/claude-code-learning-mode">Claude Code の学習モードで自分の手でコードを書く練習をしよう</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">コーディングに AI エージェントを活用する流れはもはや避けられないものとなっています。しかし、AI エージェントによってコーディングの多くが自動化されると、開発者が自分の手でコードを書く機会は減少してしまうというジレンマがあります。Claude Code の学習モードを使用すると、自分の手でコードを書く練習ができます。学習モードでは、AI エージェントはユーザー自身にも一部のコードの生成を依頼します。この記事では、Claude Code の学習モードの使い方について解説します。</div><div class="ui-feed-item__date" title="2025-08-23 04:01:00">5ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" 
href="https://azukiazusa.dev/blog/shorts/1UIDYiElwAL6Gxm0eMGaGT"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/1UIDYiElwAL6Gxm0eMGaGT">コーディングエージェントが参照するファイルを統一する AGENTS.md</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">コーディングエージェントを使用する際にはプロジェクトの技術スタックやビルド手順、コーディング規約を記載したドキュメントを用意して、コンテキストに含めるのが一般的な手法です。しかし、 コーディングエージェントの製品ごとに異なるファイル名で用意しなければいけないという問題がありました。</div><div class="ui-feed-item__date" title="2025-08-19 15:00:00">5ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/poml-prompt-structured-document"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" 
href="https://azukiazusa.dev/blog/poml-prompt-structured-document">LLM へのプロンプトを構造化された文書で管理する POML</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">POML (Prompt Orchestration Markup Language) は、Microsoft によって提案されたプロンプトを構造化された文書として管理するためのマークアップ言語です。プロンプト開発における構造の欠如や複雑なデータとの統合の困難さ、特定のフォーマットへの依存性といった課題を解決することを目指しています。</div><div class="ui-feed-item__date" title="2025-08-16 02:31:00">5ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/mcp-ui"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/mcp-ui">AI エージェントがインタラクティブな UI を返すことを可能にする MCP UI</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
MCP UI は Model Context Protocol (MCP) を拡張して、AI エージェントがインタラクティブな UI コンポーネントを返すことを可能にする仕組みです。これにより、AI エージェントとのチャットの返答としてグラフや画像ギャラリー、購入フォームなどを表示できます。この記事では MCP UI の SDK を利用して、AI エージェントがインタラクティブな UI コンポーネントを返す方法を試してみます。</div><div class="ui-feed-item__date" title="2025-08-09 01:49:00">5ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/coding-agent-qwen3-corder"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/coding-agent-qwen3-corder">コーディングのための LLM モデル Qwen3-Coder を試してみた</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Alibaba が開発した Qwen3-Coder を使用したコーディングエージェント Qwen Code を試してみた記事です。OpenRouter 経由での認証設定、コードベースの調査、リファクタリング、テストコード生成などの実際の使用例を紹介しています。</div><div class="ui-feed-item__date" title="2025-08-03 00:49:00">
6ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/serena-coding-agent"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/serena-coding-agent">コーディングエージェントの能力を拡張する Serena を試してみた</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">LSP を活用してセマンティックなコード検索・編集能力を提供する MCP サーバー Serena の導入・使用方法を紹介。Claude Code でのオンボーディングからリファクタリングまでの実践的な活用例を解説します。</div><div class="ui-feed-item__date" title="2025-08-02 02:11:00">6ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/sveltekit-remote-functions"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a 
class="ui-feed-item__title" href="https://azukiazusa.dev/blog/sveltekit-remote-functions">SvelteKit の remote functions でコンポーネント内で非同期にデータを取得する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">SvelteKit の remote functions を使用することで、コンポーネント内で直接非同期にデータを取得したり、サーバーにデータを書き込むことができます。これにより、コンポーネントごとに必要なデータを個別に取得できるようになり、コードの責任の分離が容易になります。remote functions は SvelteKit v2.27 以降で利用可能です。</div><div class="ui-feed-item__date" title="2025-08-01 10:31:00">6ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/create-custom-sub-agent-in-claude-code"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/create-custom-sub-agent-in-claude-code">Claude Code でカスタムサブエージェントを作成する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div>
<div class="ui-feed-item__summary">Claude Code では特定の種類のタスクを処理するために呼び出されるカスタムサブエージェントを作成できます。カスタムサブエージェントを使用することでメインの会話セッションとは別に独立したコンテキストウィンドウを持つことができ、コンテキストの汚染を防ぐことができます。この記事では、Claude Code でカスタムサブエージェントを作成する方法とその利点について解説します。</div><div class="ui-feed-item__date" title="2025-07-26 03:17:00">6ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/7KZCLXbHxoaCfJ92aES3uE"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/7KZCLXbHxoaCfJ92aES3uE">Cookie を管理する非同期 API CookieStore</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
従来の JavaScript では Cookie の管理は `document.cookie` を使用して文字列で行われていました。しかし、文字列での Cookie 管理は面倒で間違いやすいです。また `document.cookie` は同期的に動作するため、Cookie の更新が完了するまでイベントループがブロックされてしまいます。さらに `document` オブジェクトに依存しているため、Web Worker や Service Worker などの非同期環境では使用できません。このような問題を解決するために、非同期 API `CookieStore` が導入されました。`CookieStore` は非同期的に Cookie の読み書きを行うことができ、さらに Cookie の属性をオブジェクトとして扱うことができます。</div><div class="ui-feed-item__date" title="2025-07-25 15:00:00">6ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/computer-it-books"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/computer-it-books">私のキャリアに影響を与えたコンピューター・IT の定番書籍</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
現代は知らないことがあればすぐにインターネットで調べたり、AI に質問できる時代です。このような時代において本を読む必要はあるのでしょうか？答えは Yes です。なぜなら、検索をしたり AI に質問をするためには、ある程度の基礎知識が必要だからです。この記事では私のキャリアにおいて影響を与えたであろうコンピューター・IT の定番書籍を紹介します。</div><div class="ui-feed-item__date" title="2025-07-20 02:26:00">6ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/kiro-agent-ide"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/kiro-agent-ide">AWS の エージェント IDE Kiro を使ってみた</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Kiro は AWS が開発した IDE 内蔵型の AI コーディングエージェントです。Kiro の特徴は単なるバイブコーディングにとどまらず、スペックを使用して仕様駆動開発でアプリケーションを開発できることです。この記事では Kiro を使ったアプリケーション開発の流れを紹介します。</div><div class="ui-feed-item__date" title="2025-07-15 11:19:00">6ヶ月前</div></div></div><div class="ui-feed-item"><a 
class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/mcp-server-container-use"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/mcp-server-container-use">サンドボックス環境を MCP サーバーで提供する Container Use</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">AI コーディングエージェントは便利ですが、任意の Bash コマンドを実行できるため、ユーザーのシステムに影響を与える可能性があります。Container Use は MCP サーバーとして動作し、AI コーディングエージェントにサンドボックス環境を提供します。この記事では Container Use の利用方法について紹介します。</div><div class="ui-feed-item__date" title="2025-07-13 10:44:00">6ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/try-v0-sdk"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a 
class="ui-feed-item__title" href="https://azukiazusa.dev/blog/try-v0-sdk">v0 の SDK を試してみる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">v0 は Vercel が開発した AI ベースの Web アプリケーション・UI 生成ツールです。v0 のプラットフォーム API を使用すると、v0 の機能を自身のコードから利用できます。この記事では v0 TypeScript SDK を使用して、v0 のプラットフォーム API を試してみます。</div><div class="ui-feed-item__date" title="2025-07-12 00:32:00">6ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/1U7o1oYd6dUDaf3xOM5HVd"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/1U7o1oYd6dUDaf3xOM5HVd">Claude Code で前回の会話の続きを開始する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
Claude Code でうっかりセッションを閉じてしまった経験が一度はあるのではないでしょうか？一度セッションを終了すると会話のコンテキストが失われてしまいますが、Claude Code では前回の会話の続きを開始する方法があります。</div><div class="ui-feed-item__date" title="2025-07-11 15:00:00">6ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/css-progress-function"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/css-progress-function">値の補間計算を簡潔に記述できる CSS の `progress` 関数</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">CSS の `progress` 関数は、2 つの長さの値の間の進捗を計算するための数学関数です。流体タイポグラフィやレスポンシブなレイアウト調整に利用できます。流体タイポグラフィは `clamp` 関数を使用して実装することもできますが、`progress` 関数を使用することでより意図を明確に記述できます。この記事では、CSS の `progress` 関数の構文と使用例について解説します。</div><div class="ui-feed-item__date" title="2025-07-06 00:41:00">6ヶ月前</div></div></div><div 
class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/claude-code-hooks-run-formatter"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/claude-code-hooks-run-formatter">Claude Code の Hooks で作業が終わった後にフォーマッターを実行する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Claude Code hooks は Claude Code のライフサイクルの特定のタイミングで実行されるユーザー定義のシェルスクリプトです。hooks を使用することで、コードのフォーマットを常に実行することができます。この記事では hooks を使用してコードの変更後に prettier が実行されるように設定してみましょう。</div><div class="ui-feed-item__date" title="2025-07-01 02:03:00">7ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/one-click-mcp-server-installation-dxt-file"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" 
height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/one-click-mcp-server-installation-dxt-file">ワンクリックで MCP サーバーをインストールする .dxt ファイル</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Model Context Protocol (MCP) サーバーは LLM が外部のツールと対話するための標準的な方法ですが、インストールが複雑でハードル高いという課題があります。`.dxt` ファイルは MCP サーバーを簡単にインストールできるパッケージ形式です。これを使用することでユーザーはターミナルを操作したり JSON ファイルを編集することなく MCP サーバーを利用できるようになります。</div><div class="ui-feed-item__date" title="2025-06-28 23:17:00">7ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/mcp-structured-output"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/mcp-structured-output">MCP の Structured tool output を試してみる</a><div 
class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">MCP の 2025-06-18 バージョンでは Structured tool output がサポートされました。ツールの定義で `outputSchema` を出力のスキーマを定義し、`structuredContent` フィールドに構造化された出力を返すことができます。この記事では MCP の TypeScript SDK を使用して Structured tool output を試してみます。</div><div class="ui-feed-item__date" title="2025-06-28 05:47:00">7ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/claude-code-custom-slash-command"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/claude-code-custom-slash-command">Claude Code でカスタムスラッシュコマンドを作成する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
Claude Code では `/` で始まる文字列がスラッシュコマンドとして定義されておりあらかじめ割り当てられた操作を実行できます。スラッシュコマンドはユーザーが独自に定義することもできます。この記事では、Claude Code でカスタムスラッシュコマンドを作成する方法について説明します。</div><div class="ui-feed-item__date" title="2025-06-21 23:10:00">7ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/use-mcp-react-hook"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/use-mcp-react-hook">ブラウザから MCP サーバーに接続する use-mcp React フック</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">use-mcp はリモートの MCP サーバーに接続するための React フックです。ツールの呼び出しや認証を簡単に行うことができます。この記事では、use-mcp を使用して MCP サーバーに接続し、ツールを呼び出す方法と、OAuth 認証の実装方法について解説します。</div><div class="ui-feed-item__date" title="2025-06-21 04:31:00">7ヶ月前</div></div></div><div class="ui-feed-item"><a 
class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/a2a-protocol-js-sdk"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/a2a-protocol-js-sdk">A2A プロトコルの JavaScript SDK を試してみる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">A2A プロトコルはエージェント間の通信を標準化するためのプロトコルです。JavaScript SDK を使って A2A サーバーとクライアントを実装し、エージェント間通信を試してみます。</div><div class="ui-feed-item__date" title="2025-06-15 02:01:00">7ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/vibe-coding-tutorial-create-app-with-claude-code"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" 
href="https://azukiazusa.dev/blog/vibe-coding-tutorial-create-app-with-claude-code">バイブコーディングチュートリアル：Claude Code でカンバンアプリケーションを作成しよう</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">バイブコーディングとは、AI エージェントを活用して直感的にアプリケーションを開発する新しいコーディングスタイルです。このチュートリアルでは、Claude Code を使って Next.js でカンバンボードアプリケーションを作成します。</div><div class="ui-feed-item__date" title="2025-06-12 10:55:00">7ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/openai-agents-sdk-typescript"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/openai-agents-sdk-typescript">OpenAI Agents の TypeScript SDK</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
OpenAI Agents SDK は AI エージェントを構築するためのパッケージです。軽量で使いやすく、抽象化を最小限に抑えているのが特徴です。この記事では、OpenAI Agents SDK の TypeScript バージョンの使用例を紹介します。</div><div class="ui-feed-item__date" title="2025-06-08 00:18:00">7ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/how-to-standardize-frontend-apps-connecting-to-agents"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/how-to-standardize-frontend-apps-connecting-to-agents">フロントエンドアプリケーションがエージェントに接続する方法を標準化する AG-UI</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">AG-UI はフロントエンドアプリケーションがエージェントに接続する方法を標準化するプロトコルです。この記事では AG-UI を使用してフロントエンドアプリケーションがエージェントに接続する方法を紹介します。</div><div class="ui-feed-item__date" title="2025-06-07 00:45:00">7ヶ月前</div></div></div><div class="ui-feed-item"><a 
class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/4LdKycAFdBPzDkBfCfInVQ"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/4LdKycAFdBPzDkBfCfInVQ">Claude Code のタスクの完了を通知する方法</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">AI を使用してコードの生成を行う際、ある程度の時間待機する必要があります。その間ターミナルに張り付いて観察するのではなく、タスクが完了したタイミングで通知を受け取ることができれば、他の作業をしながら待機することができます。Claude Code でタスクの完了を通知する方法を 3 つ紹介します。</div><div class="ui-feed-item__date" title="2025-06-03 15:00:00">7ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/coding-agents-and-developers-work"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a 
class="ui-feed-item__title" href="https://azukiazusa.dev/blog/coding-agents-and-developers-work">コーディングエージェントの現状の整理とエンジニアの仕事の変化について</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">AI によるコーディングの支援はコード補完型からチャット型、そして自律型へと進化しています。この記事では現時点で主流となっているコーディングエージェントの種類とその特徴を整理したうえで、エンジニアの仕事の変化について考察します。</div><div class="ui-feed-item__date" title="2025-06-01 02:36:00">8ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/claude-code-action-github-integration"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/claude-code-action-github-integration">Claude Code Action で Claude Code を GitHub に統合しよう</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
Claude Code Action は Claude Code を GitHub Actions のワークフローに統合するためのアクションです。これを使用することで、GitHub 上でコードの生成やレビューを AI に依頼することができます。</div><div class="ui-feed-item__date" title="2025-05-25 00:32:00">8ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/mastra-a2a-protocol-support"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/mastra-a2a-protocol-support">Mastra の A2A プロトコルサポート</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Mastra は A2A プロトコルをサポートしています。Mastra サーバーを構築することで A2A プロトコルに準拠したサーバーが立ち上がります。この記事では Mastra を使用して A2A プロトコルに準拠したサーバーを構築し、Mastra のクライアント SDK を使用して A2A プロトコルの仕様に従い通信を行う方法を紹介します。</div><div class="ui-feed-item__date" title="2025-05-24 02:39:00">8ヶ月前</div></div></div><div class="ui-feed-item"><a 
class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/typescript-ai-agent-voltagent"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/typescript-ai-agent-voltagent">TypeScript で AI エージェントを構築する VoltAgent</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">VoltAgent は TypeScript で AI を活用したアプリケーションを構築するためのツールキットです。VoltAgent Console を使用すると、エージェントの状態をリアルタイムで確認したり、エージェントのワークフローを可視化できる点が特徴です。</div><div class="ui-feed-item__date" title="2025-05-18 09:18:00">8ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/react-router-server-components"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a 
class="ui-feed-item__title" href="https://azukiazusa.dev/blog/react-router-server-components">React Router の Server Components 対応</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">React Router はプレビュー版として Server Components に対応しました。これにより loader や actions を使用してデータを返す際にコンポーネント渡したり、Server Components ファーストのサーバーコンポーネントルートを作成できるようになりました。この記事では React Router の Server Components 対応を実際に試してみます。</div><div class="ui-feed-item__date" title="2025-05-18 00:46:00">8ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/vercel-mcp-server"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/vercel-mcp-server">Vercel で MCP サーバーを構築する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
Model Context Protocol (MCP) の 2025-03-26 の仕様では新たに Streamable HTTP が追加され、リモート MCP サーバーへの注目が集まっています。この記事では Next.js を使用して Vercel 上に MCP サーバーを構築する方法を紹介します。</div><div class="ui-feed-item__date" title="2025-05-11 08:50:00">8ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/cloudflare-mcp-server"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/cloudflare-mcp-server">Cloudflare で MCP サーバーを構築する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Model Context Protocol (MCP) の 2025-03-26 の仕様では新たに Streamable HTTP が追加され、リモート MCP サーバーへの注目が集まっています。この記事では `agents` フレームワークを使用して Cloudflare 上に MCP サーバーを構築する方法を紹介します。</div><div class="ui-feed-item__date" title="2025-05-11 03:08:00">8ヶ月前</div></div></div><div class="ui-feed-item"><a 
class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/error-is-error"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/error-is-error">Error インスタンスかどうか判定する Error.isError() メソッド</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Error.isError() メソッドは、オブジェクトが Error インスタンスかどうかを判定するためのメソッドです。今までも instanceof 演算子を使用して判定することができましたが、偽陽性と偽陰性が発生する可能性があります。Error.isError() メソッドは Array.isArray() と同じく内部スロットを使用して判定するため、より堅牢に判定することができます。</div><div class="ui-feed-item__date" title="2025-05-11 01:37:00">8ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/docker-mcp-toolkit"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a 
class="ui-feed-item__title" href="https://azukiazusa.dev/blog/docker-mcp-toolkit">Docker の MCP Toolkit を試してみる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Docker の MCP Toolkit はコンテナ化された MCP サーバーを AI エージェントと統合するための Docker Desktop の拡張機能です。コンテナ化された環境で MCP サーバーを実行することができ、信頼された Docker MCP カタログから MCP ツールを簡単にインストールできる点が特徴です。</div><div class="ui-feed-item__date" title="2025-05-10 01:10:00">8ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/eslint-mcp-server"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/eslint-mcp-server">ESLint を MCP サーバーとして実行する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
ESLint v9.26.0 から MCP サーバーとして実行できるようになりました。この機能により LLM（大規模言語モデル）は ESLint のルールを使用してコードを修正することができるようになります。</div><div class="ui-feed-item__date" title="2025-05-05 01:45:00">8ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/actions-ai-interface-github-actions"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/actions-ai-interface-github-actions">actions/ai-inference を使って GitHub Actions のワークフローから AI モデルを呼び出す</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">actions/ai-inference は GitHub Actions のワークフローから AI モデルを呼び出すための公式のアクションです。これを使用することで CI/CD のワークフローから AI モデルを簡単に利用できるようになります。この記事ではプルリクエスト上で AI に記事のレビューをしてもらうという実践的な使用例を紹介します。</div><div class="ui-feed-item__date" title="2025-05-02 23:27:00">9ヶ月前</div></div></div><div
 class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/react-activity-component"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/react-activity-component">UI の一部を非表示にする React の Activity コンポーネント</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">React の新しい実験的なコンポーネントとして `` が追加されました。これは UI の表示非表示を切り替えるために使用されます。従来の条件付きレンダリングとは異なり、アンマウントされた場合にも状態を保持する点が特徴です。</div><div class="ui-feed-item__date" title="2025-04-27 06:18:00">9ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/ai-talk-what-will-happen-to-engineers"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a 
class="ui-feed-item__title" href="https://azukiazusa.dev/blog/ai-talk-what-will-happen-to-engineers">AIと本音トーク：エンジニアの仕事、これからどうなる？</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">「AI コーディングエージェントの台頭によりエンジニアの働き方はどう変わるのか？」というテーマについて AI と人間のインタビューを通じて探ります。</div><div class="ui-feed-item__date" title="2025-04-26 02:01:00">9ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/ink-cli-app"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/ink-cli-app">Ink を使って CLI アプリを React で書く</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
Ink は CLI アプリを React で書くためのライブラリです。Flexbox レイアウトエンジンである Yoga を使用しているため、Web アプリケーションと同じような CSS を使って UI を構築できることが特徴です。Codex や Claude Code といったコーディングエージェントの CLI アプリが Ink で書かれています。</div><div class="ui-feed-item__date" title="2025-04-20 00:45:00">9ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/mcp-server-streamable-http-transport"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/mcp-server-streamable-http-transport">MCP サーバーの Streamable HTTP transport を試してみる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">MCP では stdio と Streamable HTTP の 2 つの transport が定義されています。TypeScript SDK では v1.10.0 から Streamable HTTP transport がリリースされました。この記事では MCP サーバーを構築し、Streamable HTTP transport を試してみます。</div><div 
class="ui-feed-item__date" title="2025-04-19 00:29:00">9ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/ai-a2a-protocol"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/ai-a2a-protocol">AI エージェントの連携を標準化する A2A プロトコルを試してみる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">AI エージェント同士の連携を標準化するために Agent2Agent プロトコル（A2A）を発表しました。A2A プロトコルは基盤となるフレームワークやベンダーに依存せず、エージェント同士が安全な方法で相互に通信できるように設計されています。この記事ではサンプルコードを通じて A2A プロトコルを使用した AI エージェントの連携を体験してみます。</div><div class="ui-feed-item__date" title="2025-04-11 22:50:00">9ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/build-your-own-coding-ai-agent"><img src="../../images/alternate-feed-image.png" 
alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/build-your-own-coding-ai-agent">コーディング AI エージェントを自作してみよう</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">好むと好まずと関わらず、ソフトウェア開発において AI の活用は重要なパラダイムシフトの 1 つです。AI エージェントはユーザーからの指示を元に自律的にタスクを選択し、実行します。この記事では、コーディング AI エージェントを自作する過程を紹介します。</div><div class="ui-feed-item__date" title="2025-04-05 00:31:00">9ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/vercel-ai-sdk-mcp-client"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/vercel-ai-sdk-mcp-client">Vercel AI SDK で MCP クライアントをツールとして利用する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div>
<div class="ui-feed-item__summary">MCP（Model Context Protocol）は LLM に追加のコンテキストを提供するための標準化されたプロトコルです。Vercel AI SDK は v4.2 から MCP をサポートしており、MCP クライアントをツールとして利用できます。この記事では Vercel AI SDK を使って MCP ツールを使用する方法を紹介します。</div><div class="ui-feed-item__date" title="2025-03-30 01:22:00">10ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/css-only-carousel"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/css-only-carousel">::scroll-button と ::scroll-marker を使って CSS だけでカルーセルを作る</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
カルーセルは Web アプリケーションでよく使われる UI コンポーネントの一つであるものの、標準化された実装方法が存在しないため、各ライブラリやフレームワークで独自の実装が行われています。この問題を解決するため、CSS だけを使用してカルーセルを実装するための新しい仕様が提案されています。:この仕様では ::scroll-button と ::scroll-marker 擬似要素を使用してカルーセルを実装します。</div><div class="ui-feed-item__date" title="2025-03-22 01:47:00">10ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/vercel-ai-sdk-nextjs"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/vercel-ai-sdk-nextjs">Vercel AI SDK を使って Next.js アプリに AI 機能を追加する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
Vercel AI SDK は TypeScript 向けの AI 機能を活用するプロダクトを構築するためのツールです。AI SDK は AI モデルのプロバイダー間における API の違いを抽象化することで、開発者はアプリケーションの開発に集中できるようになります。この記事では Vercel AI SDK の使い方を確認し、最終的に Next.js で構築した Web アプリケーションに AI 機能を追加する方法を紹介します。</div><div class="ui-feed-item__date" title="2025-03-16 11:29:00">10ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/typescript-mcp-server"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/typescript-mcp-server">TypeScript で MCP サーバーを実装し、Claude Desktop から利用する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
MCP（Model Context Protocol）とはアプリケーションが LLM にコンテキストを提供する方法を標準化するプロトコルです。MCP を使用することで、LLM は外部ツールやサービスからコンテキストを取得するだけでなく、コードの実行やデータの保存など、さまざまなアクションを実行できるようになります。この記事では MCP サーバーを TypeScript で実装する方法を紹介します。</div><div class="ui-feed-item__date" title="2025-03-14 10:59:00">10ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/typescript-ai-agent-framework-mastra"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/typescript-ai-agent-framework-mastra">TypeScript 製の AI エージェントフレームワーク Mastra</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Mastra は TypeScript 製の AI エージェントフレームワークであり Gatsby の開発チームによって開発されています。Mastra サーバーを実行することで REST API サーバーを介してエージェントとやり取りすることができます。Mastra はAI エージェントを構築するために必要なプリミティブな機能を提供するために設計されています。</div><div
 class="ui-feed-item__date" title="2025-03-09 01:16:00">10ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/llms-txt"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/llms-txt">ブログで llms.txt を提供してみた</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">従来のウェブサイトは人間用のマークアップが主であり、bot が情報を収集するために無駄な情報が多く含まれています。一方でウェブサイトを提供する側にとっても AI エージェントにより過剰なスクレイピングによりサーバーの負荷がかかることが問題となっています。LLM に適したコンテンツを提供するために Answer.AI の共同創業者である Jeremy Howard 氏により `llms.txt` というファイルが提案されました。</div><div class="ui-feed-item__date" title="2025-03-08 02:04:00">10ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/inline-conditional-css-if-function"><img 
src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/inline-conditional-css-if-function">インラインで条件分岐する CSS の if() 関数</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">if() 関数は CSS Values and Units Module Level 5 という仕様で提案されている関数です。if() 関数は CSS でインラインの条件分岐を可能にします。</div><div class="ui-feed-item__date" title="2025-03-01 06:41:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/observable-api-for-handling-asynchronous-event-streams-in-the-browser"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/observable-api-for-handling-asynchronous-event-streams-in-the-browser">
ブラウザで非同期イベントストリームを処理する Observable API</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Observable API は非同期イベントストリームを処理するための API です。 EventTarget に .when() メソッドを追加し addEventListener() よりも宣言的で優れたイベントハンドリングを提供します。</div><div class="ui-feed-item__date" title="2025-02-22 09:39:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/require-baseline-eslint-rule-to-validate-css-not-widely-supported-in-browsers"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/require-baseline-eslint-rule-to-validate-css-not-widely-supported-in-browsers">ブラウザに広くサポートされていない CSS を検証する require-baseline ESLint ルール</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
Baseline はブラウザで利用可能な JavaScript や CSS のサポート状況を明確化するプロジェクトです。ESLint/CSS の require-baseline ルールを使用することで、Baseline でサポートされていない CSS プロパティや値を検出することができます。</div><div class="ui-feed-item__date" title="2025-02-22 08:27:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/upgraded-css-attr-function"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/upgraded-css-attr-function">アップグレードされた CSS の `attr()` 関数を使う</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">`attr()` 関数は HTML の属性を読み取り、それを CSS で利用できるようにする関数です。従来までは `content` プロパティのみで使用できましたが、CSS Values and Units Module Level 5 ではこの制限が見直され、`attr()` 関数がカスタムプロパティを含む任意の CSS プロパティで使用できるようになりました。</div><div class="ui-feed-item__date" title="2025-02-22 08:00:00">1年前</div></div></div>
<div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/proposal-press-button"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/proposal-press-button">ボタンが押し込まれた状態を表す Press Button の提案</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">UI デザインにおいてボタンが「押し込まれた」状態を表現することはしばしばあります。しかし、ネイティブの HTML 要素では表現できず `aria-pressed` 属性を使用する必要がありました。Press Button Proposal では `type=&quot;press&quot;` 属性を追加することでボタンが押し込まれた状態を表現することが提案されています。</div><div class="ui-feed-item__date" title="2025-02-22 07:47:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/deno-v2-2-opentelemetry"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div 
class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/deno-v2-2-opentelemetry">Deno v2.2 で追加されたビルドイン OpenTelemetry サポートを試してみる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Deno v2.2 でビルドインの OpenTelemetry サポートが追加されました。アプリケーションのコードに変更を加えることなく、Deno のビルトイン API から自動的にテレメトリーデータを計装できるようになります。</div><div class="ui-feed-item__date" title="2025-02-22 06:42:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/prisma-opentelemetry-trace"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/prisma-opentelemetry-trace">Prisma で OpenTelemetry のトレースデータを計装する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
Prisma は OpenTelemetry の仕様に準拠したトレースデータを計装するためのパッケージを提供しています。この記事では、Prisma で OpenTelemetry のトレースデータを計装する方法について紹介します。</div><div class="ui-feed-item__date" title="2025-02-21 11:14:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/3dFzPfbB3nnbqPzTqnjPRV"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/3dFzPfbB3nnbqPzTqnjPRV">Vitest で型のテストを書く</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Vitest では `expectTypeOf` や `assetType` を使って型のテストを書くことができます。自作のユーティリティ型が期待する型を返すか検査したり、言語ファイルの JSON スキーマが同じ型を返すことを確認するなどに利用できます。</div><div class="ui-feed-item__date" title="2025-02-19 15:00:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" 
href="https://azukiazusa.dev/blog/schema-validation-library-standard-interface-standard-schema"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/schema-validation-library-standard-interface-standard-schema">スキーマバリデーションライブラリの標準インターフェース standard-schema</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">スキーマバリデーションライブラリはここ数年で人気を集めています。多くのライブラリが登場する中で、standard-schema はスキーマバリデーションライブラリの標準インターフェースを提供します。これにより、エコシステムツールがユーザー定義の型検証ツールをより簡単に受け入れられるようにすることを目指しています。</div><div class="ui-feed-item__date" title="2025-02-15 01:03:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/34rVQfZ80z5Naegm2PUyEr"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div 
class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/34rVQfZ80z5Naegm2PUyEr">CSS で関数を定義できるようになる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Chrome Canary で CSS 関数のプロトタイプが実装されました。CSS Functions and Mixins Module という仕様に基づいて実装されており、`@function` ルールを使用して開発者が関数を定義できるようになります。</div><div class="ui-feed-item__date" title="2025-02-08 15:00:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/implement-path-key-in-browser"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/implement-path-key-in-browser">パスキーによる認証をブラウザで実装してみる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
パスキーとはパスワードに代わる認証方法で、生体認証やデバイス PIN を使ってログインができる仕組みです。ユーザーはパスワードを覚える必要がなく、またフィッシング攻撃にも強いという点からよりセキュア認証方法として注目を集めています。この記事では WebAuthn を使ってパスキーをブラウザで実装する方法を紹介します。</div><div class="ui-feed-item__date" title="2025-02-08 01:13:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/react-server"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/react-server">React Server Components を手軽に扱うフレームワーク react-server</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">react-server は Node.js で JavaScript ファイルを実行するかのように React Server Components を扱うことを目的としたフレームワークです。Next.js の機能が過剰に感じられるような小さなアプリケーションを開発する際に有用です。</div><div class="ui-feed-item__date" title="2025-02-01 01:57:00">1年前</div></div></div><div class="ui-feed-item"><a 
class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/1eezsoj4N31abTOpvD9fag"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/1eezsoj4N31abTOpvD9fag">Bun v1.2 では package.json にコメントを書ける</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">`package.json` は JSON フォーマットのファイルであるため、コメントを書くことができません。`package.json` に定義したスクリプトの説明を書いておくことは重要です。別のファイルに説明を書いたり、`//` で始まるキーを使用してコメントを書くハックが生まれるなど、様々な方法が考案されていたのが思い出されます。</div><div class="ui-feed-item__date" title="2025-01-31 15:00:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/HTNCfn46WT831quJrV2aJ"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content">
<a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/HTNCfn46WT831quJrV2aJ">TypeScript 5.8 で追加される erasableSyntaxOnly フラグ</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">TypeScript 5.8 で `erasableSyntaxOnly` フラグが追加される予定です。このフラグは `enum` や `namespace`、`Class Parameter properties` などの「消去可能ではない」構文をエラーとして検知するためのものです。</div><div class="ui-feed-item__date" title="2025-01-27 15:00:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/type-safe-query-string-parameters-with-nuqs"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/type-safe-query-string-parameters-with-nuqs">型安全にクエリパラメーターを扱う nuqs</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
フロントエンドの状態管理のパターンとしてクエリパラメータを信頼できる唯一の情報源(single source of truth)として扱うことがあります。ですが、クエリパラメーターの型が文字列であるため、型安全性が保証されないという課題があります。この記事では `nuqs` というライブラリを使用してクエリパラメーターを型安全に扱う方法について解説します。</div><div class="ui-feed-item__date" title="2025-01-25 01:33:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/dialog-closedby-attribute-for-light-dismiss"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/dialog-closedby-attribute-for-light-dismiss">ダイアログの Light dismiss を有効にする `&lt;dialog closedby&gt;` 属性</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">`` 属性はダイアログの外側をクリックした際にダイアログを閉じる Light dismiss 機能を実現するための属性です。closedby 属性は `any`, `closerequest`, `none` の 3 つの値を受け付けます。</div><div class="ui-feed-item__date" 
title="2025-01-21 09:04:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/declarative-page-transition-animation-with-react-viewtransition-component"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/declarative-page-transition-animation-with-react-viewtransition-component">React の `&lt;ViewTransition&gt;` コンポーネントで宣言的にページ遷移アニメーションを追加する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">`` コンポーネントは React の実験的なバージョンとして導入されました。これは View Transition API を 宣言的な方法で使用できるようにするものです。</div><div class="ui-feed-item__date" title="2025-01-19 03:50:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" 
href="https://azukiazusa.dev/blog/view-transition-css-at-rule-for-page-transition-animation-in-mpa"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/view-transition-css-at-rule-for-page-transition-animation-in-mpa">MPA でページ遷移アニメーションを行う `@view-transition` CSS アットルール</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">View Transition API はページを遷移する際に簡単にアニメーションを追加できる API です。SPA では `document.startViewTransition()` メソッドを DOM が変更される前に呼び出すことでページ遷移アニメーションを追加できます。MPA の場合 CSS アットルール `@view-transition` を使用できます。SPA の場合と異なり、JavaScript を使用せずに CSS だけでアニメーションを追加できる点が特徴です。</div><div class="ui-feed-item__date" title="2025-01-18 13:47:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" 
href="https://azukiazusa.dev/blog/scroll-state-function-to-show-border-when-sticky"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/scroll-state-function-to-show-border-when-sticky">scroll-state() CSS コンテナクエリを使用して sticky で張り付いたときに境界線を出す</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">scroll-state() はコンテナ要素のスクロール状態に応じてスタイルを変更することができるコンテナクエリです。例えば、スクロール中にヘッダーを sticky な場合の境界線を表示することが挙げられます。</div><div class="ui-feed-item__date" title="2025-01-18 10:59:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/popover-hint-attribute"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" 
href="https://azukiazusa.dev/blog/popover-hint-attribute">ユーザーにヒントを表示するための `popover=hint` 属性</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">ポップオーバー API は 2024 年の Baseline に組み込まれており、主要なブラウザでサポートされています。Chrome Beta 133 では 3 番目の値として `hint` が追加されました。`popover=hint` はユーザーに対してヒントを表示する「ツールチップ」として動作します。この記事では `popover=hint` 属性について詳しく見ていきます。</div><div class="ui-feed-item__date" title="2025-01-18 03:25:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/6Dpm3KfJdorewgzFu8kvv4"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/6Dpm3KfJdorewgzFu8kvv4">Node.js で TypeScript を直接実行できるようになった</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
Node.js v23.6.0 から `--experimental-strip-types` フラグがデフォルトで有効になりました。これにより、Node.js でTypeScript を直接実行できるようになります。</div><div class="ui-feed-item__date" title="2025-01-11 15:00:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/try-ai-editor-cursor"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/try-ai-editor-cursor">AI エディター Cursor を試してみる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">AI エディター Cursor は GitHub Copilot と同様にコードの補完やチャットによるコードの生成をサポートしてくれます。Cursor は VS Code をフォークして作られており、既存の VS Code の拡張機能やキーバインドをそのまま利用することも特徴の 1 つです。</div><div class="ui-feed-item__date" title="2025-01-11 03:04:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" 
href="https://azukiazusa.dev/blog/github-actions-reusable-workflow"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/github-actions-reusable-workflow">GitHub Actions で再利用可能なワークフローを作成する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">GitHub Actions で CI/CD 環境を構築する際に、同じような処理を複数のファイルで記述するようなことがよくあります。この記事では、GitHub Actions で再利用可能なワークフローを作成する方法と、実際に再利用可能なワークフローを作成する手順を紹介します。</div><div class="ui-feed-item__date" title="2025-01-04 02:30:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/books-read-in-2024"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" 
href="https://azukiazusa.dev/blog/books-read-in-2024">2024 年に読んでよかった本</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">私は今年 1 年間でおおよそ 300 冊の本を読んだようです。その中から、特に印象に残った本をいくつか紹介します。</div><div class="ui-feed-item__date" title="2024-12-28 11:59:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/link-area-delegation-proposal"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/link-area-delegation-proposal">カード UI の入れ子のリンクの問題を解決する Link Area Delegation の提案</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
多くのウェブサイトではリンクを入れ子にしたカード UI が利用されています。しかし、このような UI では HTML 仕様に違反していたり、ハッキーな手法で実装されていることがあります。Open UI コミュニティでは Link Area Delegation という提案を行っており、標準化された方法で入れ子のリンクを実装することで UX やアクセシビリティを損なうことを防ぐことを目的としています。この記事では Link Area Delegation の内容について紹介します。</div><div class="ui-feed-item__date" title="2024-12-21 01:30:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/msw-mock-web-socket-request"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/msw-mock-web-socket-request">MSW で Web Socket のリクエストをモックする</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
Mock Service Worker (MSW) の v2.6.0 から Web Socket のリクエストをモックすることができるようになりました。Web Socket のサポートのリクエストは 2020 年から存在しており、多くの議論の末 4 年の歳月を経てリリースされた機能となります。この記事では、MSW で Web Socket のリクエストをモックする方法を紹介します。</div><div class="ui-feed-item__date" title="2024-12-14 01:52:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/239ZgsDWxE249fBsJVCrje"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/239ZgsDWxE249fBsJVCrje">Testing Library の debug で出力される行数を多くする方法</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Testing Library では要素の取得に失敗した場合にレンダリングされた HTML がコンソールに表示されます。しかし、デフォルトで出力される行は 7000 に制限されているため目的の要素が表示される前に表示が終了してしまうことがしばしばあります。</div><div class="ui-feed-item__date" title="2024-12-11 15:00:00">1年前</div></div>
</div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/zod-openai-structured-output"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/zod-openai-structured-output">Zod を使って OpenAI の構造化された出力を扱う</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">OpenAI の gpt-4o-2024-08-06 以降のモデルではパラメータとして JSON Schema を指定することで構造化された出力をサポートしています。Node.js 向けの OpenAI SDK では Zod を使ってスキーマを定義し、構造化された出力を扱うことができます。この記事では実際に Zod を使って OpenAI の構造化された出力を扱う方法を紹介します。</div><div class="ui-feed-item__date" title="2024-12-07 01:49:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/tailwind-css-v4-css-first-configurations"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" 
width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/tailwind-css-v4-css-first-configurations">Tailwind CSS v4 で導入される CSS First Configurations</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Tailwind CSS v4 における最も大きな変更点の 1 つは、CSS First Configurations です。今まで `tailwind.config.js` で設定していたテーマなどの設定を CSS ファイル内で行うことができるようになります。</div><div class="ui-feed-item__date" title="2024-11-30 02:21:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/playwright-aria-snapshot"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/playwright-aria-snapshot">アクセシビリティツリーを比較する Playwright の Aria snapshots がよさそう</a><div class="ui-feed-item__blog-title">
azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Playwright の Aria snapshots はアクセシビリティツリーを比較することでテストする手法です。アクセシビリティツリーは DOM のスナップショットテストと比較して、外部から見た振る舞いが変わりづらいという利点があります。`.toMatchAriaSnapshot()` メソッドを使ってアクセシビリティツリーのスナップショットテストを行うことができます。</div><div class="ui-feed-item__date" title="2024-11-24 00:23:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/5fGDdRNfZNvgS1iAURPEXe"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/5fGDdRNfZNvgS1iAURPEXe">Node.js では標準モジュールで Promise timer が使える</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">人為的な遅延を発生させるために、`setTimeout` を Promise をラップする方法がよく使われています。これにより、`await` を使って任意の秒数処理を遅らせることができます。</div><div class="ui-feed-item__date" 
title="2024-11-16 15:00:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/new-package-manager-vlt"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/new-package-manager-vlt">新しいパッケージマネージャーの vlt を使ってみる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">vlt は npm と互換性のあるパッケージマネージャーです。`npm` と同じように、パッケージのインストールや script の実行ができます。また、npm registry 互換のサーバーレジストリである vsr も同時に提供されています。</div><div class="ui-feed-item__date" title="2024-11-16 06:36:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/instrumentation-with-opentelemetry-in-nextjs"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div 
class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/instrumentation-with-opentelemetry-in-nextjs">Next.js で OpenTelemetry を使用した計装を行う</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">この記事では Next.js で OpenTelemetry を使用した計装を行う方法について紹介します。Next.js では `instrumentation.ts` ファイルを使用して監視ツールやログツールの計装を設定できます。</div><div class="ui-feed-item__date" title="2024-11-10 08:53:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/cache-control-with-use-cache-directive-in-nextjs"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/cache-control-with-use-cache-directive-in-nextjs">Next.js の &quot;use cache&quot; ディレクティブによるキャッシュ制御</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2
</div><div class="ui-feed-item__summary">Next.js の App Router はデフォルトでキャッシュされる設計でリリースされました。一方でデフォルトでキャッシュされることに対して不満を持つ開発者も多かったように思います。このようなフィードバックを受けて、Next.js 15 ではいくつかのキャッシュ戦略が変更されました。さらに現在 canary チャンネルで提供されている dynamicIO フラグを有効にすることで、&quot;use cache&quot; ディレクティブを用いてキャッシュを制御できるようになります。</div><div class="ui-feed-item__date" title="2024-11-02 05:07:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/cssstylesheet-to-build-stylesheets-in-javascript"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/cssstylesheet-to-build-stylesheets-in-javascript">JavaScript でスタイルシートを構築する CSSStyleSheet</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
CSSStyleSheet インターフェースは、JavaScript でスタイルシートを構築し、操作するための API です。CSSStyleSheet() コンストラクターで新しいスタイルシートを作成し、.replaceSync() メソッドでスタイルを適用できます。</div><div class="ui-feed-item__date" title="2024-10-26 02:59:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/react-to-web-component"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/react-to-web-component">react-to-web-component を使って React コンポーネントを Web Components に変換する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">@r2wc/react-to-web-component は React コンポーネントを Web Components に変換するためのライブラリです。このライブラリを使用することで、React コンポーネントを任意の HTML 要素として使用することが可能になります。</div><div class="ui-feed-item__date" title="2024-10-20 12:06:00">1年前</div></div></div><div class="ui-feed-item"><a 
class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/declarative-shadow-dom"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/declarative-shadow-dom">HTML だけで Shadow DOM を構築するための宣言型 Shadow DOM</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">宣言型 Shadow DOM は `` 要素を使用して Shadow DOM を構築する方法です。宣言型 Shadow DOM を使用することで、従来の JavaScript を使用した Shadow DOM の構築方法と比較して、サーバーサイドレンダリング（SSR）に対応しているため、パフォーマンスの向上や SEO 対策に期待されます。</div><div class="ui-feed-item__date" title="2024-10-19 06:45:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/chrome-internal-ai-language-detection-api"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div 
class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/chrome-internal-ai-language-detection-api">Chrome の組み込み AI の Language Detection API で言語を判定する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Language Detection API は Chrome に組み込まれた AI により、クライアントサイドで言語を判定するための提案です。この API を利用することで、テキストの言語を判定することが可能になります。</div><div class="ui-feed-item__date" title="2024-10-14 07:58:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/try-chrome-internal-ai-summarization-api"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/try-chrome-internal-ai-summarization-api">Chrome の組み込み AI の Summarization API を試してみる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div 
class="ui-feed-item__summary">Google では大規模言語モデル（LLM）などの AI モデルをブラウザに直接統合するように設計された、Web プラットフォーム API とブラウザ機能を開発しています。これには Gimini Nano という AI モデルが含まれており、デスクトップパソコンにおいてローカルで実行されるように設計されています。この記事では Summarization API を使用して、文章を要約してみます。</div><div class="ui-feed-item__date" title="2024-10-13 04:27:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/storybook-and-vitest-integration"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/storybook-and-vitest-integration">Storybook と Vitest の統合したコンポーネントテスト</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Storybook v8.3 以降、ストーリーをテストするためのテストランナーとして Vitest を使用できるようになりました。Vitest を使用することで複雑なセットアップが不要になります。また、推奨されているブラウザモードを使用することで、実際のブラウザでの挙動をより正確に再現できます。</div><div 
class="ui-feed-item__date" title="2024-10-06 06:39:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/close-watcher-api"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/close-watcher-api">UI を閉じる動作を処理する CloseWatcher API</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">CloseWatcher API は UI を閉じる動作を処理するための API です。キーボードの `Esc` キー、Android の戻るボタンなどのデバイス固有のメカニズムによって閉じるイベントを提供します。</div><div class="ui-feed-item__date" title="2024-09-28 06:08:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/2fo3q3hxoB0bSvZBDghtCM"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div 
class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/2fo3q3hxoB0bSvZBDghtCM">ユーザーのカラースキーマ設定を上書きする web preferences API の提案</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">ユーザーのカラーテーマの設定によりスタイルを変更するためには、`prefers-color-scheme` メディアクエリを使用することが一般的です。しかし、多くのウェブサイトでは OS の設定とは独立してカラースキーマを設定する機能が提供されています。この場合、`prefers-color-scheme` メディアクエリを使用せずに、`class` 属性を使ったスタイルの切り替えが行われます。</div><div class="ui-feed-item__date" title="2024-09-21 15:00:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/customizable-select-element"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/customizable-select-element">スタイルをカスタマイズ可能な新しい `&lt;select&gt;` 要素</a><div class="ui-feed-item__blog-title">
azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">従来の `` 要素は CSS を利用したスタイルを適用することができないため、多くの開発者にとって課題となっていました。この問題を解決するために新しい既存の `` 要素をカスタマイズする手段が提案されました。この疑似要素を利用することで、開発者は `` 要素のスタイルをカスタマイズをオプトインできるようになります。</div><div class="ui-feed-item__date" title="2024-09-21 02:59:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/calc-size-animation"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/calc-size-animation">`calc-size()` や `interpolate-size: allow-keywords;` で `height: auto;` な要素のアニメーションをサポートする</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">CSS において height プロパティを 0 から auto に変化させた場合に、アニメーションが適用されないのはよく知られた問題です。この記事では calc-size() 関数を使って height: auto; な要素のアニメーションを実装する方法を紹介します。</div><div 
class="ui-feed-item__date" title="2024-09-14 06:06:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/react-aria-drag-and-drop"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/react-aria-drag-and-drop">アクセシビリティが考慮された React Aria のドラッグアンドドロップ</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">React Aria は Adobe により提供されている React 用のコンポーネントライブラリであり、アクセシビリティを最優先した設計となっています。本記事では、React Aria により提供されているドラッグアンドドロップ機能を紹介します。</div><div class="ui-feed-item__date" title="2024-09-07 06:17:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/openfeature-react-sdk"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" 
height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/openfeature-react-sdk">フィーチャーフラグの標準規格 OpenFeature の React SDK を試してみる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">OpenFeature はフィーチャーフラグのオープンな規格です。特定のベンダーに依存しない API や SDK が提供されています。フィーチャーフラグの API の標準化により、ベンダーロックインを回避し、フィーチャーフラグのツールを自由に選択できるようになります。この記事では OpenFeature の React SDK を使ってフィーチャーフラグを評価する方法を紹介します。</div><div class="ui-feed-item__date" title="2024-08-31 07:56:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/react-aria-accessible-component"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/react-aria-accessible-component">React Aria でアクセシブルなコンポーネントを作成する</a><div 
class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">React Aria は Adobe が提供する React 用のコンポーネントライブラリです。スタイルを持たずに UI の機能やロジックのみを提供するいわゆるヘッドレス UI ライブラリであり、特に React Aria はアクセシビリティを最優先した設計となっているのが特徴です。ヘッドレス UI ライブラリを用いて UI コンポーネントを実装することで、開発者はビジネスロジックやデザインに集中することができます。</div><div class="ui-feed-item__date" title="2024-08-25 06:34:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/axe-core-playwright"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/axe-core-playwright">@axe-core/playwright によるアクセシビリティテストの自動化</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
axe-core は axe というアクセシビリティテストツールのコアエンジンで、オープンソースとして提供されています。この記事では、E2E テストフレームワークの Playwright と axe-core を組み合わせて使用して、アクセシビリティテストを自動化する方法について紹介します。</div><div class="ui-feed-item__date" title="2024-08-18 03:53:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/box-shadow-focus-ring-not-visible-in-high-contrast-mode"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/box-shadow-focus-ring-not-visible-in-high-contrast-mode">box-shadow で実装されたフォーカスリングはハイコントラストモードで表示されない</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">フォーカスリングとは、キーボード操作でフォーカスが当たった要素を視覚的に示すための UI デザインのことです。フォーカスリングのカスタマイズに `box-shadow` プロパティを使うことがありますが、ハイコントラストモードではフォーカスリングが表示されない問題があります。この記事では、ハイコントラストモードでフォーカスリングを表示する方法について解説します。</div><div 
class="ui-feed-item__date" title="2024-08-11 05:42:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/css-reading-flow-property"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/css-reading-flow-property">CSS の `reading-flow` プロパティで要素の読み上げ順を制御する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Flex や Grid コンテナ内では要素の見た目上の順序と DOM 上の順序が異なることがあります。このような状態はキーボード操作やスクリーンリーダーなどの支援技術を使うユーザーにとって混乱を招く可能性があります。CSS の `reading-flow` プロパティ個の問題を解決するためのプロパティです。見た目上の順序に従って読み上げ順を制御することができます。</div><div class="ui-feed-item__date" title="2024-08-03 06:33:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/css-random-function"><img 
src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/css-random-function">CSS でランダムな値を扱う `random()` と `random-item()` 関数</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">`random()` と `random-item()` 関数は CSS でランダムな値を扱うための関数です。`random()` 関数は最小値と最大値を引数に取り、その範囲内のランダムな数値を返します。`random-item()` 関数は引数に渡したリストの中からランダムに 1 つの値を返します。</div><div class="ui-feed-item__date" title="2024-07-28 08:06:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/new-build-tool-farm"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/new-build-tool-farm">新しいビルドツールの Farm</a><div 
class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Farm は Rust 製の新しいビルドツールです。パフォーマンスを重視して設計されており、Vite と互換性のある JavaScript プラグインをサポートしているという特徴があります。バンドルの戦略には Partial Bundling というものを採用しており、モジュールのネットワークリクエスト数を削減するため、20 ~ 30 のファイルにバンドルするという特徴があります。</div><div class="ui-feed-item__date" title="2024-07-21 06:44:00">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/define-custom-properties-with-css-property-rule"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/define-custom-properties-with-css-property-rule">CSS の `@property` ルールでカスタムプロパティを定義する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
CSS の @property ルールを使うことで、CSS のカスタムプロパティを定義できます。カスタムプロパティを定義することでプロパティの構文チェック、デフォルト値の設定、プロパティが値を継承するかどうかの設定などが可能になります。カスタムプロパティに誤った値が代入されることを防いだり、グラデーションのアニメーションなど、従来は実装が難しかった機能をサポートすることができます。</div><div class="ui-feed-item__date" title="2024-07-13 07:16:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/scope-rule-in-css"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/scope-rule-in-css">スタイルの適用範囲を限定する CSS の `@scope` ルール</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">`@scope` アットルールは特定のセレクタの範囲に限定したスタイルを適用するためのルールです。`@scope` のルールセットに 1 つの CSS セレクタを指定すると、そのセレクタがスコープのルートとなります。`@scope` ルール内のスタイルはそのセレクタの範囲内でのみ適用されます。</div><div class="ui-feed-item__date" title="2024-07-07 07:46:00">2年前</div></div></div><div 
class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/manage-styles-structurally-with-css-cascade-layer"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/manage-styles-structurally-with-css-cascade-layer">CSS のカスケードレイヤー `@layer` を使ってスタイルを階層化して管理する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">CSS の `@layer` ルールは、カスケードレイヤーを宣言するために使用されます。カスケードレイヤーとは、スタイルの優先度をレイヤー（階層）に分けて管理する仕組みです。`@layer` ルールを使用することでスタイルの記述順や詳細度に関係なくスタイルを宣言できるため、新しい形式の CSS 設計を実現することができます。</div><div class="ui-feed-item__date" title="2024-06-30 07:47:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/1I2o5hV41vUHNH8mMXWN9h"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" 
loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/1I2o5hV41vUHNH8mMXWN9h">TypeScript で配列の要素を取得する時 `.at()` メソッドを使うとより安全</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">JavaScript で配列にアクセスする際、配列の長さを超えるインデックスを指定すると `undefined` が返されることがあります。しかし、TypeScript の型定義上では、配列の長さを超えるインデックスを指定しても `undefined` 型が返されることはありません。これはランタイムエラーを引き起こす恐れがあります。</div><div class="ui-feed-item__date" title="2024-06-24 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/when-else-rule-in-css"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/when-else-rule-in-css">CSS で条件分岐を行う `@when/@else` ルール</a><div class="ui-feed-item__blog-title">
azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">`@when/@else` アットルールは条件付きスタイルをまとめて記述するためのルールです。`@media` や `@support` の条件を `@when` にわたすことで、`true` の場合には `@when` ブロック内のスタイルが、`false` の場合には `@else` ブロック内のスタイルが適用されます。このルールを使うことでより簡潔なコードを書くことができます。</div><div class="ui-feed-item__date" title="2024-06-22 06:36:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/use-mask-image-css-property-to-display-svg-icons"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/use-mask-image-css-property-to-display-svg-icons">SVG アイコンの表示に mask-image CSS プロパティを使用する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
mask-image プロパティは CSS でマスキングを行うためのプロパティであり、SVG アイコンを表示する際に有用です。mask-image プロパティを使用することで、外部の SVG ファイルを読み込みつつ、アイコンの色を CSS で指定することが可能になります。</div><div class="ui-feed-item__date" title="2024-06-15 06:35:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/try-chrome-internal-ai-gemini-nano"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/try-chrome-internal-ai-gemini-nano">Chrome の 組み込み AI Gemini Nano を試してみる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Chrome 126 から Gemini Nano という AI がデスクトップクライアントに組み込まれる予定です。Gemini Nano は Google の AI モデルの中で最も小さいモデルです。デスクトップクライアントに直接組み込まれることで、ユーザーの手元の環境で AI を利用できることが特徴です。開発者は JavaScript から Chrome に組み込まれた Gemini Nano にアクセスして生成 AI の機能を実装することができます。</div><div 
class="ui-feed-item__date" title="2024-06-11 10:19:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/starting-style-rule-for-css-transitions"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/starting-style-rule-for-css-transitions">CSS トランジションの開始時のスタイルを定義する `@starting-style` ルール</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">`@starting-style` ルールは、CSS トランジションの開始時のスタイルを定義するためのアットルールです。CSS トランジションの既定のルールでは前回のスタイル変更イベントでレンダリングされていなかった要素では、アニメーションが適用されない、`display: none` から他の値に変更した場合にアニメーションが適用されないといった問題があります。`@starting-style` ルールを使用することでこれらの問題を解決できます。</div><div class="ui-feed-item__date" title="2024-06-09 06:22:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" 
href="https://azukiazusa.dev/blog/scrollbar-gutter-css-property-to-prevent-screen-jitter-due-to-scroll-bar-switching"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/scrollbar-gutter-css-property-to-prevent-screen-jitter-due-to-scroll-bar-switching">scrollbar-gutter CSS プロパティでスクロールバーの切り替わりによる画面のガタツキを解消する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">子要素が親要素のボックスからはみ出した時、overflow プロパティの値が auto または scroll の場合にスクロールバーが表示されます。スクロールバーがクラシックスクロールバーの場合、スクロールバーの表示・非表示によりボックスの幅が変わるため、画面がガタつくことがあります。scrollbar-gutter プロパティを使うとスクロールバー用のスペースをあらかじめ確保でき、画面のガタツキを解消できます。</div><div class="ui-feed-item__date" title="2024-06-01 06:30:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/sveltekit-tutorial-create-a-blog-site">
<img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/sveltekit-tutorial-create-a-blog-site">SvelteKit チュートリアル - 記事投稿サイトを作ってみよう</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">SvelteKit は Svelte と Vite で構築たフレームワークです。SvelteKit は Web アプリケーションを開発するために必要な機能を提供します。この記事では、SvelteKit を使用して記事投稿サイトを作成するチュートリアルを紹介します。記事投稿サイトは、記事の一覧表示、記事の詳細表示、記事の投稿、記事の削除の機能を持つシンプルな Web アプリケーションです。</div><div class="ui-feed-item__date" title="2024-05-26 05:28:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/svelte-v5-snippet-feature"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" 
href="https://azukiazusa.dev/blog/svelte-v5-snippet-feature">Svelte v5 で導入されるスニペット機能</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Svelte v5 ではスニペットと呼ばれる新しい機能が導入されます。スニペットとは、コンポーネント内で使用できる再利用可能なマークアップのことです。`#snippet` ディレクティブを使用してスニペットを定義し、引数を受け取ることができます。スニペットを呼び出す際には `@render` ディレクティブを使用します。またスニペットは単なる値として扱われるため、コンポーネントの Props として渡すことができます。</div><div class="ui-feed-item__date" title="2024-05-19 04:36:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/react-use-optimistic-hook"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/react-use-optimistic-hook">楽観的更新を行うための React の useOptimistic フック</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
React v19 では楽観的更新を行うための `useOptimistic` フックが導入される予定です。楽観的更新とは、ユーザーの操作に対して非同期処理の完了を待たずに UI を更新する手法のことです。楽観的更新によりユーザーの操作に対して即座にフィードバックを提供できるため、UX の向上につながります。</div><div class="ui-feed-item__date" title="2024-05-12 04:43:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/svelte-v5-event-handlers"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/svelte-v5-event-handlers">Svelte v5 における イベントハンドラの変更点</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Svelte v5 では、イベントハンドラの書き方が一新され、いくつか非推奨となった書き方があります。この記事では、Svelte v4 と Svelte v5 のイベントハンドラの書き方の違いについて見ていきます。</div><div class="ui-feed-item__date" title="2024-05-05 06:15:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" 
href="https://azukiazusa.dev/blog/svelte-reactivity-system-with-runes"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/svelte-reactivity-system-with-runes">Svelte v5 で導入された Runes によるリアクティビティシステム</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Svelte v5 で導入された Runes によるリアクティビティシステムについて解説します。従来の Svelte は純粋な JavaScript のコードのみを使用してリアクティビティを実現していましたが、アプリケーションが大規模になると複雑性が増すという問題がありました。Runes は Svelte のリアクティビティシステムをより柔軟にし、アプリケーションの規模が大きくなってもシンプルさを保つことを目指しています。</div><div class="ui-feed-item__date" title="2024-05-04 05:54:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/typescript-library-for-safer-error-handling-and-async-operations-effect-ts"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" 
loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/typescript-library-for-safer-error-handling-and-async-operations-effect-ts">エラーや非同期処理をより安全に扱うための TypeScript ライブラリ Effect-TS</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Effect-TS は、開発者が複雑なエラーや非同期処理をより安全に開発できるようにすることを目的とした TypeScript ライブラリです。Effect-TS は、TypeScript の型システムを活用して、本番のアプリケーションにおける実用的な問題を解決することを目指しています。</div><div class="ui-feed-item__date" title="2024-04-29 05:54:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/nextjs-typed-routes"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/nextjs-typed-routes">Next.js 型安全なルーティングを使う</a><div 
class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Next.js では実験的な機能として、型安全なルーティングを利用できます。この機能を使うことでリンク先のパス名を静的に検査できるため、typo などのエラーを事前に防ぐことができます。</div><div class="ui-feed-item__date" title="2024-04-28 06:46:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/53WOkRFJq2m0UvpiEH4RV8"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/53WOkRFJq2m0UvpiEH4RV8">React v19 から forwardRef が不要になる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">今までの React では `ref` をコンポーネントの Props として渡す際に、`forwardRef` を使ってラップする必要がありました。しかし、React v19 からは `forwardRef` が不要になり、`ref` を直接渡すことができるようになりました。</div><div class="ui-feed-item__date" title="2024-04-27 15:00:00">2年前</div></div></div>
<div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/single-fetch-in-remix"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/single-fetch-in-remix">Remix v2.9 で導入された Single Fetch</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Remix v2.9 で導入された Single Fetch はクライアントサイドでのページ遷移が行われた際に、サーバーへの複数の HTTP リクエストを並行して行う代わりに、1 つの HTTP リクエストを実行しまとめてレスポンスを返す機能です。Single Fetch は v2.9 ではフィーチャーフラグとして提供されており、v3 以降ではデフォルトの挙動となります。</div><div class="ui-feed-item__date" title="2024-04-27 05:08:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/6Q3axtdkljrdkl9jiahurP"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div 
class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/6Q3axtdkljrdkl9jiahurP">Math.max() にスプレッド構文で大きな配列を渡すとエラーになる恐れがある</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">`Math.max()` は、引数に渡された数値のうち最大のものを返す JavaScript の組み込み関数です。この関数は任意の数の引数を受け取るので、配列最大値を求めたい場合にはスプレッド構文で展開して渡す使い方が一般的です。しかし、引数の数が多すぎるとエラーになることがあります。</div><div class="ui-feed-item__date" title="2024-04-21 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/relative-css-units-based-on-container-elements"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/relative-css-units-based-on-container-elements">コンテナ要素に基づく相対的な CSS の単位（cqw, cqh, cqi, cqb, cqmin, cqmax）</a><div class="ui-feed-item__blog-title">
azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">コンテナクエリ単位とは、コンテナ要素に基づいてスタイルを定義するための相対的な長さを表す単位です。例えば `1cqw` はコンテナ要素の幅の 1% に相当します。</div><div class="ui-feed-item__date" title="2024-04-21 02:22:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/3xubuPzazJ86RlN8Br7Lm3"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/3xubuPzazJ86RlN8Br7Lm3">CSS でファイルのアップロードボタンをカスタマイズする ::file-selector-button 疑似要素</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">`::file-selector-button` 疑似要素を使用することで、`` 要素のデフォルトのボタンのスタイルをカスタマイズできます。現在すべてのモダンブラウザでサポートされています。</div><div class="ui-feed-item__date" title="2024-04-15 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" 
href="https://azukiazusa.dev/blog/css-anchor-positioning"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/css-anchor-positioning">ポップアップが画面内に収まらない場合に自動的に表示位置を調整する CSS Anchor Positioning</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">CSS Anchor Positioning とは、特定の要素を Anchor（基準）としてツールチップなどの要素の位置を決定する機能の総称です。CSS Anchor Positioning を使用することで、Floating UI のように自動で画面内に表示されるツールチップやコンテキストメニューを実装できます。</div><div class="ui-feed-item__date" title="2024-04-13 06:49:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/promise-context-value-react-hook"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" 
href="https://azukiazusa.dev/blog/promise-context-value-react-hook">Promise や Context から値を読み取る use React フック</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">React の Canary および experimental チャンネルでのみ利用可能な `use` フックについて解説します。`use` フックは Promise や Context から値を読み取るためのフックで、Promise の値を同期的に読み取ることができます。その他の React フックと異なり、`if` 文やループ内で呼び出すことができる点が特徴として挙げられます。</div><div class="ui-feed-item__date" title="2024-04-07 01:33:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/container-style-query-in-css"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/container-style-query-in-css">親要素のスタイルの基づいてスタイルを適用するコンテナスタイルクエリー CSS</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
CSS の @container ルールは、コンテナ（親要素）の特性に基づいてスタイルを適用するためのルールです。コンテナースタイルクエリーはコンテナサイズクエリーとコンテナスタイルクエリーの 2 種類に分類されます。コンテナスタイルクエリは style() 関数記法で定義されたスタイルを @container ルールで評価し、指定された条件が一致する場合にスタイルが適用されます。</div><div class="ui-feed-item__date" title="2024-03-30 05:12:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/5DNVLeqAtB5yYui390DNvS"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/5DNVLeqAtB5yYui390DNvS">CSS: ダークモードで値を切り替える light-dark 関数</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">light-dark 関数は CSS のカラー関数で、引数に 2 つのカラー値を取り、ライトモードのときには 1 つ目の値をを、ダークモードのときには 1 つ目の値を返します。`color-scheme` プロパティの値もしくはユーザーの OS のダークモード設定によって切り替わります。</div><div class="ui-feed-item__date" title="2024-03-27 15:00:00">2年前</div>
</div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/css-to-react-component-with-mistcss"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/css-to-react-component-with-mistcss">CSS から React コンポーネントを生成する MistCSS</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">MistCSS は CSS in JS になぞらえた JS from CSS というコンセプトで、CSS から React コンポーネントを生成するツールです。ピュアな CSS を記述できるので、学習コストが低い、パフォーマンスに影響がないといったメリットがあります。</div><div class="ui-feed-item__date" title="2024-03-23 05:18:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/unit-test-visual-screen-reader"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div 
class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/unit-test-visual-screen-reader">単体テストでスクリーンリーダーをシミュレートする Virtual Screen Reader</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Virtual Screen Reader は単体テストのためにスクリーンリーダをシミュレートするライブラリです。このライブラリを使うことでマウスやキボードの操作をテストするように、スクリーンリーダーにより期待する読み上げが行われるかどうかをテストできます。なお、Virtual Screen Reader はあくまでスクリーンリーダーの挙動を模倣したものであり、現実で使われているスクリーンリーダーによるテストを代替するものではないことに注意してください。</div><div class="ui-feed-item__date" title="2024-03-16 04:20:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/2jii12VuEFgjUUEzSDpjEy"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/2jii12VuEFgjUUEzSDpjEy">TypeScript 5.5 で関数による型の絞り込みが改善される</a><div 
class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">従来までは、TypeScript で関数の引数の型を絞り込んだ結果を返す場合には、ユーザー定義型ガードとして `x is string` のような形式で型ガードを定義する必要がありました。TypeScript 5.5 では自動で型の絞り込みが推論されるようになります。</div><div class="ui-feed-item__date" title="2024-03-15 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/form-accessibility"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/form-accessibility">フォームのアクセシビリティを考える</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
今日の Web におけるフォームはユーザーが情報を入力して対話するための重要な要素です。支援技術を利用しているユーザーがフォームの入力を妨げられることは当然避けるべきでしょう。また障害の有無に関わらず、ユーザーに迷いを与えたり、入力ミスを誘発するようなフォームはユーザーがタスクを完了せずに途中で離脱してしまう可能性が高まり、ビジネスの観点からも望ましくありません。この記事ではフォームのアクセシビリティについて考え、実際のフォームの実装においてどのような点に注意すべきかを紹介します。</div><div class="ui-feed-item__date" title="2024-03-10 05:06:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/75AEHrLoJIw1jQtCgE02Xn"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/75AEHrLoJIw1jQtCgE02Xn">CSS メディアクエリで比較演算子が使える</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">CSS のメディアクエリで比較演算子（``, `=`）が使えます。この記法を Range Syntax と呼びます。この記法は従来の `min-width` や `max-width` といった記法と比べて、より直感的に記述できるため便利です。</div><div class="ui-feed-item__date" 
title="2024-03-02 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/react-server-components-minimal-framework-waku"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/react-server-components-minimal-framework-waku">React Server Components を使うためのミニマムなフレームワーク Waku</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Waku は小規模から中規模の React プロジェクトを構築するためのミニマムなフレームワークです。従来は React Server Components を使うためには Next.js のような比較的大規模なフレームワークが必要でした。Waku もまた React Server Components に対応しているため、最小限の構成で React Server Components を使いたい場合に適しています。</div><div class="ui-feed-item__date" title="2024-03-02 07:13:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" 
href="https://azukiazusa.dev/blog/shorts/1qEr3YBzjVTUbtDrlTdGHG"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/1qEr3YBzjVTUbtDrlTdGHG">1 つの AbortController で複数の fetch をキャンセルできる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">`AbortController` は、fetch API でリクエストをキャンセルするためのオブジェクトです。`AbortController` は複数のリクエストを 1 度にキャンセルできます。</div><div class="ui-feed-item__date" title="2024-02-29 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/6TnCzA1HWOiWmIAVx0a3Gx"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" 
href="https://azukiazusa.dev/blog/shorts/6TnCzA1HWOiWmIAVx0a3Gx">CSS の reverse 系の値は可能な限り使わない</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">CSS の reverse 系の値とは、`flex-direction` の `row-reverse` や `column-reverse` などのことです。これらの値は、アクセシビリティの観点からできる限り使用を避けるべきです。</div><div class="ui-feed-item__date" title="2024-02-27 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/safetest-a-test-library-offering-a-new-ui-testing-approach"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/safetest-a-test-library-offering-a-new-ui-testing-approach">新しい UI テストの手法を提供するテストライブラリ SafeTest</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
SafeTest は Playwright と Jest/Vitest を組み合わせた UI テストライブラリです。特定のライブラリに依存せず、React, Vue, Angular, Svelte などのフレームワークに対応しています。SafeTest は単体テストと Playwright を使った E2E テストの手法を組み合わせることで、それぞれの手法が抱える欠点を補うことを目指しています。</div><div class="ui-feed-item__date" title="2024-02-25 04:14:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/write-articles-for-technical-practice"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/write-articles-for-technical-practice">技術の素振りのために記事を書く</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
技術の素振りを、ここではある特定の言語やフレームワークに対する理解を深めるために、その技術を使って何かしらの成果物を作成することと定義します。素振りの目的としては、ドキュメントからは読み取れない Pro/Con を得ること、その技術が実際のプロジェクトで使えるかどうか調査するといった事項があげられるでしょう。ただ素振りするだけではぼんやりと頭に知識が入っている状態になりがちですが、他者への説明というアウトプットを意識することで、コードを書くことによって得られた知見を整理できるようになります。</div><div class="ui-feed-item__date" title="2024-02-20 09:16:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/beginner-friendly-simple-rules"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/beginner-friendly-simple-rules">初心者向けの単純なルールを作る</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">新しい物事を始めるときは複雑な理屈は抜きにして、単純なルールが規定されていることが初心者にとって大切です。この理屈は開発時の設計やコーディングルールにも当てはまると思います。単純なルールとして lint を設定したり、コンポーネント化して複雑な部分を隠蔽することですべての開発者にとってコードをコミットしやすくなります。</div><div 
class="ui-feed-item__date" title="2024-02-19 09:59:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/type-safe-and-progressive-enhancement-form-library-conform"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/type-safe-and-progressive-enhancement-form-library-conform">type-safe とプログレッシブエンハンスメント、アクセシビリティヘルパーを備えたフォームライブラリ Conform</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Conform は React 向けのフォームライブラリです。type-safe であること、Web 標準を利用したプログレッシブエンハンスメントや、アクセシビリティヘルパーを特徴としており、Next.js の Server Actions や Remix に対応しています。</div><div class="ui-feed-item__date" title="2024-02-18 04:30:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" 
href="https://azukiazusa.dev/blog/full-stack-web-framework-honox"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/full-stack-web-framework-honox">フルスタック Web フレームワーク HonoX を使ってみる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">HonoX は Hono と Vite をベースにしたフルスタック Web フレームワークです。Hono が提供するサーバーサイドやクライアントサイドの機能を使いつつ、ファイルベースルーティングや Islands Architecture などの新しい機能を使うことができます。</div><div class="ui-feed-item__date" title="2024-02-10 07:55:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/tailwind-css-libs"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" 
href="https://azukiazusa.dev/blog/tailwind-css-libs">Tailwind CSS を使う時に一緒に入れたいライブラリ</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Tailwind CSS を使う上でクラス名をスッキリと書くために一緒に入れたいライブラリを紹介します</div><div class="ui-feed-item__date" title="2024-02-03 10:26:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/hono-streaming-response"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/hono-streaming-response">Hono で Server-Sent Events によるストリーミングを実装する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Server-Sent events（SSE）は、サーバーからクライアントに向けてイベントをストリーミングするための仕組みです。WebSocket と比較すると、サーバーからの単方向の通信、HTTP で通信するという特徴があります。この記事では Hono を使って OpenAI API を使ったテキスト生成をストリーミングする方法を紹介します。</div>
<div class="ui-feed-item__date" title="2024-02-01 11:43:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/5g2wGcIq0uuPn1jn9soemE"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/5g2wGcIq0uuPn1jn9soemE">npm は isntall でもコマンドを実行できる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">npm は install の alias として isntall が用意されているので、typo して isntall と打ってもコマンドが実行されます。</div><div class="ui-feed-item__date" title="2024-01-31 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/5KH0RavVHAFFwAHMcLQGSg"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div 
class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/5KH0RavVHAFFwAHMcLQGSg">クラス名の結合をする軽量ライブラリの clsx</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">clsx は、複数のクラス名を結合するための軽量ライブラリです。条件によってクラスを付け替えたり、グルーピングをする際に簡潔に記述できます。</div><div class="ui-feed-item__date" title="2024-01-27 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/typescript-like-syntax-for-openapi-schemas"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/typescript-like-syntax-for-openapi-schemas">TypeScript のような構文で OpenAPI のスキーマを定義する TypeSpec</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
TypeSepc は TypeScript にインスパイアされた言語で、開発者が親しみやすい構文で OpenAPI のスキーマを定義できます。モデルを使ってデータの構造を定義し、`@route` デコレーターを使って REST API のエンドポイントを定義します。</div><div class="ui-feed-item__date" title="2024-01-27 04:48:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/5BUGlsWJn2QzxIgFYvkrds"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/5BUGlsWJn2QzxIgFYvkrds">CSS で絶対に最前面に表示したい要素には z-index:calc(infinity) を指定する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">いつの時代にも z-index の管理には頭を悩ませます。z-index の値には 1 以外の値を許可しないなどの管理方法がありますが、外部のライブラリを使用してる場合に勝つことができません。そこで z-index の値に `calc(infinity)` を指定すると、絶対に最前面に表示させることができます。</div><div class="ui-feed-item__date" title="2024-01-25 15:00:00">2年前</div></div></div><div 
class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/3YJDVYrF4mHiqMsnmzUQvW"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/3YJDVYrF4mHiqMsnmzUQvW">Node.js esm の dirname と filename</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">commonjs では `__dirname` と `__filename` でファイルのパスを取得できますが ES Modules では使えません。今まで同等の API が存在していなかったのですが、Node.js v20.11.0 で `import.meta.dirname` と `import.meta.filename` が追加されました。</div><div class="ui-feed-item__date" title="2024-01-23 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/bun-cross-platform-shell-script"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a>
<div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/bun-cross-platform-shell-script">Bun でクロスプラットフォームなシェルスクリプト</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Bun の `$` を使うと、クロスプラットフォームなシェルスクリプト（Bun Shell）を書くことができます。Bun Shell は macOS (zsh)、Linux (bash)、および Windows (cmd) と OS の違いを気にせずにシェルスクリプトを書ける、JavaScript オブジェクトとのやりとりが可能であることが特徴です。</div><div class="ui-feed-item__date" title="2024-01-20 11:01:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/73zH9ULSIWeA55tA6corT8"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/73zH9ULSIWeA55tA6corT8">MSW v2 では　Web 標準の Fetch API をサポート</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div 
class="ui-feed-item__summary">Mock Service Worke（MSW） v2 では Web 標準の Fetch API をサポートしました。</div><div class="ui-feed-item__date" title="2024-01-14 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/remix-spa-mode"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/remix-spa-mode">Remix の SPA モード</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Remix は React のフルスタックフレームワークで、Web 標準に基づいた API で構築されていることが特徴です。Node.js のようなサーバーサイドの JavaScript 環境で動作することを前提としています。しかし、現実の世界ではサーバーを用意せずに、静的なファイルをホスティングするだけの環境で Web アプリケーションを構築することが有効な場合も多くあります。このような需要を満たすために、Remix v2.5.0 から実験的に SPA モードが導入されました。</div><div class="ui-feed-item__date" title="2024-01-14 02:22:00">2年前</div></div></div><div class="ui-feed-item"><a 
class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/4Tq3csJ5BwAXPR4OBuJvIo"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/4Tq3csJ5BwAXPR4OBuJvIo">TypeScript で任意の文字列を受け取りつつエディタの補完を効かせる型</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">すべての文字列を受け入れつつ、特定の文字列のみを補完候補に表示させたい場合があります。例えば、CSS の色を指定するプロパティの値には、カラーコードで指定する `#000000` や `#ffffff` などの文字列を受け入れつつ、`red` や `blue` などの特定の文字列を指定します。</div><div class="ui-feed-item__date" title="2024-01-12 10:13:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/3rHXViGZDvnLN3TGQqZ2TP"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a 
class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/3rHXViGZDvnLN3TGQqZ2TP">React でコンポーネントの Props の型を取得する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">プリミティブな UI を構築するとき、button や input などの HTML 要素をラップしたコンポーネントを作成することがあります。このようなコンポーネントでは、HTML 要素の Props に加えて、コンポーネント固有の Props を定義することが多いです。</div><div class="ui-feed-item__date" title="2024-01-11 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/47G6Ncc9VEZ1qOIGaZ9eOx"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/47G6Ncc9VEZ1qOIGaZ9eOx">配列をグループ化する Object.groupBy 静的メソッド</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
Object.groupBy 静的メソッドは、ES2024 で追加された配列をグループ化する関数です。配列の各要素に対してグループ化のキーを指定することで、グループ化されたオブジェクトを返します。</div><div class="ui-feed-item__date" title="2024-01-10 20:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/5VaSPYejGTbfPNm8xK8TqN"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/5VaSPYejGTbfPNm8xK8TqN">TailwindCSS で複数行のテキストを省略するとき</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">TailwindCSS で長いテキストを省略するときには、`truncate` クラスを使用します。しかし、`truncate` クラスは 1 行のテキストにしか対応していません。</div><div class="ui-feed-item__date" title="2024-01-10 17:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/23dS5pxOnX9UmrJFiCERQw"><img 
src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/23dS5pxOnX9UmrJFiCERQw">tabIndex には 0 と -1 だけを指定する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">tabIndex 属性は、フォーカス可能な要素を指定するための属性です。この属性自由な数値を指定できますが、これはアクセシビリティの観点から推奨されていません。</div><div class="ui-feed-item__date" title="2024-01-10 16:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/7hqTwjmQ3nlA7Nt8W6eceS"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/7hqTwjmQ3nlA7Nt8W6eceS">Svelte の Props 省略記法</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div 
class="ui-feed-item__summary">Svelte ではコンポーネントに Props を渡す際に省略記法が使えます。</div><div class="ui-feed-item__date" title="2024-01-10 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/4byw2Sh9S0AQfqL9Tyz08q"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/4byw2Sh9S0AQfqL9Tyz08q">GitHub Copilot Chat の inline chat のキーボードショートカットを無効にする</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">GitHub Copilot Chat を VSCode で使用していると、エディタ上で ⌘ + i を押すと inline chat が表示されます。しかし、このショートカットはコードの補完を表示するためにも使われていました。このショートカットに慣れていた人にとっては、inline chat が表示されるのは意図しない動作でしょう。</div><div class="ui-feed-item__date" title="2024-01-09 16:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" 
href="https://azukiazusa.dev/blog/shorts/1BPeVzWipcnv9IIopiScEd"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/1BPeVzWipcnv9IIopiScEd">details 要素の name 属性による排他的アコーディオン</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">`details` 要素は、開閉可能なコンテンツをマークアップするための要素です。`details` 要素に新たに `name` 属性が追加され排他的アコーディオンとして利用できるようになりました。</div><div class="ui-feed-item__date" title="2024-01-09 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/5LiIo1l7qCJN5ptnXUjl8u"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/5LiIo1l7qCJN5ptnXUjl8u">
GitLens で特定のコミットを除外する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">GitLens の使用時に、機械的にフォーマットされたコミットがあるとコードの変更履歴を確認する際に邪魔になってしまいます。この記事では、GitLens で特定のコミットを除外する方法を紹介します。</div><div class="ui-feed-item__date" title="2024-01-08 16:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/48N6K7RZKQhKT83zsu1AMS"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/48N6K7RZKQhKT83zsu1AMS">大きさが自動で変わる textarea を CSS だけで実現</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">テキストの入力量に応じて自動で高さが変わる textarea をよく見かけると思います。Slack や X の入力欄がそうですね。</div><div class="ui-feed-item__date" title="2024-01-08 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a 
class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/shorts/PQPy2VKlf5RDNssDCgdnP"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/shorts/PQPy2VKlf5RDNssDCgdnP">TailwindCSS の data 属性</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">TailwindCSS v3.2 からは data 属性を使って、条件付きでスタイルを適用できます。</div><div class="ui-feed-item__date" title="2024-01-07 15:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/static-site-search-engine-and-ui-library-pagefind"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" 
href="https://azukiazusa.dev/blog/static-site-search-engine-and-ui-library-pagefind">静的サイト向けの全文検索エンジンと UI ライブラリの Pagefind</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Pagefind は、静的サイト向けの全文検索エンジンと UI ライブラリです。特定のフレームワークに依存しない JavaScript ライブラリとして実装されており、静的サイトジェネレーターで生成された HTML ファイルに対して検索機能を追加できます。</div><div class="ui-feed-item__date" title="2024-01-06 06:52:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/books-i-read-in-2023"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/books-i-read-in-2023">2023 年に読んでよかった本</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
年末なので 2023 年のまとめっぽい記事を書きたくなりました。今年は 1 年間でおおよそ 300 冊の本をよんだようです（そのうち 3 割ほどはラノベなのですが...）。その中でも特に印象に残った本を紹介します。</div><div class="ui-feed-item__date" title="2023-12-30 10:22:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/input-type-checkbox-switch"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/input-type-checkbox-switch">input[type=checkbox] 要素に switch 属性を指定することによる HTML 標準のスイッチ UI の提案</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">スイッチは多くのウェブサイトで使われているものの、HTML の標準要素としては存在していませんでした。そのため多くの開発者は、スイッチを実装するために独自の実装を行っていましたが、このような独自の実装はアクセシビリティの問題を引き起こす可能性がありました。この問題を解決するために、WHATWG により `input[type=&quot;checkbox&quot;]` 要素に `switch` 属性を追加することが提案されました。この属性を指定することで、チェックボックスをスイッチとして利用できます。</div><div 
class="ui-feed-item__date" title="2023-12-23 07:31:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/custom-build-opentelemetry-collector"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/custom-build-opentelemetry-collector">OpenTelemetry Collector をカスタムビルドする</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">本番環境では OpenTelemetry Collector Contrib を使用せず、必要なコンポーネントのみを含むようにカスタムビルドすることが推奨されています。この記事では、OpenTelemetry Collector をカスタムビルドする方法について紹介します。</div><div class="ui-feed-item__date" title="2023-12-20 11:49:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/scroll-driven-animation"><img src="../../images/alternate-feed-image.png" 
alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/scroll-driven-animation">CSS だけで動くスクロールドリブンアニメーション</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Google Chrome 115 で追加されたスクロールドリブンアニメーションを使うことで、今まで JavaScript を使わなれけば実装できなかったようなスクロールと連動するアニメーションを CSS だけで実装できるようになりました。スクロールの進行状況に応じてバーを伸縮させるようなアニメーションや、要素が画面内に入ったタイミングでアニメーションを開始するようなことが実装できます。</div><div class="ui-feed-item__date" title="2023-12-17 04:29:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/storybook-v8-react-server-components"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/storybook-v8-react-server-components">
Storybook v8 の React Server Components サポート</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Storybook v8 では `experimentalNextRSC` オプションにより React Server Components をサポートしています。しかし、このオプションは React Server Components としての動作を再現しているわけではありません。サーバーサイドで Storybook が動作してるわけではなく、非同期コンポーネントをクライアントでレンダリングしているに過ぎないことに留意すべきです。</div><div class="ui-feed-item__date" title="2023-12-09 09:17:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/msw-v2-httpresponse-json-type-error"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/msw-v2-httpresponse-json-type-error">MSW v2 で `HttpResponse.json()` の型がおかしいときの対処法</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
MSW v2 の `HttpResponse.json()` の第 2 引数の型は `Response` オブジェクトの初期化時に渡すオプションを指定できます。しかし、tsconfig.json の設定によっては、この型がおかしくなることがあります。その場合には、`tsconfig.json` の `compilerOptions.lib` に `dom` を追加するのが一時的な対処法です。</div><div class="ui-feed-item__date" title="2023-12-02 08:42:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/server-components-testing"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/server-components-testing">React Server Components のテスト手法</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
現代におけるコンポーネントのテストは Testing Library を用いてテストを行うことが一般的です。しかし、2023 年 11 月現在、Testing Library はまだ Server Components のテストを十分にサポートしていません。そのため、Server Components のテストを行うには、別の方法を用いる必要があります。この記事では、Testing Library を用いずに Server Components のテストを行う方法について説明します。</div><div class="ui-feed-item__date" title="2023-11-26 05:21:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/combobox-element"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/combobox-element">HTML 標準でコンボボックスを実現する `&lt;combobox&gt;` 要素の提案</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">コンボボックスとは、テキストボックスとドロップダウンリストを組み合わせた UI コンポーネントです。コンボボックスはユーザーがテキストボックスに入力した文字列に基づいて、ドロップダウンリストのアイテムをフィルタリングできます。`` 要素は、HTML の標準でコンボボックスを実現することを目的としています。</div><div 
class="ui-feed-item__date" title="2023-11-18 11:47:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/why-use-server-actions"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/why-use-server-actions">なぜ Server Actions を使うのか</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Next.js 14 の Server Actions の stable リリースに発表は大きな反響を呼びました。特に `` の `formAction` 属性内で直接 SQL クエリを実行するコードは多くの人に衝撃を与えていました。Server Actions の是非について語る時、導入の背景にユーザー体験の向上があるという観点を忘れてはいけません。また、セキュリティ上の観点についてどのように考えるべきでしょうか？</div><div class="ui-feed-item__date" title="2023-11-12 05:10:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" 
href="https://azukiazusa.dev/blog/use-the-npm-install-package-lock-only-command-when-migrating-package-managers-to-npm"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/use-the-npm-install-package-lock-only-command-when-migrating-package-managers-to-npm">パッケージマネージャーを npm に移行するときには `npm install --package-lock-only` コマンドを使うとよい</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">既存のプロジェクトで npm に移行する際に `npm install --package-lock-only` を使うことで、依存パッケージのバージョンを変更することなく lock ファイルを移行できます。</div><div class="ui-feed-item__date" title="2023-11-07 10:40:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/server-actions-return-jsx"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" 
height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/server-actions-return-jsx">Server Actions の戻り値には JSX を使える</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Server Actions の戻り値には、シリアライズ可能なデータ型を返す必要があります。ドキュメントでは Server Actions の戻り値に JSX を使うことはサポートされていないと記述されていますが、実際には Server Actions の戻り値に JSX を使うことができます。ただし、公式にサポートされている仕様ではないので、思わぬバグを踏む、将来追加される機能に対応しないおそれがあることを理解した上で、使うかどうかを判断する必要があります。</div><div class="ui-feed-item__date" title="2023-11-04 05:45:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/use-form-state-to-display-error-messages-in-server-actions-forms"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" 
href="https://azukiazusa.dev/blog/use-form-state-to-display-error-messages-in-server-actions-forms">Server Actions のフォームバリデーションにおいて useFormState でエラーメッセージを表示する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Next.js の Server Actions でフォームを作成する際に、どのような方法でバリデーションを行い、エラーメッセージを表示する際にどのような手段が考えられるでしょうか。プログレッシブエンハンスメントの恩恵を受けるために、サーバーサイドでバリデーションを行いその結果を表示する方法が効果的です。`useFormStatus` フックはこの一連の動作を行うために使用します。</div><div class="ui-feed-item__date" title="2023-10-31 10:16:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/exclude-specific-commits-from-github-history"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/exclude-specific-commits-from-github-history">GitLens で特定のコミットを除外する</a><div class="ui-feed-item__blog-title">
azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">GitLens の使用時に、機械的にフォーマットされたコミットがあるとコードの変更履歴を確認する際に邪魔になってしまいます。この記事では、GitLens で特定のコミットを除外する方法を紹介します。</div><div class="ui-feed-item__date" title="2023-10-28 01:30:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/invokers-to-add-interactions-without-javascript"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/invokers-to-add-interactions-without-javascript">JavaScript なしでインタラクションを追加する Invokers</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Invokers は JavaScript なしでインタラクションを追加するための提案です。`` 要素に `invoketarget` 属性を指定することで、値として指定した id を持つ `` などの要素の開閉状態を切り替えることが可能となります。</div><div class="ui-feed-item__date" title="2023-10-22 01:37:00">2年前</div></div></div>
<div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/url-canparse-method"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/url-canparse-method">URL が有効かどうかを判定する `URL.canParse()` メソッド</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">`URL.canParse()` メソッドは与えられた URL 文字列が有効であるかどうかを判定します。URL 文字列が有効であれば `true` を、無効であれば `false` を返します。これは URL コンストラクターを用いた `try...catch` 文による判定よりも簡潔に記述できます。</div><div class="ui-feed-item__date" title="2023-10-15 05:28:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/user-valid-and-user-invalid-pseudo-classes"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div 
class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/user-valid-and-user-invalid-pseudo-classes">:user-valid、:user-invalid 擬似クラスでユーザーの操作の後に検証を行う</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">ユーザーの操作の後にフォームの検証に基づき有効か無効かを示すために使用できる :user-valid、:user-invalid 擬似クラスを紹介します。従来の :valid、:invalid 擬似クラスと異なり、ユーザーがフォームに入力するまではスタイルを適用されません。</div><div class="ui-feed-item__date" title="2023-10-13 11:16:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/focusgroup-arrow-key-focus-navigation"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/focusgroup-arrow-key-focus-navigation">focusgroup で矢印キーによるフォーカスナビゲーションを実装する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div>
<div class="ui-feed-item__summary">カスタム UI ウィジェットを実装する際には、ウィジェットのロールに応じたキーボード操作によるフォーカスナビゲーションを実装することが求められています。従来このようなキーボード操作は JavaScript を用いて実装する必要がありました。`focusgroup` の提案は、このようなキーボード操作を独立して使用できるプリミティブとして提案されています。この機能を利用することで、開発者は JavaScript を用いることなく一貫したフォーカスナビゲーションを実装できます。</div><div class="ui-feed-item__date" title="2023-10-09 05:22:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/details-name-attribute-accordion"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/details-name-attribute-accordion">`&lt;details&gt;` 要素の `name` 属性による排他的なアコーディオンの実装</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">`` 要素の `name` 属性を利用してグループ化することにより、排他的なアコーディオンを JavaScript なしで実装できます。</div><div class="ui-feed-item__date" 
title="2023-10-08 06:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/selectlist-element-for-a-more-customizable-select-box"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/selectlist-element-for-a-more-customizable-select-box">よりカスタマイズ可能なセレクトボックスを実現する `selectlist` 要素</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">`` 要素は、デザインをカスタマイズできなかった従来の `` 要素の問題を解決するために Open UI グループにより提案されている要素です。`` の構成要素の多くはスロットとして提供されていて、高いカスタマイズ性を備えているのが特徴です。</div><div class="ui-feed-item__date" title="2023-10-07 07:46:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/history-replacestate-rate-limit"><img src="../../images/alternate-feed-image.png" 
alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/history-replacestate-rate-limit">`history.replaceState()` にはブラウザによって呼び出し回数制限がある</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">`history.replaceState()` は、ブラウザの履歴を変更するための API です。使用例としてユーザーのアクションによる UI の状態の変更に合わせて、URL のクエリパラメータを変更することが挙げられます。この API はブラウザにより呼び出し回数に制限が設けられており、使い方を誤ると予期せぬ挙動が発生するおそれがあります。</div><div class="ui-feed-item__date" title="2023-10-01 04:11:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/manage-modal-state-with-url"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/manage-modal-state-with-url">モーダルの開閉状態を URL で管理する</a><div 
class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">モーダルの開閉状態を URL で管理することで、状態を復元したり、状態を共有できるなどのメリットがあります。この記事では、Next.js を例に URL でモーダルの開閉状態を管理する方法を紹介します。</div><div class="ui-feed-item__date" title="2023-09-24 07:38:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/elysiajs-tutorial"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/elysiajs-tutorial">Bun の Web フレームワーク ElysiaJS のチュートリアル</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">ElysiaJS は Bun の Web フレームワークです。高いパフォーマンスと、シンプルな API や厳格な型チェックにより生産性に優れているという特徴があります。また柔軟性が高く、多くのプラグインを組み合わせて利用できます。この記事では、ElysiaJS を使って簡単なタスク管理アプリの Web API を作成してみます。</div><div class="ui-feed-item__date" title="2023-09-16 02:34:00">2年前
</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/bun-workspace"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/bun-workspace">Bun workspace で始めるモノレポ生活</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Bun では `package.json` の `workspaces` を使用することでモノレポの管理が可能です。この記事では Bun によるモノレポを試してみます。</div><div class="ui-feed-item__date" title="2023-09-15 11:53:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/use-bun-macro-to-differentiate-new-features"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" 
href="https://azukiazusa.dev/blog/use-bun-macro-to-differentiate-new-features">Bun のマクロを使ってフィーチャートグルを実装する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Bun にはマクロはビルド時に実行される関数です。関数が返す値がインラインにバンドルファイルに埋め込まれます。マクロには、実行してインライン化した後に、デッドコードを削除するという特徴があります。この機能を使ってフィーチャートグルを実装してみましょう。</div><div class="ui-feed-item__date" title="2023-09-14 11:50:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/import-css-file-directly-in-bun-plugin"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/import-css-file-directly-in-bun-plugin">Bun の Plugins で CSV ファイルを直接 import する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
Bun の Plugins API を使用することで、任意の拡張子のファイルのサポートを追加できます。例えば Bun の公式の動画では、Plugins API を使用して Rust ファイル（.rs）を直接 import できる仕組みも作れることが紹介されています。</div><div class="ui-feed-item__date" title="2023-09-13 12:11:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/convert-logs-to-metrics-with-opentelemetry-collector-connector"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/convert-logs-to-metrics-with-opentelemetry-collector-connector">OpenTelemetry Collector の Connector を使ってログをメトリックに変換する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
OpenTelemetry には、メトリック、トレース、ログの 3 つの形式があります。これらの形式はそれぞれ別のパイプラインで処理されます。ある形式のデータを別の形式に変換し、あたかも 1 つのパイプライン上でデータを処理したい場合に Connector を使用します。例えば、あるパイプラインはログのパイプラインのエクスポーターとメトリックのパイプラインのレシーバーとして動作します。このような場合、Connector はログをメトリックに変換する役割を担います。</div><div class="ui-feed-item__date" title="2023-09-09 03:51:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/start-with-the-ugliest-code-that-works"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/start-with-the-ugliest-code-that-works">最小限のコードで動く最も汚いコードから始める</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
コードを書く際の重要な要点は、読みやすく他人に理解される「良いコード」を書くことです。しかし、完璧を目指して最初から書こうとすると行き詰まります。代わりに、荒削りながらも動くコードを作成し、徐々にリファクタリングして完成度を高めます。型エラーやリントエラーを無視しても構わないので、まずは動くものを作成しましょう。それからリファクタリングして「良いコード」を作成できます。</div><div class="ui-feed-item__date" title="2023-09-02 23:57:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/instrumenting-Node-js-applications-with-open-telemetry"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/instrumenting-Node-js-applications-with-open-telemetry">OpenTelemetry を使用して Node.js アプリケーションを計装する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
OpenTelemetry は Observability のフレームワークであり、トレース・メトリクス・ログなどのテレメトリーデータを作成、管理するためのツールキットです。OpenTelemetry はベンダーに依存しない形で標準化されたプロトコルとツールを提供していることが特徴です。この記事では Node.js アプリケーションを計装して Prometheus にデータを送信する方法を紹介します。</div><div class="ui-feed-item__date" title="2023-08-26 08:38:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/await-is-not-only-for-promise"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/await-is-not-only-for-promise">await は Promise 以外のオブジェクトでも値を取り出せる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">await キーワードは `then()` という名前のメソッドを持つオブジェクトに対して使用できます。このようなオブジェクトを thenable object と呼びます。await キーワードが Promise オブジェクトではなく thenable オブジェクトを対象としているのは、ライブラリの相互運用のためです。</div><div class="ui-feed-item__date" 
title="2023-08-20 08:41:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/react-memoized-component-children"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/react-memoized-component-children">【React】メモ化したコンポーネントに children を渡すと効果がなくなる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">React.memo は Props が変更されないかぎり、コンポーネントを再レンダリングしないようにする関数です。この関数はコンポーネントの余分なレンダリングを防ぎ、パフォーマンスを向上させる目的で使用されます。しかし、React.memo の使い方を誤ると意図しない再レンダリングが発生してしまうことがあります。ここではメモ化したコンポーネントに children を渡すと効果がなくなるというケースについて説明します。</div><div class="ui-feed-item__date" title="2023-08-13 04:25:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" 
href="https://azukiazusa.dev/blog/prefers-reduced-motion-or-application-settings"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/prefers-reduced-motion-or-application-settings">アニメーションの無効設定は prefers-reduced-motion に任せるか、アプリケーションの設定で制御するか</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">prefers-reduced-motion とは、ユーザーの環境設定によって余計な動きを抑制することを要求したことを検出するメディアクエリです。この設定は各 OS ごとに設定できます。ユーザーがアニメーションを無効にできることは、アクセシビリティの観点で重要です。prefers-reduced-motion によりアニメーションを無効にするのでも十分ですが、アプリケーションの設定として持たせるべきだと考えています。</div><div class="ui-feed-item__date" title="2023-08-06 05:25:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/rust-wasm-game-dev-book"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" 
loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/rust-wasm-game-dev-book">【書評】RustとWebAssemblyによるゲーム開発は Rust 開発における設計を学べる良書</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">本のタイトルは「Rust と WebAssembly によるゲーム開発」となっていますが、反して WebAssembly についての話題はほとんど出てきません。主に Rust における開発の設計についての話題が中心となっています。</div><div class="ui-feed-item__date" title="2023-07-30 13:39:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/graph-accessibility"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/graph-accessibility">グラフのアクセシビリティについて考える</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
`` や `` 要素で描画されたグラフは、スクリーンリーダーを使用するユーザーにとって内容を正しく理解することが難しいです。この記事では、グラフの内容をスクリーンリーダーを使用するユーザーに伝える方法について考えてみます。</div><div class="ui-feed-item__date" title="2023-07-29 08:19:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/react-memo-mocked-component-cannot-use-mock-function"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/react-memo-mocked-component-cannot-use-mock-function">React.memo でメモ化したコンポーネントはモック関数が使えない</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">テストにおいて子コンポーネントをモックしたい場合には通常のテストと同様に jest.mock() を使います。しかし、React.memo() でメモ化したコンポーネントはモック自体には成功するものの、mockImplementation のようなモック関数が使えません。</div><div class="ui-feed-item__date" title="2023-07-22 12:15:00">2年前</div></div></div><div class="ui-feed-item"><a 
class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/document-picture-in-picuture-any-element"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/document-picture-in-picuture-any-element">Document Picture in Picture で任意の要素を Picture in Picture する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Document Picture-in-Picture は、`` 要素に限らず任意の要素を PiP できるようにする提案です。これにより、動画以外の要素を PiP できるようになります。主なユースケースとして、カスタムのメディア・コントロールを使用したり、プレイリストとともに動画を PiP することが挙げられます。</div><div class="ui-feed-item__date" title="2023-07-16 05:38:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/snapshot-test-vs-assertion-test"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256">
</a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/snapshot-test-vs-assertion-test">スナップショットテストとアサーションテスト</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">この記事では、スナップショットテストとアサーションテストの違いを説明します。また、それぞれのアプローチでテストを書いたときのメリットとデメリットを見ていき、どちらのアプローチを採用すべきか考えていきます。</div><div class="ui-feed-item__date" title="2023-07-08 06:10:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/pnpm-patch"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/pnpm-patch">pnpm でパッケージにパッチを当てる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">`pnpm patch` コマンドを使うと、依存パッケージのコードを直接書き換えることができます。</div><div class="ui-feed-item__date" 
title="2023-07-01 05:37:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/do-not-use-aria-label-too-much"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/do-not-use-aria-label-too-much">aria-label を使いすぎない</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">aria-label 属性はコンテンツに対してアクセシブルな名前を与えるために使用します。aria-label 属性を使用する代表例として、中身がアイコンのボタンがあげられます。aria-label 属性は手軽に使えますが、できる限り一般的な形式でテキストを提供することが望ましいです。</div><div class="ui-feed-item__date" title="2023-06-25 04:17:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/screen-reader-friendly-text-notation"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" 
height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/screen-reader-friendly-text-notation">スクリーンリーダーに配慮したテキスト表記</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">文字を機械的に判断するスクリーンリーダーでは、人間の目によって判断できる文字について異なる解釈をするおそれがあります。そのような場合、利用者に正しい文章の意図を伝えられません。スクリーンリーダーに配慮したテキストの表記法を紹介します。</div><div class="ui-feed-item__date" title="2023-06-18 03:15:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/popover-api"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/popover-api">ポップオーバー API で JavaScript を使わずにポップアップを表示する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
Chrome 114 から追加されたポップオーバー API を使うと、JavaScript を使わずに簡単にポップアップを表示することができます。</div><div class="ui-feed-item__date" title="2023-06-11 05:12:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/vue-generic-component"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/vue-generic-component">Vue.js でジェネリックコンポーネントを使う</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Vue.js 3.3 から `` 構文を使用してコンポーネントを記述する際に、型引数を指定することができるようになりました。TypeScript で関数に型引数を指定するのと同じように、コンポーネントの props の型を指定することができます。</div><div class="ui-feed-item__date" title="2023-06-04 05:16:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/avoid-using-gif-animation"><img 
src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/avoid-using-gif-animation">GIF アニメーションの使用を控える</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">技術記事を書く際に、GIF アニメーションを使用することがあるかと思います。しかし、GIF アニメーションを使用することはアクセシビリティ上問題となります。この記事では、GIF アニメーションを使用することを避けるべき理由を説明します。</div><div class="ui-feed-item__date" title="2023-05-28 05:34:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/list-style-none-styled-ul-element-should-have-a-list-role"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/list-style-none-styled-ul-element-should-have-a-list-role">
list-style: none スタイルを指定した ul 要素には list ロールを指定すべき</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">WAI-ARIA における role 属性を使用する際のプラクティスとして、暗黙のロールを明示しないというものがあります。しかし、`` 要素は暗黙のロールとして `list` ロールを持っていますが、明示的に `list` ロールを宣言するべきです。</div><div class="ui-feed-item__date" title="2023-05-21 05:13:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/vitest-browser-test"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/vitest-browser-test">Vitest のブラウザテスト</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Vitest は実験的な機能として、ブラウザモードをサポートしています。ブラウザテストは Node.js 上で jsdom を用いてテストを実効するよりも信頼性の高い方法ですが、テストのセットアップに時間がかかるといったデメリットも存在します。</div><div class="ui-feed-item__date" 
title="2023-05-14 05:04:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/nextjs-server-action"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/nextjs-server-action">Next.js の Server Actions について</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Next.js の Server Actions はサーバーサイドのデータのミューテーション、クライアント JavaScript の削減、プログレッシブエンハンスメントなフォームを実現します。</div><div class="ui-feed-item__date" title="2023-05-06 05:13:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/sveltekit-form-action"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a 
class="ui-feed-item__title" href="https://azukiazusa.dev/blog/sveltekit-form-action">SvelteKit のフォーム操作</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">SvelteKit のフォームは Web 標準の機能のみで完結しています。つまり、クライアントサイドでは JavaScript を一切使用せずにサーバーにデータを送信できるのです。さらに、JavaScript を利用できる環境であるならばリッチなユーザー体験を追加できます。例えば、フォームを送信した後ページ全体の再読み込みを行わずに、フォームの送信結果を表示することができたり、バリデーションメッセージを即座に表示できたりします。</div><div class="ui-feed-item__date" title="2023-04-30 04:59:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/what-is-array-prototype-with"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/what-is-array-prototype-with">Array.prototype.with() とは</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
`Array.prototype.with()` は、非破壊的に配列の要素を置き換えるためのメソッドです。非破壊的とは、元の配列を変更せずに新しい配列を返すということです。`arr` に対して `with()` を実行しても、`arr` は変更されず、新しい配列のコピーが返されます。</div><div class="ui-feed-item__date" title="2023-04-23 03:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/tailwind-css-dark-mode-system-light-dark"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/tailwind-css-dark-mode-system-light-dark">Tailwind CSS のダークモードで System, Light, Dark を切り替える</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">ダークモードの設定では、OS の設定と同期させるか、ライトモードまたはダークモードに手動で切り替えるかの 3 つの選択肢が用意されていることがあります。手動でライトモードとダークモードを切り替える場合に比べて、OS の設定を自動で反映できるメリットがあります。</div><div class="ui-feed-item__date" title="2023-04-16 01:49:00">3年前</div></div></div><div 
class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/nextjs-interception-routes"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/nextjs-interception-routes">Next.js の Interception Routes について</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Intercepting routes は Next.js 13.3 から追加された機能で、App Router（app ディレクトリ）において使用できます。Intercepting routes ではブラウザの URL を遷移先のものに上書きしつつ、現在のレイアウトに新しいページを表示できます。これは例えば Instagram のように、ユーザーのプロフィールから写真をクリックすると、写真をモーダルを開き、ページを更新したり共通したりするとデフォルトのレイアウトで表示する場合などに便利です。</div><div class="ui-feed-item__date" title="2023-04-09 04:38:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/tried-superflare-a-full-stack-toolkit-for-cloudflare-workers"><img 
src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/tried-superflare-a-full-stack-toolkit-for-cloudflare-workers">Cloudflare Workers のためのフルスタックツールキット Superflare を試してみた</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Superflare は Cloudflare Workers 用のフルスタックツールキットです。D1 Database 向けの ORM や R2 Storage 向けのユーティリティなどの機能を提供しています。Superflare 自体はフレームワークを謳っておりません。実際に、Superflare は Remix、Next.js、Nuxt.js などのフレームワークと組み合わせることで効果を発揮します。</div><div class="ui-feed-item__date" title="2023-04-02 02:23:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/the-search-element-has-been-added-to-the-html-specification"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div 
class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/the-search-element-has-been-added-to-the-html-specification">HTML の仕様に search 要素が追加された</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">HTML Standardに新しい``要素が追加された。これまで、ARIAには``に相当するHTML要素がなかったため、``しか代替要素がなかった。新たに``要素を使用することにより、WAI-ARIA を使用せずともsearchランドマークを定義できるようになった。通常、``要素は少なくとも1つの入力要素を含んでおり、検索を開始するためのボタンもあることが期待されている。</div><div class="ui-feed-item__date" title="2023-03-26 07:50:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/it-may-be-helpful-to-provide-an-example-when-you-want-to-fix-the-output-format-in-chatgpt3"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" 
href="https://azukiazusa.dev/blog/it-may-be-helpful-to-provide-an-example-when-you-want-to-fix-the-output-format-in-chatgpt3">ChatGPT3 で出力の形式を固定したい場合には例を提示してあげるとよさそう</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">ChatGPT は毎回異なる出力を返すことがあるため、APIやアプリ開発にとって不都合が生じる。そこで、出力の例を提示することで固定した形式の回答を得やすくすることができる。提示するためのプロンプトは区切り文字を使用して区切ることが推奨され、回答は通常、「例」に基づいた形式で得られる。</div><div class="ui-feed-item__date" title="2023-03-19 04:13:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/exhaustive-checks-in-typescript"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/exhaustive-checks-in-typescript">TypeScript で網羅性をチェックする</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
パターンマッチを備えている言語では、コンパイル時に網羅性が検査され、網羅的でない場合にはコンパイルエラーとなります。例えば Rust では match 式は網羅性を検査します。列挙型が取りうる値をすべて網羅していない場合にはコンパイルエラーとなります。TypeScript にはパターンマッチがないため、網羅性の検査は行われません。ですが、TypeScript では `never` 型を利用することで網羅性の検査を行うことができます。</div><div class="ui-feed-item__date" title="2023-03-11 05:37:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/using-environment-variables-with-sveltekit"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/using-environment-variables-with-sveltekit">SvelteKit で環境変数を使う</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">SvelteKit プロジェクトは Vite を使用しているので、`import.meta.env` から環境変数を参照できます。単に環境変数を参照するだけならば十分です。ですが SvelteKit により提供されている環境変数の仕組みを使用すると、型安全に環境変数を参照できる、公開してはいけない値をクライアントから参照できなくなるなどのメリットを得られます。
</div><div class="ui-feed-item__date" title="2023-03-04 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/react-javascript-xss"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/react-javascript-xss">React は javascript スキームを使った XSS を防ぐことができない</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">React を使用していた場合に引き起こす可能性がある XSS 脆弱性の例として、javascript スキームを使った XSS があります。この記事では、javascript スキームを使った XSS についての説明とその対策について紹介します。</div><div class="ui-feed-item__date" title="2023-02-25 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/typescript-esmodules"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" 
width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/typescript-esmodules">TypeScript + ESModules の開発環境をシュッと作る</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">ほぼ設定なしで TypeScript + ESModules の開発環境をシュッと作る時のレシピです。</div><div class="ui-feed-item__date" title="2023-02-18 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/web-accessibility-basics-every-web-application-engineer-needs-to-know"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/web-accessibility-basics-every-web-application-engineer-needs-to-know">Web アプリケーションエンジニアのためのウェブアクセシビリティの基礎</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div 
class="ui-feed-item__summary">ウェブアプリケーションエンジニアを対象に、アクセシビリティの対応について解説した記事。アクセシビリティを向上させるためには、正しいHTMLの書き方が必要である。HTML要素には、アクセシビリティに関する機能が元々備わっているため、適切なHTMLを選択し使用することが大切だ。複雑なUIの場合はWAI-ARIAを使用し、ARIA Authoring Practices Guideに基づき適切に実装する必要がある。UIライブラリ選びの際には、WAI-ARIAに従った実装を行っているかが基準の1つとなる。</div><div class="ui-feed-item__date" title="2023-02-18 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/react-hook-form-zod-5-patterns"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/react-hook-form-zod-5-patterns">React Hook Form で Zod を使う時の 5 つパターン</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">React Hook Form で Zod を使用する時によくあるバリデーションのパターンを 5 つ紹介します</div><div class="ui-feed-item__date" title="2023-02-11 15:00:00">3年前
</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/sveltekit-navigate-progressbar"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/sveltekit-navigate-progressbar">SvelteKit でページ遷移時のプログレスバーを表示する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">SPA で画面遷移をする場合、MPA の場合と違い、ブラウザがローディングの表示を行ってくれません。リンクをクリックしてから画面遷移が完了するまで何も表示されないので、ユーザーからすると何も反応していないように感じてしまいます。 SPA で画面遷移した時にプログレスバーを表示したい場合には NProgress が最適です。コンパクトな JavaScript ライブラリでフレームワークを選ばず利用できます。この記事では SvelteKit で NProgress を使用する方法を紹介します。</div><div class="ui-feed-item__date" title="2023-02-05 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/accessible-tooltip"><img 
src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/accessible-tooltip">アクセシビリティに考慮したツールチップを実装する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">ツールチップとは、ある要素に対する補足情報を与える UI です。通常ある要素に対してマウスホバーまたはキーボードでフォーカスした時少しのディレイの後に、ユーザーの操作によらず自動的にポップアップして表示されます。このポップアップはユーザーの操作をブロッキングするものではありません。ユーザーがマウスのホバー外すかフォーカスが外れた場合にツールチップは非表示となります。</div><div class="ui-feed-item__date" title="2023-02-04 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/focus-css-focus-visible"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/focus-css-focus-visible">
focus() メソッドで CSS の :focus-visible 擬似クラスが適用されるかどうかは最後の操作によって異なる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">:focus-visible 擬似クラスはユーザーの入力方法によって異なるフォーカス表示をしたい時に便利です。この擬似クラスはキーボード操作によりフォーカスされた場合に適用されますが、マウス操作によりフォーカスした場合には適用されません。 それでは、JavaScript の focus()メソッドによりフォーカスされた場合には、`:focus-visible` 擬似クラスは適用されるのでしょうか？実はこれは最後 `focus()` メソッドが呼ばれる前に要素にフォーカスがあったかどうかにより異なります。</div><div class="ui-feed-item__date" title="2023-01-28 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/avoid-writing-conditional-branches-in-the–test-code"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/avoid-writing-conditional-branches-in-the–test-code">テストコード内では条件分岐を書かないようにする</a><div class="ui-feed-item__blog-title">
azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">誰でも読める愚直なコードであることの 1 つの目安として、テストコードの中に if 文や三項演算子などの条件分岐が入り込んでいていないことが上げられます。if 文が存在するコードはアンチパターンであるといえます。実際に if 文がテストコードの中に入り込んだ例を見てみましょう。</div><div class="ui-feed-item__date" title="2023-01-21 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/use-aria-disabled-to-give-focus-to-disabled-button"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/use-aria-disabled-to-give-focus-to-disabled-button">無効にしたボタンにフォーカスさせたいときには aria-disabled を使う</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
例えばフォームの項目になにか入力されるまで、送信ボタンを無効にしたい状況があるかと思います。このような場合には `` に `disabled` 属性を与えることでフォームの送信を無効にできます。`disabled` 属性はデフォルトでコントロールを無効にする一般的に期待されるすべての機能を提供するため、多くの場合はこの属性を使用するべきです。しかし `disabled` 属性には 1 つ問題点が存在します。それは Tab キーによるフォーカスができなくなるという点です。</div><div class="ui-feed-item__date" title="2023-01-14 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/the-unit-of-unit-testing-is-behavior-not-code"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/the-unit-of-unit-testing-is-behavior-not-code">単体テストの単位はコードではなく振る舞いである</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
単体テストの目的は、ソフトウェア開発プロジェクトを持続可能なものにすることです。この目的を達成するための単体テストの機能の 1 つにリファクタリングに対する耐性が上げられます。これは内部のコードを変更した前後でも、外部の振る舞いから見た振る舞いが壊れていないことを保証してくれる度合いです。この耐性が高ければ、開発者は安全にコードを変更できます。 この記事では、単体テストをコード単位で書いた場合と振る舞い単位で書いた場合をそれぞれ提示して、リファクタリングに対する耐性がどのように異なるのかを見ていきます。</div><div class="ui-feed-item__date" title="2023-01-07 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/accessibility-improvements-you-can-make-now"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/accessibility-improvements-you-can-make-now">今すぐできる Web アクセシビリティ改善</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
アクセシビリティの対応は、要件定義段階から設計したりなど大変そうなイメージはあります。実際に本格的に対応するにはどの達成基準を目標にするか決めたり、入念なテストが必要になるなど確かに一朝一夕で対応できるわけではないでしょう。 ですが、完璧な対応を目指すのではなく、少しづづ改善できるところから進めることこともできます。実際にやってみると、簡単な HTML や CSS のコードの修正でもよい改善を得られたりします。 この記事では比較的低コストで実践入門できるアクセシビリティの改善を紹介します。</div><div class="ui-feed-item__date" title="2022-12-30 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/do-not-compromise-html-functionality-in-your-web-front-end-implementation"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/do-not-compromise-html-functionality-in-your-web-front-end-implementation">Web フロントエンドの実装において本来の機能を損なってはいけない</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
データの取得・ルーティング・フォームの値の管理に至るまで JavaScript で制御するようになった結果、本来備わっていた機能を損なう形で実装されるような間違いが起きるケースも発生してしまいました。見た目上操作に不都合がないのですが、修飾キーが有効でなかったりと、とある要素が当然に持っているべき機能が失われていることがよくあります。</div><div class="ui-feed-item__date" title="2022-12-24 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/satori-sveltekit-ogp-image"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/satori-sveltekit-ogp-image">Satori + SvelteKit で OGP 画像を自動生成する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Satori とは Vercel が公開している OGP 画像生成ライブラリです。OGP 画像を表示したい場合、記事ごとに対応する OGP 画像が必要になるわけで、新しい記事を投稿するたびに新たな画像を生成しなければいけません。都度画像を生成する手間は取れないわけで、このOGP 画像を生成する工程を自動化する仕組みが必要となります。Satori は記事のタイトルなどをもとに動的 OGP 画像を生成するユースケースのために使用できます。</div><div 
class="ui-feed-item__date" title="2022-12-17 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/what-to-do-when-tailwindcss-is-momentarily-displayed-in-light-mode-in-dark-mode"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/what-to-do-when-tailwindcss-is-momentarily-displayed-in-light-mode-in-dark-mode">TailwindCSS のダークモードでページ読み込み時に一瞬ライトモードで表示されてしまうときの対応法</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">ユーザーの OS の設定や LocalStorage の値をもとにダークモードかどうか判定する場合、コンテンツが読み込まれる前にスクリプトの実行が完了している必要があります。</div><div class="ui-feed-item__date" title="2022-12-10 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/pa11y-ci-githubactions"><img 
src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/pa11y-ci-githubactions">Pa11y CI でアクセシビリティテストを GitHub Actions で実行する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Pa11y とは Web Content Accessibility Guidelines (WCAG) をベースに HTML のアクセシビリティを検査するツールです。適合レベル AA を対象にテストします。Pa11y にはいくつかの種類がありますが、その中でも Pa11y CI は CI 上で実行することにフォーカスしています。</div><div class="ui-feed-item__date" title="2022-12-03 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/monorepo-github-actions-jest-coverage-report-action"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" 
href="https://azukiazusa.dev/blog/monorepo-github-actions-jest-coverage-report-action">モノレポで GitHub Actions の jest coverage report を動かす</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">jest coverage reportは GitHuba Actions のワークフローの1つで Jest で実行したテストのコードカバレッジをプルリクエスト上にコメントしてくれます。 この記事では yarn workspaces 使用して作成したモノレポ構築のレポジトリで jest coverage report を動かしてみます。</div><div class="ui-feed-item__date" title="2022-11-26 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/typescript-4-9-in"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/typescript-4-9-in">TypeScript 4.9 で in 演算子による型の絞り込みが改善された</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
TypeScript において `in` 演算子を `unknown` 型に対して使用した際の挙動が改善されました。</div><div class="ui-feed-item__date" title="2022-11-19 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/react-router-defer"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/react-router-defer">React Router の defer で重要なデータを先に描画する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">あるページの中で重要ではない付随的なデータの取得を待たずに、重要なデータの取得が完了したタイミングでページを表示させたい場合があります。例えば、ブログの記事のページを遷移する場合、ユーザーにとって記事のコンテンツは重要なデータですが、それに付随するコメントやいいねの数はそれほど重要ではないので、それらのデータの取得を待つ必要がありません。 この記事では React Router の loaderを使用して重要なデータの完了のみを待機する方法を試してみます。</div><div class="ui-feed-item__date" title="2022-11-11 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a 
class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/react-accessible-tab"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/react-accessible-tab">【React】アクセシビリティに考慮したタブを実装する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">タブとは、ページ内でコンテンツを切り替えるために使用する UI です。タブ初期表示ではいずれか一つのタブパネルが表示されており、関連するタブがアクティブなスタイルで表示されます。それぞれのタブには関連するタブパネルがあり、タブを選択することで表示されるタブパネルがタブに関連するものに切り替わります。</div><div class="ui-feed-item__date" title="2022-11-05 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/react-accessible-accordion"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" 
href="https://azukiazusa.dev/blog/react-accessible-accordion">【React】アクセシビリティに考慮したアコーディオンを実装する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">アコーディオンは見出しであるヘッダーとコンテンツであるパネルから構成された UI が垂直に積み重ねられたセットです。ユーザーはヘッダーをクリックすることで、ヘッダーに関連付けられたパネルの表示・非表示を切り替えることができます。 アコーディオンは1つのページ内で複数のセクションのコンテンツを表示する際に、スクロールを減らすためによく 使用されます。例えば、「よくある質問」のようなページで使われていることを見たことがあるかと思います</div><div class="ui-feed-item__date" title="2022-10-28 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/Implement-accessibil-listbox-in-react"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/Implement-accessibil-listbox-in-react">【React】アクセシビリティに考慮したリストボックスを実装する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div 
class="ui-feed-item__summary">リストボックスにアクセシビリティ上求められる要件を確認した後に、React で実際に要件に従った実装をおこないます。</div><div class="ui-feed-item__date" title="2022-10-22 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/qwik-city-blog-app"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/qwik-city-blog-app">Qwik City でブログアプリを作る</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Qwik City は Qwik のメタフレームワークです。React における Next.js、Vue.js における Nuxt.js のような関係と同等です。</div><div class="ui-feed-item__date" title="2022-10-15 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/event-bubbling-follows-the-react-tree-not-the-dom-tree"><img 
src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/event-bubbling-follows-the-react-tree-not-the-dom-tree">イベントのバブリングは DOM ツリーではなく React ツリーに従う</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">イベントのバブリングとは、ある要素で発生したイベントがその親要素まで伝播することです。React でポータルを使用した場合、DOM ツリー状親子関係でなかったとしても、React ツリー上親子関係であればイベントがバブリングされます。</div><div class="ui-feed-item__date" title="2022-10-08 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/react-state"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/react-state">【React】state のリフトダウンパターン</a><div 
class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">React において不要な再レンダリングを避けるためのいくつかのパターンを紹介します</div><div class="ui-feed-item__date" title="2022-10-01 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/jest-beforeunload"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/jest-beforeunload">Jest で beforeunload イベントをテストする</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">beforeunload イベントをテストする方法を紹介します</div><div class="ui-feed-item__date" title="2022-09-24 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/css-pseudo-class-focus-within"><img src="../../images/alternate-feed-image.png" 
alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/css-pseudo-class-focus-within">CSS 擬似クラス「:focus-within」</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">:focus-within は CSS の擬似クラスであり、その要素または子孫要素にフォーカスがある場合に一致します。</div><div class="ui-feed-item__date" title="2022-09-17 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/dialog-accessibility"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/dialog-accessibility">アクセシブルなダイアログに必要なこと</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">ダイアログをアクセシビルに実装するための要件を確認しましょう。</div><div 
class="ui-feed-item__date" title="2022-09-10 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/sanitizer-api-html"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/sanitizer-api-html">Sanitizer API で HTML を安全に使用する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">ユーザーが入力した情報をそのまま表示するとクロスサイトスクリプティング（XSS）脆弱性につながる問題があることはよく知られています文字列の無害化はこのようにライブラリの実装に頼っている状況でしたが、WING により Sanitizer API という仕様が策定されました。Sanitizer API により外部ライブラリの依存無しで XSS の対策が可能となります。</div><div class="ui-feed-item__date" title="2022-09-03 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/hono-cloudflare-workers-rest-api"><img src="../../images/alternate-feed-image.png" 
alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/hono-cloudflare-workers-rest-api">Hono + Cloudflare Workers で REST API を作ってみよう</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Hono は TypeScript/JavaScript のシンプルな Web フレームワークです。Hono という名前は日本語の「炎」に由来します。 Hono の特徴としては以下の点が挙げられています。 - ウルトラファスト - 依存関係なし - ミドルウェア - TypeScript - マルチプラットフォーム</div><div class="ui-feed-item__date" title="2022-08-27 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/fetch-upload-streaming"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/fetch-upload-streaming">Fetch Upload Streaming でチャットアプリを作ってみる</a><div 
class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Fetch Upload Streaming とは、ブラウザの JavaScript の POST リクエストで HTTP のストリーミングを行える機能です。より具体的には、Fetch API の `body` に ReadableStream を渡せるようになります。</div><div class="ui-feed-item__date" title="2022-08-20 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/angularjs-react-3"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/angularjs-react-3">AngularJS のチュートリアルを React にリプレイスしてみた③</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">それではいよいよ、AnguarJS のルーティングモジュールである `ngRoute` を置き換えましょう。この置き換えが完了したら AngularJS を完全に取り除くことができます。</div><div class="ui-feed-item__date" title="2022-08-13 15:00:00">3年前</div></div></div><div 
class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/angularjs-react-2"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/angularjs-react-2">AngularJS のチュートリアルを React にリプレイスしてみた②</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">AngularJS のチュートリアルを React にリプレイスします。今回の記事では AngularJS のコンポーネントをすべてリプレイスして、angular-resorce の代わりに API クライアントを実装します。</div><div class="ui-feed-item__date" title="2022-08-06 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/angularjs-react"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" 
href="https://azukiazusa.dev/blog/angularjs-react">AngularJS のチュートリアルを React にリプレイスしてみた①</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">AngularJS のチュートリアルを React にリプレイスします。</div><div class="ui-feed-item__date" title="2022-07-30 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/pnpm-npm"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/pnpm-npm">pnpm は npm と何が違うのか</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">pnpm は npm、yarn と並ぶ JavaScript のパッケージマネージャーです。pnpm と言う名前は「performant npm」に由来します。</div><div class="ui-feed-item__date" title="2022-07-23 15:00:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" 
href="https://azukiazusa.dev/blog/examples-of-msw-practice-Applications"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/examples-of-msw-practice-Applications">MSW の実践活用例</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">msw の実践で活用する例を紹介します</div><div class="ui-feed-item__date" title="2022-07-16 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/volar-vuetify2-x"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/volar-vuetify2-x">Volar で Vuetify2.x の補完を効かせる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div 
class="ui-feed-item__summary">Volar + Vuetify 2.x を利用する場合、型定義ファイルを作成してグローバルコンポーネントを定義する必要があります。</div><div class="ui-feed-item__date" title="2022-07-09 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/schema-declaration-and-validation-in-zod"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/schema-declaration-and-validation-in-zod">【TypeScript】Zod でスキーマ宣言とバリデーションを実施する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">[Zod](https://github.com/colinhacks/zod) は TypeScript first でスキーマ宣言とバリデーションを実施するためのライブラリです。 一度バリデータを宣言すれば、Zod が自動的に TypeScript の型を推論してくれるという特徴があります。このおかげで重複した型宣言を排除できます。 また、Zod はエコシステムも多く存在しており、OpenApi、Nest.js、Prisma、react-hook-form などと組み合わせて使うことができます。</div><div class="ui-feed-item__date" 
title="2022-07-02 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/typescript-no-unchecked-indexed-access"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/typescript-no-unchecked-indexed-access">おまえら禁じられたインデックスアクセスを平気で使ってんじゃねえか！わかってんのか？『ランタイムエラー』が生まれたのは人間がコンパイラオプションに甘えたせいだろうがよ！</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">TypeScript 4.1 から noUncheckedIndexedAccess オプションが追加されました。このオプションは上記のような配列のアクセスやオブジェクトのプロパティのアクセスをより厳密にします。 具体的には、配列に対するインデックスアクセスやインデックスシグネチャを通じたプロパティのアクセスは常に `undefined` とのユニオン型となります。</div><div class="ui-feed-item__date" title="2022-06-25 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/fresh-tutorial">
<img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/fresh-tutorial">Deno Web フレームワーク Fresh チュートリアル</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Fresh は Deno 製の Web フレームワークです。事前のビルドを必要せず、エッジでレンダリングを提供するという特徴があります。また、Islands Architecture を採用しており、デフォルトではクライアントに JavaScript が配信されることがありません。</div><div class="ui-feed-item__date" title="2022-06-18 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/atomic-css-engine-unocss"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/atomic-css-engine-unocss">Atomic CSS エンジン - UnoCSS</a><div 
class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">UnoCSS はフレームワークではなく、Atomic CSS エンジンです。全ては柔軟性とパフォーマンスを考慮して設計されています。UnoCSS にはコアユーティリティはなく、すべての機能はプリセットで提供されます。</div><div class="ui-feed-item__date" title="2022-06-10 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/histoire-a-ui-component-cataloging-tool-from-Vite"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/histoire-a-ui-component-cataloging-tool-from-Vite">Vue 向けの Vite 製の UI コンポーネントカタログツール Histoire</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Histoireはフランス語で「Story」という意味の単語であり、Storybook のように UI コンポーネントのカタログを作成するツールです。Vite にネイティブ対応、Vue の SFC 形式で Story を書けるといった特徴があります。</div><div 
class="ui-feed-item__date" title="2022-06-04 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/jest-preview"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/jest-preview">Jest Preview がけっこーすごい</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Jest Preview とは Jest で実行中のテストに debug() 関数を仕込むことで、実行中のテストが作成した HTML をブラウザでプレビューしながらデバッグできるライブラリです。</div><div class="ui-feed-item__date" title="2022-05-28 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/playwright-component-testing"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a 
class="ui-feed-item__title" href="https://azukiazusa.dev/blog/playwright-component-testing">Playwright でコンポーネントテスト</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Playwright は E2E テストのための Node.js フレームワークです。v1.22.0 から React,Vue.js,Svelte のコンポーネントに対してテストを実行できるようになりました。つまりもともと備えていた E2E レベルのテストに加えて、結合レベルのテストまでカバーできるようになったということです。</div><div class="ui-feed-item__date" title="2022-05-21 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/tailwind-css-ui-library-option"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/tailwind-css-ui-library-option">Tailwind CSS ベースの UI フレームワークという選択肢</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
この記事を読んでいるみなさんも、Vuetify や MUI のような UI フレームワークを使用したことがあるでしょう。これらの UI フレームワークは Web アプリケーションでよく使われる UI パーツを非常に高機能で提供しており、多大な工数の削減に貢献しています。 その一方で、細かなスタイルの調整に手間取り余分に時間を取られ苦労を経験している方も多いのではないでしょうか？</div><div class="ui-feed-item__date" title="2022-05-14 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/node-js-api"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/node-js-api">Node.js の標準 API にテストランナーが追加された</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">JavaScript のテストランナーといえば、Jest がデファクトスタンダードと言えるでしょう。最近は Vitest と呼ばれる新たなテストランナーも登場していますが、しばらくは Jest が使われ続けられることでしょう。 そんな中、Node.js 18 から標準 API としてテストランナーが組み込まれました。まだ実験的な機能ではありますが、サードパーティのライブラリを使用せずに扱えることもあって注目を集めています。</div><div class="ui-feed-item__date" 
title="2022-05-07 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/what-i-found-attractive-aboutr-rust"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/what-i-found-attractive-aboutr-rust">Rust の魅力に感じた点</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">最近は [Rust](https://www.rust-lang.org/) と呼ばれるプログラミング言語を趣味として触っています。[SWC](https://swc.rs/) や [Rome](https://rome.tools/) のように Rust で作成されたフロントエンドツールが増えていることから興味を持ったのですが、実際に触ってみて Rust が高い人気を誇る理由がよく分かるようになりました。 この記事では私が Rust を触ってみて魅力に感じた点を列挙していきます。</div><div class="ui-feed-item__date" title="2022-04-30 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" 
href="https://azukiazusa.dev/blog/start-syntax-checking-with-markuplint"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/start-syntax-checking-with-markuplint">markuplint で構文チェックを始めよう</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">HTML の構文チェックを実施するには適切なツールを導入するのがよいでしょう。この記事では markuplint と呼ばれる HTML の静的解析ツールを紹介します。markuplint は JSX(React),Vue,Svlete のようなテンプレートエンジンにも対応しています。</div><div class="ui-feed-item__date" title="2022-04-23 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/node-js-volta"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" 
href="https://azukiazusa.dev/blog/node-js-volta">Node.js のバージョン管理には Volta がよい</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">皆さん Node.js のバージョン管理ツールには何を使っておりますでしょうか？上記の中でも私がオススメするのは [volta](https://volta.sh/) です。volta は 1.0 がリリースされたのが2020年12月と比較的新しいツールです。</div><div class="ui-feed-item__date" title="2022-04-16 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/Starting--monorepol-with-npm-workspace"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/Starting--monorepol-with-npm-workspace">npm workspace で始めるモノレポ生活</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">workspace は複数のパッケージ（`package.json`）をレポジトリを管理するために使用されます。このようなレポジトリは**モノレポ**として知られています。</div>
<div class="ui-feed-item__date" title="2022-04-09 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/return-await-return"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/return-await-return">君は return と await return の違いを理解して使っているか</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">`Promise` を返す非同期関数を扱う時 `Promise` をそのまま返す書き方と `Promise` を `await` してから返す二通りの方法があります。これらは一見同じように動作するように見えますが異なる点が存在します。</div><div class="ui-feed-item__date" title="2022-04-02 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/import-type-from-module"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256">
</a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/import-type-from-module">import type { ... } from &quot;./module&quot; とは何者何か</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">TypeScript のプロジェクトにおいて `import type { ... } from &quot;./module&quot;` という記述を見たことはないでしょうか？ これは Type-Only imports and export と呼ばれる機能で TypeScript3.8 より導入されました。これは名前の通りモジュールから型情報のみをインポートするために使用されます。これは通常の利用用途ではあまり考慮する必要はないのですが、特定の問題に立ち向かうために利用されることがあります。</div><div class="ui-feed-item__date" title="2022-03-26 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/anonymous-default-export"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/anonymous-default-export">
anonymous default export はやめたほうがいいかもね</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">`anonymous default export` とは名前の通り匿名でデフォルトエクスポートを宣言することです。必ず名前を付与しなければいけない名前付きエクスポートと異なり、以下はすべて有効な構文です。</div><div class="ui-feed-item__date" title="2022-03-19 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/msw-request-assertions"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/msw-request-assertions">msw でリクエストを検証する方法</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">msw 使ってテストを記述した時期待したリクエストが送信されているのか検査したくなるかもしれません。リクエストを検証する方法と、それを回避する方法を紹介します。</div><div class="ui-feed-item__date" title="2022-03-12 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a 
class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/storybook-testing"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/storybook-testing">Storybook 単体でインタラクションテストを実施する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Storybook の Component Story Format 3.0 では新機能として play() 関数が追加されました。 `play()` 関数は Storybook 上で ユーザーのインタラクションな操作を表現することができます。 以前は composeStories() 関数により Storybook 上で作成したストーリーを Jest で再利用する方法を書いたのですが、どうやら Storybook のみで完結してテストを実行することができるようですのでこちらを試してみます。</div><div class="ui-feed-item__date" title="2022-03-05 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/web-rust"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div 
class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/web-rust">Web フロントエンドエンジニアなら当然 Rust も書けますよね？？</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">本記事では Yew を利用して Web アプリケーションを作成してみたいと思います。Yew は React や Vue などと同じくコンポーネントベースのフレームワークでインタラクティブな UI を作成できます。</div><div class="ui-feed-item__date" title="2022-02-26 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/v-for-key-as-index"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/v-for-key-as-index">Q：v-for の key に 配列のインデックスを使うのは犯罪ですか？#Shorts</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
結論： - `v-for` ディレクティブに渡す配列要素が決して変わらないことがわかっているのであれば使っても良い。 - `id` 属性を持っているのであれば常に `id` 属性を `key` に使用するべき。</div><div class="ui-feed-item__date" title="2022-02-19 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/q-typescript-shorts"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/q-typescript-shorts">Q：TypeScript の関数の返り値の型を明示的に書かないのは犯罪ですか？#Shorts</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">TypeScript において関数の返り値の型は推論させることは可能ですが、これはコードベース全体に意図しない型の変更による影響が広がる可能性があります。</div><div class="ui-feed-item__date" title="2022-02-12 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/node-js-fetch"><img 
src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/node-js-fetch">Node.js に fetch がやってきた</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Node.js で fetch が使えるようになる</div><div class="ui-feed-item__date" title="2022-02-05 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/vue-a11y-testing"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/vue-a11y-testing">アクセシビリティを自動で検査する仕組みを整える</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">様々な方法でアクセシビリティを自動で検査します</div><div class="ui-feed-item__date" 
title="2022-01-29 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/compose-storybook-interaction-testing-jest"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/compose-storybook-interaction-testing-jest">Storybook の interaction testing と jest を組み合わせる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Storybook の Component Story Format 3.0 では新機能として `play()` 関数が追加されました。 `play()` 関数は Storybook 上で ユーザーのクリックやフォーム入力のようなインタラクションな操作を表現することができます。 `play()` 関数の大きな特徴としては Component Story Format の移植性の高さを利用して Storybook 上で定義したインタラクションを `Jest` など他の領域においても再利用できることです。</div><div class="ui-feed-item__date" title="2022-01-22 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" 
href="https://azukiazusa.dev/blog/vite-require"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/vite-require">Vite だと require() が使えないよ〜</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">皆様はすでにプロジェクトに Vite は導入されていらっしゃいますでしょうか？私はできていません。 Vite はフロントエンドのビルディングツールであり、従来の Webpack 等と比較して高速に動作するといった特徴があります。Vue.js を開発した Evan You 氏によって開発ツールではありますが Vue.js に限らず React や Svelte にも対応しています。</div><div class="ui-feed-item__date" title="2022-01-15 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/using-msw-to-mock-front-end-tests-seems-to-be-the-latest-trend"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a 
class="ui-feed-item__title" href="https://azukiazusa.dev/blog/using-msw-to-mock-front-end-tests-seems-to-be-the-latest-trend">フロントエンドのテストのモックには msw を使うのが最近の流行りらしい</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">最近のテスト手法として API コールをモックする際に Jest ではなく [Mock Service Worker](https://mswjs.io/) (以下 `msw` ）を使用する手法が注目されています。実施にどのように使用されているのか見ていきましょう。</div><div class="ui-feed-item__date" title="2022-01-08 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/vue-js-ref-vs-reactive"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/vue-js-ref-vs-reactive">【Vue.js】ref vs reactive</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
さて、そんな Compositon API ですがリアクティブなデータを定義する際に `reactive` と `ref` の2つの方法が用意されています。 `reactive` と `ref` どちらを使用するのがよいのか公式からも推奨する方法がありませんので、どちらを使用するべきか迷ってしまうところです。 `reactive` と `ref` のそれぞれのメリット・デメリットを確認してみましょう。</div><div class="ui-feed-item__date" title="2022-01-01 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/testingframework-vitest"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/testingframework-vitest">Vitest と呼ばれるテスティングフレームワークがめちゃくちゃ早いらしいな</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Vitest は Vite ベースの JavaScript のテスティングフレームワークです。</div><div class="ui-feed-item__date" title="2021-12-25 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" 
href="https://azukiazusa.dev/blog/vuetify-3-alpha-mejar-changes"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/vuetify-3-alpha-mejar-changes">Vuetify 3 Alpha の主な変更点</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">[Vuetify](https://vuetifyjs.com/) は Vue.js で多く使われている UI コンポーネントです。現在のバージョンは Vue 3 には対応していません。 現在 Vue 3 に対応する Alpha 版の Vuetify 3 が公開されています。開発スケジュールは以下のとおりになっています。</div><div class="ui-feed-item__date" title="2021-12-18 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/nuxt3-new-features"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" 
href="https://azukiazusa.dev/blog/nuxt3-new-features">Nuxt3 の新しい機能いろいろ</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">現在 Nuxt.js は バージョン3がパブリックベータ版として提供されています。 Nuxt.js が 2 → 3 に移行するにあたってたくさんの新機能が追加されました。</div><div class="ui-feed-item__date" title="2021-12-11 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/css-print-style"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/css-print-style">CSS で印刷用のスタイルを設定できる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
大抵のブラウザでは Web ページを印刷することができます。 しかし Web ページをそのまま印刷しようとすると改ページがおかしくなったりレイアウトがおかしくなってしまうことがあるでしょう。そもそも Web ページはディスプレイで表示することを目的としているので印刷には不向きなものです。 とはいえ Web ページを印刷したいというニーズは少なからずあるとは思います、そのようば場合には `@media print` などのような印刷用の CSS を利用することで見た目を整えることができます</div><div class="ui-feed-item__date" title="2021-12-04 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/fucus-trap-accessible-modal"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/fucus-trap-accessible-modal">フォーカストラップとは? 〜アクセシブルなモーダル〜</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">フォーカストラップ(またはループ)とは、ウェブページをキーボードで操作する際にフォーカスをとある領域からはみ出さないようにすることです。フォーカス可能な要素を抽出してその中をループすることで実現ができます。 登場シーンとしてはモーダルで使われることが多いです。実際に例を交えて確認してみましょう。</div><div 
class="ui-feed-item__date" title="2021-11-27 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/webpack5-module-federation"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/webpack5-module-federation">Webpack5 Module Federation ではじめるマイクロフロントエンド</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Webpack5 の Module Federation を使用してマイクロフロントエンドを作成します。</div><div class="ui-feed-item__date" title="2021-11-20 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/youtube-trick"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a 
class="ui-feed-item__title" href="https://azukiazusa.dev/blog/youtube-trick">Youtube すごい裏ワザ！！！</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Tab キーでページを操作した時のみ表示される「ナビゲーションをスキップ」は一般にスキップリンクと呼ばれるものであり、ウェブアクセシビリティのガイドライン (W3C 勧告) である WCAG 2.0にあるブロックスキップと呼ばれる達成基準を達成する方法として上げられています。</div><div class="ui-feed-item__date" title="2021-11-13 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/npm-coa-rc-embded-malware"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/npm-coa-rc-embded-malware">npm の人気パッケージ 「coa」と「rc」にマルウェアが埋め込まれた</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
2021/11/5 npm パッケージ 「coa」と「rc」がハイジャックされ、パスワードを盗むマルウェアが埋め込まれました。現在の時点では問題のあったバージョンはすべて取り除かれています。</div><div class="ui-feed-item__date" title="2021-11-06 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/css-box-model"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/css-box-model">ボックスモデル</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">CSS にはボックスという概念があります。ブラウザは文書をレイアウトする際に、それぞれの要素を CSS のボックスモデルに基づいた長方形の箱（ボックス）として表現します。つまりは、HTMLの個々の要素はすべてボックスにからできており、それらのボックスが組み合わさることによってページ全体が表現されます。 ボックスは CSS において最も基本的な概念であり、ボックスを理解することは CSS でレイアウトを構成したり要素同士を揃えるための手助けとなることでしょう。</div><div class="ui-feed-item__date" title="2021-10-30 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a 
class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/typescript-type-challenges"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/typescript-type-challenges">【TypeScript】type-challenges 中級編</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">[type-challengs](https://github.com/type-challenges/type-challenges) の medium レベルをやります。</div><div class="ui-feed-item__date" title="2021-10-23 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/typescript-type-challenges-advanced-types"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" 
href="https://azukiazusa.dev/blog/typescript-type-challenges-advanced-types">【TypeScript】type-challenges で学ぶ高度な型</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">type-challengesを知っていますか？ これは TypeScript の型についての問題集で、問題文の条件を満たす独自のユーティリティ型を作るチャレンジです。いわゆる「型パズル」ってやつですね。 問題の回答はPlayground上で行えるので実際に手を動かしながら問題を解くことができます。型パズルを通じてTypeScript の高度な型について学んでいきましょう。</div><div class="ui-feed-item__date" title="2021-10-16 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/lodash-es-lodash"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/lodash-es-lodash">lodash-es lodash 違い</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
[lodash-es](https://www.npmjs.com/package/lodash-es) とは [lodash](https://lodash.com/) を `ES module` 形式で提供しているライブラリです。</div><div class="ui-feed-item__date" title="2021-10-09 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/q-typescript-readonly-shorts"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/q-typescript-readonly-shorts">Q: TypeScript を使っているのに関数の引数のオブジェクトや配列に `readonly` を付与しないのは犯罪ですか？ #Shorts</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">質問来てた👉 Q: TypeScript を使っているのに関数の引数のオブジェクトや配列に `readonly` を付与しないのは犯罪ですか？ 結論：犯罪になる場合がある。 まず、配列の引数に `readonly` を付与しておけば以下の利点を得られます。 - うっかり関数の内部で引数の値を変更してしまうコードを書いてしまったときにコンパイルエラーが得られる - 関数の利用者が安心して関数を呼び出せる</div><div class="ui-feed-item__date" 
title="2021-10-02 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/vue-js-script-setup"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/vue-js-script-setup">【Vue.js】script setup 構文がすごくすごい</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Vue.js 3.x から script setup 構文が使えるようになりました。これは単一ファイルコンポーネント(SFC)内で Composition API を使用している際に使える糖衣構文です。下記のようなメリットを得ることができ、公式からも使用が推奨されています。</div><div class="ui-feed-item__date" title="2021-09-25 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/vuex-5"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content">
<a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/vuex-5">Vuex 5 でどのように変わるのか。</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">現在リリースされている最新のバージョンは Vuex 4 です。 これは Vuex 3 と互換性のあるバージョンで Vue 3 で使用するためのものであり、 Vuex 3 と同じ API となっています。 Vuex 5 は Vue 3 において Composition API による Reactivity API が登場したことにより Reactivitty API によってどのように Vuex をどうさせるか再考されたバージョンとなっています。</div><div class="ui-feed-item__date" title="2021-09-25 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/vue3-2-style-javascript"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/vue3-2-style-javascript">【Vue3.2】styleタグ内でJavaScript変数をバインドできる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
Vue.js3.2からは、JavaScriptの変数をCSS変数としてバインドできるようになりました。 つまりは、CSSの値を動的に設定できるということです。 ものは試しのやってみましょう。</div><div class="ui-feed-item__date" title="2021-09-18 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/vue2-vue3"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/vue2-vue3">Vue2のプロジェクトをVue3へマイグレーションsする</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Vue 3が正式リリースされてから約1年が経過しました。 Vuetifyのリリース目標である2021年Q3も近づく中でそろそろVue3へのアップデートを検討されている方もいらっしゃることでしょうか？ この記事ではVue 2からVue 3への移行手順を記述していきます。</div><div class="ui-feed-item__date" title="2021-09-11 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/vue-js-mixin"><img 
src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/vue-js-mixin">【Vue.js】Mixinを使うのはもうやめよう</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">禁止まで言ってしまうとなんだか強い言葉のように聞こえてしまいますが、mixinは基本的にあまり良いアプローチとは考えられません。 実際に、Reactにも過去にはMixinが存在していましたが現在は廃止されています。</div><div class="ui-feed-item__date" title="2021-09-04 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/axios"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/axios">あの日見たaxiosの機能を僕達はまだ知らない。</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
axiosは、JavaScriptにおけるHTTPクライアントのデファクトスタンダードといえるでしょう。 Promiseベースで非同期通信を行えるHTTPクライアントとして、ブラウザ標準のfatchやjQuery.ajaxなどがありますが、特にaxiosがよく使われているのには豊富なオプションや設定に理由付けられるでしょう。 axiosの機能について私のように詳しくなくても直感的にHTTPリクエストを送れるのも良い点の1つですが、せっかくなのでaxiosでどのようなことができるのがを見ていきましょう。</div><div class="ui-feed-item__date" title="2021-08-28 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/vuetify-theme-css-variables"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/vuetify-theme-css-variables">VuetifyのテーマをCSS変数として使用する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">VuetifyのテーマをCSSの変数として生成して使用します。</div><div class="ui-feed-item__date" title="2021-08-21 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a 
class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/jsdoc-typescript"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/jsdoc-typescript">青春JSDocはTypeScript先輩の夢を見ない</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">時には、TypeScriptという概念が存在しない退屈な世界で開発を行わなけらばならない状況はあるでしょう。私はもはやキーボードでタイピングすることすらままなりません。 そんなJavaScriptしか利用できない状況で代替手段となるのが、JSDocです。JSDocのアノテーションによって型を付与することによって最低限の支援を受けることができます。</div><div class="ui-feed-item__date" title="2021-08-14 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/typescript-dry-type-definition"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a 
class="ui-feed-item__title" href="https://azukiazusa.dev/blog/typescript-dry-type-definition">【TypeScript】型定義をする際にもDRY原則を守る</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">DRY原則は非常に有名な原則ですし、普段から特に考えずとも自然と重複をさけるようなコードを書いている方も多いことでしょう。 とはいえ、TypeScriptにおいて`interface`や`type`などを用いて型定義を行う際に重複した型定義を行ってしまうことはないでしょうか？ TypeScriptには型定義をする際に重複を抑える手段は確かに存在します。そのようないくつかの方法を紹介します。</div><div class="ui-feed-item__date" title="2021-08-07 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/jest-timer-test"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/jest-timer-test">Jest setTimeout()のようなでタイマー関数をテストする</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
JavaScriptには、setTimeout()のような時間に関する便利な機能が用意されています。しかし、これらの関数はユニットテストを記述する際に厄介です。Jestのタイマーモックはこのような場合に利用できる便利な機能です。</div><div class="ui-feed-item__date" title="2021-07-31 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/typescript-type-annotation-vs-type-assetion"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/typescript-type-annotation-vs-type-assetion">【TypeScript】型アノテーションと型アサーションの違い</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">型アノテーションと型アサーションによる変数宣言は、一見同じ結果をもたらすように見えます。しかし、型アサーションには明確な欠点が存在します。</div><div class="ui-feed-item__date" title="2021-07-23 15:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" 
href="https://azukiazusa.dev/blog/mongoose-group-by-hour-count"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/mongoose-group-by-hour-count">【mongoose】日付のカラムで時間ごとにグループ化してドキュメント数をカウントする</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">タイトルのとおりです</div><div class="ui-feed-item__date" title="2021-07-17 15:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/mongoose-cannot-overwrite-model-model-once-compiled-error-handling"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/mongoose-cannot-overwrite-model-model-once-compiled-error-handling">
【mongoose】Cannot overwrite &#39;Model&#39; model once compiled. エラーの直し方</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">mongooseで遭遇するCannot overwrite &#39;Model&#39; model once compiled. エラーの解消方法です</div><div class="ui-feed-item__date" title="2021-07-10 15:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/json-object"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/json-object">JSONオブジェクトのあれこれ</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">`JSON`オブジェクトはJavaScriptにおいて、JSONをパースしたり値をJSONに変換するためにもっぱら使われます。 普段使っている`JSON.stringify()`や`JSON.parse()`にはオプショナルな引数を渡すことによってその振る舞いを変更することができます。</div><div class="ui-feed-item__date" title="2021-07-03 15:00:00">5年前
</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/javascript-object"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/javascript-object">【JavaScript】Objectがプリミティブに変換されるとき</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">JavaScriptがプリミティブな値に変換されるとき、string型に変換されようとするか、number型に変換されようとするかで挙動が変化する</div><div class="ui-feed-item__date" title="2021-06-26 15:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/react-errorboundary"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" 
href="https://azukiazusa.dev/blog/react-errorboundary">ReactのErrorBoundaryで内部のエラーをキャッチする</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Error Boundaryとは、自身の子コンポーネントツリーで発生したJavaScriptのエラーをキャッチ・記録しフォールバックのUIを表示するコンポーネントです。 例えるなら、`try/catch`構文を行うコンポーネントのようなものと言えます。</div><div class="ui-feed-item__date" title="2021-06-19 15:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/useful-minor-html5"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/useful-minor-html5">仕事で役に立つかもしれないHTML5のマイナー要素</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
HTMLは書いたことがありますか？プログラミング初心者が最初の一歩として書き出すのに好まれる言語ですが、セマンティクスを追求すると奥深い言語だとわかります。タグの種類も数多くあり、全てを把握している人はそう多くなないでしょう。 今回は、そんなHTMLの普段の仕事では余り見かけないであろう要素を紹介していきます。</div><div class="ui-feed-item__date" title="2021-06-12 15:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/nuxt-sentry-user-feedback"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/nuxt-sentry-user-feedback">Nuxt Sentryでユーザーフィードバックを受け取る</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Sentryでは、エラーが発生した際に簡単にユーザーフォードバックを求めるダイアログを表示することができます。 Nuxt.jsでは、エラーが発生した際には`layouts/error.vue`へ遷移させることでエラーページを表示するので、このエラーコンポーネントにダイアログを表示させる処理を書いていきます。</div><div class="ui-feed-item__date" title="2021-06-05 15:00:00">5年前</div></div></div><div class="ui-feed-item">
<a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/node-js-express-csv"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/node-js-express-csv">Node.js(Express)でcsvを生成してダウンロード</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Node.js(Express)でCSVファイルを生成してダウンロードさせます。</div><div class="ui-feed-item__date" title="2021-05-29 15:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/also-passed-ckad"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/also-passed-ckad">CKADにも合格した</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div>
<div class="ui-feed-item__summary">開発者向けのK8sの試験であるCKADにも合格したので同様に合格体験記を記載したいと思います。 といっても、大枠の部分はCKAのときとあまり変わらないのでCKAと異なる部分を中心に記載したいと思います。</div><div class="ui-feed-item__date" title="2021-05-22 15:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/vue-cli-vite"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/vue-cli-vite">Vue CLIで作成したプロジェクトをViteに置き換える</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Viteは、一言でいうとフロントエンドのめっちゃ早いビルドツールです。Vue CLIで作成したプロジェクトをViteに置き換えるためにvue-cli-plugin-viteをというプラグインを使います。</div><div class="ui-feed-item__date" title="2021-05-15 15:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/kubernetes-apiversion"><img 
src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/kubernetes-apiversion">KubernetesのapiVersion</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Kubernetesのマニフェストを作成するときには、`apiVersion`フィールドを指定する必要があります。 例えば`Pod`の場合には`v1`を、`Deployment`の場合には`apps/v1`を指定しますが、これらはどのようなルールで記述するのでしょうか。</div><div class="ui-feed-item__date" title="2021-05-08 15:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/etcd-backup-restore"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/etcd-backup-restore">etcdのバックアップとリストア</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2
</div><div class="ui-feed-item__summary">etcdは、kubernetesのクラスターの情報を保存するkey-valueストアです。</div><div class="ui-feed-item__date" title="2021-05-01 15:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/kubectl-jsonpath"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/kubectl-jsonpath">kubectl JSONpath</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">kubectlはアウトプットの形式としてJSONPathをサポートしています。</div><div class="ui-feed-item__date" title="2021-04-24 15:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/vue-js-for-ie11"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div 
class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/vue-js-for-ie11">Vue.jsでIE11対応</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">人生でときにはIE11に対応させなければいけない時があるでしょう。Vue.jsでIE11に対応しなけらばいけなくなったときに読むものを記載しておきます。</div><div class="ui-feed-item__date" title="2021-04-17 15:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/e2e-cypress"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/e2e-cypress">e2eテスティングフレームワークCypress</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Cypressは、JavaScript製のE2Eテスティングフレームワークです。 実行速度が早い、HTTPリクエストの実行を待つなどテストが壊れにくい仕組みが整っています</div><div class="ui-feed-item__date" title="2021-04-10 15:00:00">5年前
</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/kubernetes-tips"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/kubernetes-tips">Kubernetes Tips</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">知っていると時間を短縮できるようなkubectlコマンドのtipsです。</div><div class="ui-feed-item__date" title="2021-04-03 15:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/basic-sass-syntax"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/basic-sass-syntax">Sassの基礎文法</a><div class="ui-feed-item__blog-title">
azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">SassはCSSのメタ言語です。CSSに比べてコード量が減り、保守性が優れるといった開発体験を向上させてくれる特徴があります。</div><div class="ui-feed-item__date" title="2021-03-27 15:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/what-is-kustomize"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/what-is-kustomize">Kustomizeとは</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Kustomizeとは、Kuberbetsコミュニティのsig-cliが提供しているマニフェストのテンプレーティングツールです。環境ごとにマニフェストを生成したり特定のフィールドを上書きするといった機能が提供されています。</div><div class="ui-feed-item__date" title="2021-03-20 15:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/kubernetes-helm"><img 
src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/kubernetes-helm">KubernetesのパッケージマネージャーHelm</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Helmは、Kubernetsのパッケージマネージャーです。 例えば、npmを利用して第三者が作成したパッケージをレポジトリで管理して検索・インストールするように、Helmではチャート(Chart)と呼ばれる設定ファイルをレポジトリで管理しています。</div><div class="ui-feed-item__date" title="2021-03-13 15:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/kubernetes-glossary"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/kubernetes-glossary">Kubernetes用語集</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div 
class="ui-feed-item__summary">仕事上kubernetesを学ぶ必要が出てきました。 筆者のレベルは、Docker・kubernetesの概念・必要性をやんわりと理解している状態です。 勉強をすすめる上で、わからない用語が次々と出てきたて頭の中がパンクしそうになったので、簡潔に随時まとめることとしました。</div><div class="ui-feed-item__date" title="2021-03-06 15:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/deno-rest-api"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/deno-rest-api">DenoでREST API</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">この記事では、Denoを使い簡単なCRUD操作を行うREST APIを構築します。</div><div class="ui-feed-item__date" title="2021-02-27 15:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/tailwindcss-dark-mode"><img src="../../images/alternate-feed-image.png" 
alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/tailwindcss-dark-mode">TailwindCSSでダークモード</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">昨今のアプリケーションでは、ダークモードを提供しているのがもはや当たり前になってきました。 OSのレベルでダークモードを設定することができ、ダークモードが提供されていないサイトは眩しく感じしてしまって敬遠してしまうなんて経験はあるのではないでしょうか？ そんな一般化されたダークモードの提供をTailwind CSSで実装します。</div><div class="ui-feed-item__date" title="2021-02-20 15:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/what-is-graphql"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/what-is-graphql">はじめてのGraphQL</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div 
class="ui-feed-item__summary">GraphQLとは、Facebookが開発したAPI向けのクエリ言語です。RESTに変わるサーバーとクライアントの通信手段として注目を集めています。 リクエスト・レスポンスの型の定義ができる、フロント側から取得するデータを選択することができるなどの特徴があります。 GraphQL自体はSQLのようなクエリ言語としての位置づけなので、Java、Node.js、Ruby、JavaScript、Pythonなど様々な言語で利用することができます。</div><div class="ui-feed-item__date" title="2021-02-16 15:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/sapper-contentful-vercel-jamstack-blog"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/sapper-contentful-vercel-jamstack-blog">Sapper + contentful + VercelのJamstackで高速なブログを構築する</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
JamstackのJamはJavaScript/APIs/Markupの頭文字です。 従来の手法と比較して、高速化・堅牢なセキュリティ。より簡単なスケーラブル・開発体験の向上という特徴を持っています。実行時にAPIから取得したデータを動的にレンダリングせずに、ビルド時にAPIから取得して静的なHTMLとして出力されます。</div><div class="ui-feed-item__date" title="2021-02-13 15:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/svelte-typescript-tailwindcss-book-search-app-tutorial"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/svelte-typescript-tailwindcss-book-search-app-tutorial">【Svelte + TypeScript + tailwindcss】本検索サイト チュートリアル</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">この記事でははSvelte + TypeScript + tailwindcssで本検索サイトを作成します。 Svelteを使ってアプリケーションを作成1から作成することができます。 以下のことが学べます。 - Svelteの基礎文法 - Svelteのルーティング - Svelteのストア HTML・CSS・JavaScriptの基礎的な理解がある人が対象です。
</div><div class="ui-feed-item__date" title="2021-02-06 15:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/vue3-test-components"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/vue3-test-components">Vue3 コンポーネントのテスト</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">コンポーネントのテストをするのフレームワークとしてJest、vue-test-utils 2を利用します。Vue2系をターゲットにしているvue-test-utils 1とは一部APIが異なります。</div><div class="ui-feed-item__date" title="2021-02-02 15:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/what-is-tailwindcss"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div 
class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/what-is-tailwindcss">TailWindCSSとは</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">TailWindCSSはBootStrap・Materialize CSSなどに代表するCSSフレームワークの一つです。 その特徴として、**Utility First**を掲げています。</div><div class="ui-feed-item__date" title="2021-01-30 15:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/what-is-svelte"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/what-is-svelte">JavaScriptライブラリ Svelteとは</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
Svelteとは、ReactやVue.jsのような宣言的UIライブラリの一種です。その最大の特徴は、ReactやVue.js・Angularと異なりSvelteはコンパイラであることを謳っているところです。Svelteによってコンパイルされたコードは、すべてVanilla JS - ネイティブのJavaScript- にで生成されます。 そのため、コンパイル後のファイルサイズも小さくパフォーマンス上での利点が期待されています。</div><div class="ui-feed-item__date" title="2021-01-23 15:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/firebase-functions-https-oncall"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/firebase-functions-https-oncall">Firebase Functions https.onCall()トリガーでアプリから簡単に呼び出す</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
Firebase Functionsとは、Firebaseの提供するサーバレスフレームワークです。HTTPSリクエストによって関数を実行したり、FireStore・Cloud Storage・AuthenticationのCRUDイベントをトリガーに関数を実行することができます。使用できる言語はJavaScript・TypeScriptに限られているというデメリットはあるものの、手軽にデプロイでき簡単にプロジェクトの他のFirebaseの機能と統合できるメリットがあります。</div><div class="ui-feed-item__date" title="2021-01-09 15:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/jest-mock"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/jest-mock">JavaScript テストフレームワークのJestのモックがすごくすごい</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Jestは、JavaScriptのシンプルなテスティングフレームワークです。ゼロコンフィグを謳っており、細かい設定なしに動作させることが可能です。 Jestの中でも特に強力な機能がモッキングです。Jestのモックを利用すれば、外部ライブラリであろうとモジュール外のオブジェクトを簡単にモック化することができます。 実際に、テストコードの例を見ていきましょう。</div><div 
class="ui-feed-item__date" title="2020-12-15 15:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/vue-js-composition-api-todo-app"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/vue-js-composition-api-todo-app">Vue.js Composition APIでTODOアプリ作成</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Vue3 Composition APIを使って、ハンズオン形式でTODOアプリを作成していきます。</div><div class="ui-feed-item__date" title="2020-12-12 15:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/how-to-write-javascript-in-the-modern-world"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div 
class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/how-to-write-javascript-in-the-modern-world">イマドキのJavaScriptの書き方</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">JavaScriptはES2015以降から言語自体が大きく変化しました。 ES2015以降も、毎年JavaScriptはアップデートが行われており、最新の使用はES2020となっています。 このように、JavaScriptという言語は日々進化を遂げています。ES2015より前の書き方の多くが非推奨となっており、過去のWebや本の情報は現在ではあまり役に立たなくなっています。 そんなJavaScriptのイマドキの書き方を見ていきましょう。</div><div class="ui-feed-item__date" title="2020-12-04 15:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/javascript-array-operations"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/javascript-array-operations">すぐに使える！JavaScriptの華麗な配列操作</a><div class="ui-feed-item__blog-title">
azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">JavaScriptで配列操作をする際には、まずはJavascriptが持つ配列のメソッドを眺めて見るとよいでしょう。JavaScriptはライブラリに頼らなくとも自前で高度な操作を可能にしてくれます。 組み込みの配列メソッドはたくさんありますが、その中で私がよく使うメソッドを紹介します。</div><div class="ui-feed-item__date" title="2020-11-28 15:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/go-test"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/go-test">Go言語 テスト</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Go言語の提供するテストはシンプルです。テストのために覚えることは多くはありません。 Go言語の単体テスト用の機能は`testing`という標準パッケージとして提供されています。ベンチマークやカバレッジ、標準出力のテストなどをカバーしています。 また、テストは`go test`コマンドによって実行されます。サードパーティのツールなどは必要ありません。まずはこの`testing`パッケージの内容を見ていきます。</div><div class="ui-feed-item__date" title="2020-11-14 15:00:00">5年前
</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/go-http"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/go-http">Go 言語　標準パッケージでHTTPサーバー</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Go言語は、標準パッケージでHTTPサーバーと基本的なHTTPクライアントを提供します。 使用するのは、net/httpというパッケージです。</div><div class="ui-feed-item__date" title="2020-11-07 15:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/go-pointer"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/go-pointer">Go言語 ポインター</a><div 
class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Go言語には、ポインタがあります。 ポインタとは、メモリのアドレスのことです。アドレスは`0xc0000b4008`のような16進数で表されます。</div><div class="ui-feed-item__date" title="2020-10-31 15:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/go-struct-interface"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/go-struct-interface">Go言語 構造体・インターフェース</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">構造体(Struct)とは、フィールドの集まりです。JavaScriptのオブジェクトよく似ており、データをまとめて1つの集まりの値として表現します。 例えば、座標を表すには緯度と経度がフィールドとして必要になるでしょう。緯度と経度をそれぞれ別の変数として宣言することはできますが、間違いが生じやすく面倒な処理になってしまいます。</div><div class="ui-feed-item__date" title="2020-10-24 15:00:00">5年前</div></div></div><div class="ui-feed-item"><a 
class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/go-collection"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/go-collection">Go言語　コレクション（配列・スライス・マップ）</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">配列は決まった長さを持つ要素を並べた順序のあるコレクションです。 Go言語の配列は固定長になっており、宣言時に長さと要素型を指定します。 長さは後から変更することはできません。 Go言語の配列は柔軟性に欠けるため、実際にはあまり使用されません。可変長であるスライスがよく使われます。 マップはキーと値によって宣言されます。これは、連想配列のようなものです。</div><div class="ui-feed-item__date" title="2020-10-17 15:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/go-type-function-method"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" 
href="https://azukiazusa.dev/blog/go-type-function-method">Go言語　型・関数・メソッド</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Go言語は静的型付け言語であり、全ての変数は何らかの型に属し、異なる型同士の演算といった問題点の多くはコンパイル時に検出されます。 関数の宣言にはfuncキーワードを使用します。関数の引数と戻り値には型を指定します。戻り値を複数持たせられる、戻り値に名前をつけることができるといった特徴があります。 クラスやオブジェクトはないですが、メソッドはあります。メソッドは型に紐付けられます。</div><div class="ui-feed-item__date" title="2020-10-03 15:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/what-is-go"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/what-is-go">Go言語基礎文法</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
Go言語(Golang）は、2009年にGoogleによって開発されたオープンソースの静的型付け、コンパイルされるプログラミング言語です。Go言語はコンパイルされるプログラミング言語です。 Go言語はシンプルで、信頼性が高く、効果的なソフトウェアを構築します。</div><div class="ui-feed-item__date" title="2020-09-26 15:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/css-design"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/css-design">CSSの設計</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">今この文章を読んでいる人ならば、少なくともCSSには触れたことがあると思います。CSSはとても簡単に記述できますが、それゆえにCSSは「壊れやすい」のです。なぜCSSは壊れやすくなってしまうのでしょうか。CSSには「すべてがグローバルスコープ」「複雑化するWeb開発」といった問題点があげられます。そのような状態に対する解決策として、CSSの設計が誕生しました。</div><div class="ui-feed-item__date" title="2020-09-12 15:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" 
href="https://azukiazusa.dev/blog/express-typescript-mondodb"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/express-typescript-mondodb">Express + TypeScript + MondoDBでやる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Expressは、Node.jsのWebアプリケーションでもっとも利用されているフレームワークです。Expressは、HTTPによるWeb上の相互作用とNOde.jsプラットフォームの中間に位置するので、ある種のミドルウェアと言えます。 Expressを利用して、MVCモデルのアプリケーションを開発してみます。 データベースにはMongoDBを利用し、さらにTypeScriptで書いてみます。</div><div class="ui-feed-item__date" title="2020-06-13 15:00:00">6年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/node-js"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a 
class="ui-feed-item__title" href="https://azukiazusa.dev/blog/node-js">Node.js - サーバーサイドのJavaScript</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Node.jsは、V8 Javascriptエンジン上に構築されたJavaScriptの実行環境です。サーバーサイドのJavaScript環境であり、非同期、イベント駆動といった特徴があります。</div><div class="ui-feed-item__date" title="2020-06-06 15:00:00">6年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/firebase-cloud-firestore-query"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/firebase-cloud-firestore-query">Firebase④ Cloud FireStore - クエリ</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Firebase4回目の記事です。 前回は、Firebaseにおける単一のドキュメントに対するCRUD操作までを取り扱いました。 今回は複数のコレクションから取得するためのクエリについて説明していきます。</div><div 
class="ui-feed-item__date" title="2020-05-23 15:00:00">6年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/what-is-deno"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/what-is-deno">Denoとはなにか - 実際に使ってみる</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Denoは、Node.jsの製作者であるRyan Dahlによって作られた、新しいJS/TSランタイムです。簡単に説明すると、Node.jsのイケてなかったところを改良したものがDenoになります。</div><div class="ui-feed-item__date" title="2020-05-16 15:00:00">6年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/firebase-cloud-storage"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a 
class="ui-feed-item__title" href="https://azukiazusa.dev/blog/firebase-cloud-storage">Firebase③ Cloud Storage</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Firebase3週目の記事です。 今回は、主に画像などのデータを保存するストレージ機能を提供するCloud Storageを取り扱います。 Vue.jsを利用したブログにサムネイル画像を設定する機能をもとに説明していきます。</div><div class="ui-feed-item__date" title="2020-05-02 15:00:00">6年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/javascript-ecmascript-babel"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/javascript-ecmascript-babel">JavaScript ECMAScriptとかBabelとか</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">JavaScript ECMAScriptとかBabelとか</div><div class="ui-feed-item__date" 
title="2020-04-30 15:00:00">6年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/firebase-cloud-firestore"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/firebase-cloud-firestore">Firebase④ Cloud FireStore</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Cloud FireStore(以下FireStore)とは、FireBaseの提供するドキュメント指向型 のNoSQLデータベースです。 NoSQLとしての特徴としてのスキーマレス、スケーラブルといった特徴のほかにリアルタイムアップデート、セキュリティルール、オフラインサポートといった独自の特徴を備えており、特にバックエンドを介さずにクライントサイドから直接操作できるという点が大きなポイントです。 また、β版から正式リリースされたのが2019年2月ということもあり、比較的新しい技術です。</div><div class="ui-feed-item__date" title="2020-04-25 15:00:00">6年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/firebase-firebase-authentication"><img 
src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/firebase-firebase-authentication">Firebase② Firebase Authentication</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">Firebase第二弾です。 Firebase Authenticationのメールアドレスによるログインと、FireStorageについて説明していきます。</div><div class="ui-feed-item__date" title="2020-04-18 15:00:00">6年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://azukiazusa.dev/blog/what-is-firebase"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://azukiazusa.dev/blog/what-is-firebase">firebaseとは</a><div class="ui-feed-item__blog-title">azukiazusa のテックブログ2</div><div class="ui-feed-item__summary">
Firebaseは、Googleが提供するバックエンドサービスです。 Firebaseは、バックエンドのサービスを担ってくれるので、開発者はアプリケーションの開発に専念することができ、バックエンドで動くサービスを作成、管理する必要はありません。 そのため、素早くアプリケーションをリリースるることができます。 Firebaseは、iOS/AndroidアプリからWebサービスまで幅広く使えます。 認証、データベース、ストレージなどたくさんの機能が使用できます。</div><div class="ui-feed-item__date" title="2020-04-11 15:00:00">6年前</div></div></div></div></div></section></main><footer role="contentinfo" class="ui-section-footer"><div class="ui-layout-container"><div class="ui-layout-column-6 ui-layout-column-center"><div class="ui-component-cta ui-layout-flex ui-section-footer__site-info"><p class="ui-text-note">このサイトは<br>記事を読んでその企業の技術・カルチャーを知れることや<br>質の高い技術情報を得られることを目的としています。</p><p class="ui-text-note">追加したいブログがある場合は<br><a href="https://github.com/jser/watch-list-rss#%E3%82%B5%E3%82%A4%E3%83%88%E3%81%AE%E8%BF%BD%E5%8A%A0%E6%96%B9%E6%B3%95" target="_blank">サイトの追加方法</a> をご参照ください。</p></div></div></div><div class="ui-layout-container"><div class="ui-section-footer__layout ui-layout-flex"><p 
class="ui-section-footer--copyright ui-text-note"><a class="ui-text-note" href="https://github.com/jser/" target="_blank"><small>@jser</small></a></p><a href="https://github.com/jser/watch-list-rss/" role="link" aria-label="#" class="ui-text-note" target="_blank"><small>GitHub</small></a></div></div></footer></body></html>