<!doctype html><html lang="ja"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="JSer.infoの情報源となるサイトのRSSフィードをまとめたサイトです。JavaScriptの情報源を集めることを目的としています。"><meta name="author" content="jser"><meta name="robots" content="index, follow"><meta property="og:url" content="https://jser.info/watch-list-rss/"><meta property="og:title" content="Object.create(null)のフィード｜JSer.info Watch List RSS"><meta property="og:image" content="https://jser.info/watch-list-rss/images/og-image.png"><meta property="og:description" content="JSer.infoの情報源となるサイトのRSSフィードをまとめたサイトです。JavaScriptの情報源を集めることを目的としています。"><meta property="og:type" content="website"><meta property="og:site_name" content="JSer.info Watch List RSS"><meta property="og:locale" content="ja_JP"><meta name="twitter:card" content="summary"><meta property="twitter:domain" content="https://jser.info/watch-list-rss/"><meta property="twitter:url" 
content="https://jser.info/watch-list-rss/"><meta name="twitter:title" content="Object.create(null)のフィード｜JSer.info Watch List RSS"><meta name="twitter:description" content="JSer.infoの情報源となるサイトのRSSフィードをまとめたサイトです。JavaScriptの情報源を集めることを目的としています。"><meta name="twitter:image" content="https://jser.info/watch-list-rss/images/og-image.png"><meta name="thumbnail" content="https://jser.info/watch-list-rss/images/og-image.png"><link rel="preload" href="../../styles/bundle.css" as="style"><link rel="shortcut icon" href="../../images/favicon.ico"><link rel="apple-touch-icon" href="../../images/apple-icon.png"><link rel="alternate" type="application/atom+xml" title="Atom Feed" href="../../feeds/atom.xml"><link rel="alternate" type="application/rss+xml" title="RSS2.0" href="../../feeds/rss.xml"><link rel="alternate" type="application/json" href="../../feeds/feed.json"><link rel="stylesheet" type="text/css" href="../../styles/bundle.css"><title>Object.create(null)のフィード｜JSer.info Watch List RSS</title>
</head><body><header role="banner" class="ui-section-header"><div class="ui-layout-container"><div class="ui-section-header__layout ui-layout-flex"><a href="https://jser.info/watch-list-rss/" role="link" aria-label="#"><img src="../../images/icon.png" alt="サイトロゴ" loading="eager" width="96" height="96"> <span class="ui-section-header__title">JSer.info Watch List RSS</span></a><div class="ui-section-header__links"><a href="https://github.com/jser/watch-list-rss/" role="link" aria-label="#" target="_blank"><img src="../../images/icon-github.png" alt="GitHubロゴ" loading="eager" width="96" height="96"> </a><a href="https://x.com/jser_info" role="link" aria-label="#" target="_blank"><img src="../../images/icon-x.png" alt="Xロゴ" loading="eager" width="96" height="96"></a></div></div></div></header><main role="main"><nav class="ui-nav"><div class="ui-layout-container"><div class="ui-section-nav__layout ui-layout-flex"><a class="ui-section-nav__link" href="../../">フィード</a> <a 
class="ui-section-nav__link" href="../../hot/">人気フィード</a> <a class="ui-section-nav__link" href="../../blogs/">ブログ一覧</a></div></div></nav><section class="ui-section-content ui-section-feed"><div class="ui-layout-container"><h2 class="ui-typography-heading">Object.create(null)</h2><div class="ui-container-blog-summary"><div class="ui-blog-summary"><a class="ui-blog-summary__link" href="https://susisu.hatenablog.com/">https://susisu.hatenablog.com/</a><p class="ui-blog-summary__description">Object.create(null)</p></div></div><h3 class="ui-typography-heading">フィード</h3><div class="ui-section-content--feature ui-layout-grid ui-layout-grid-3 ui-container-feed ui-container-feed--no-image"><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://susisu.hatenablog.com/entry/2025/12/04/130842"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" 
href="https://susisu.hatenablog.com/entry/2025/12/04/130842">never が好き</a><div class="ui-feed-item__blog-title">Object.create(null)</div><div class="ui-feed-item__summary">この記事は はてなエンジニア Advent Calendar 2025 の 4 日目の記事です. id:susisu です. TypeScript の never 型がたいへん奥ゆかしいので見ていってください. 基礎編 まずは never 型がどういったものなのかを見てみましょう. 値のない型として 例えば number 型に対しては 42, 3.14, NaN など , string 型に対しては &quot;&quot;, &quot;Hello&quot; などのように, 一般的な型にはその型が付けられる値が存在します. 一方で never 型にはそういった値が存在しません (こういった型は一般にボトム型などと呼ばれたりします…</div><div class="ui-feed-item__date" title="2025-12-04 04:08:42">1ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://susisu.hatenablog.com/entry/2025/11/04/123400"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://susisu.hatenablog.com/entry/2025/11/04/123400">Next.js でよくある一覧 + 詳細画面を作る</a><div 
class="ui-feed-item__blog-title">Object.create(null)</div><div class="ui-feed-item__summary">あの日見たパターンの名前を僕たちはまだ知らない. よくある一覧 + 詳細画面を作りたい 例えば TODO アプリで, /todo にアクセスしたらタスクの一覧を, /todo/42 にアクセスしたら一覧は表示したまま ID = 42 のタスクの詳細を表示する, というよくあるパターンの画面を作りたい. 世の中の実例としては Asana や, URL の形は異なりますが GitHub の Projects なんかがこういう感じですね. /todo で一覧, /todo/42 で一覧 + 詳細 技術的には要するに SPA なのでやればできるはずなんですが, これを Next.js (App Rou…</div><div class="ui-feed-item__date" title="2025-11-04 03:34:00">2ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://susisu.hatenablog.com/entry/2025/10/10/020828"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://susisu.hatenablog.com/entry/2025/10/10/020828">querySelector に型引数を指定しない</a><div class="ui-feed-item__blog-title">Object.create(null)</div><div class="ui-feed-item__summary">
必要もないのに querySelector や querySelectorAll の型引数を指定しないようにしましょう. (この記事は AI レビュワーに「型引数を指定した方が型安全だ」と提案されたのに対する反論として作成しています.) querySelector の型安全性 querySelector や querySelectorAll の型定義は, 後述する要素型セレクターに関連する部分を除くと, 基本的には以下のようになっています. querySelector&lt;E extends Element = Element&gt;(selectors: string): E | null; quer…</div><div class="ui-feed-item__date" title="2025-10-09 17:08:28">3ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://susisu.hatenablog.com/entry/2025/09/30/195338"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://susisu.hatenablog.com/entry/2025/09/30/195338">OpenTelemetry でメトリクスを計測しようとしたときに知りたかったこと</a><div class="ui-feed-item__blog-title">Object.create(null)</div><div class="ui-feed-item__summary">
タイトルは What I Wish I Knew When Learning Haskell リスペクトです. SDK と API OpenTelemetry でアプリケーションの計装をする際に使うパッケージ (モジュール) は, 計測・集約・エクスポートなどの実装の本体である SDK と, 計測のためのインターフェースである API に分離されています. たとえば Node.js の場合, アプリケーションのエントリポイント付近で @opentelemetry/sdk-metrics パッケージを使って SDK を初期化し, グローバルな MeterProvider を設定します. impo…</div><div class="ui-feed-item__date" title="2025-09-30 10:53:38">4ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://susisu.hatenablog.com/entry/2025/08/31/190757"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://susisu.hatenablog.com/entry/2025/08/31/190757">fetch() では Host ヘッダーを設定できないし話はそこまで単純じゃない</a><div class="ui-feed-item__blog-title">Object.create(null)</div><div class="ui-feed-item__summary">
JavaScript (TypeScript) のコードから HTTP リクエストを送る手段として, 最近では Web 標準の一つである Fetch Standard で定義された fetch() が使われることが多いですね. await fetch(&quot;https://example.com&quot;); リクエストヘッダーには Host を設定できない Fetch Standard では Host をはじめとして Content-Length, Cookie, Origin など, いくつかのリクエストヘッダーを設定 (JavaScript から上書き) することが禁止されています. https:/…</div><div class="ui-feed-item__date" title="2025-08-31 10:07:57">5ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://susisu.hatenablog.com/entry/2025/07/19/130935"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://susisu.hatenablog.com/entry/2025/07/19/130935">Math メソッド 最強</a><div class="ui-feed-item__blog-title">Object.create(null)</div><div class="ui-feed-item__summary">
異論は認めます S clz32 A acosh, asinh, atanh, f16round, fround, imul B acos, asin, atan, cbrt, cosh, expm1, hypot, log1p, sign, sinh, tanh, trunc, sumPrecise*1 C atan2, cos, exp, log, log2, log10, sin, tan D abs, ceil, floor, max, min, pow, random, round, sqrt *1:Stage 3 https://github.com/tc39/proposal-ma…</div><div class="ui-feed-item__date" title="2025-07-19 04:09:35">6ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://susisu.hatenablog.com/entry/2025/07/01/012022"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://susisu.hatenablog.com/entry/2025/07/01/012022">コードの読み書き</a><div class="ui-feed-item__blog-title">Object.create(null)</div><div class="ui-feed-item__summary">
コードレビューというかコードリーディングというかコードライティングというか、とにかく自分と他人の見えている景色がかなり違っていそうということはわかっているんだが、それを伝えられるなら苦労していないという状態— 塩水うに (@susisu2413) June 29, 2025 とにかく他人がコードを読み書きしている様子を見ていると腑に落ちないというか, 何と言うか自分の考える「読み書き」とは全然違うことをしているんじゃないか? あるいは自分の「読み書き」が異常なのか? みたいな気持ちになることが多い. 例えばセルフコードレビューをしてみようみたいな記事を書いて, これを読んでコードを自分でレビュ…</div><div class="ui-feed-item__date" title="2025-06-30 16:20:22">7ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://susisu.hatenablog.com/entry/2025/06/01/171515"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://susisu.hatenablog.com/entry/2025/06/01/171515">プロジェクト固有の ESLint ルール追加 RTA</a><div class="ui-feed-item__blog-title">Object.create(null)</div><div class="ui-feed-item__summary">
TypeScript 使用ルートです. AI Coding Agent Enablement in TypeScript や TS特化Clineプログラミング で紹介されていたように独自の lint ルールを作りたいということがあるかと思いますが, それシュッとプロジェクト内に完結した形で作りたいといったときにご活用ください. サンプルリポジトリは以下: 1. 依存ライブラリをインストール TypeScript でルールを書くために, 以下の 2 つを devDependencies としてインストールしてください. jiti: ESLint で TypeScript で書かれた設定ファイルを…</div><div class="ui-feed-item__date" title="2025-06-01 08:15:15">8ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://susisu.hatenablog.com/entry/2025/05/30/214530"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://susisu.hatenablog.com/entry/2025/05/30/214530">TSKaigi 2025 参加レポート</a><div class="ui-feed-item__blog-title">Object.create(null)</div><div class="ui-feed-item__summary">
登壇してきた 発表の内容については前の記事を読んでください. この規模のカンファレンスでの登壇は初めてだったのですが, 元々関連分野に興味があった人には刺さりつつ, そうでない人にも面白いと思ってもらえた様子も観測していて, だいたい目論見通りの発表ができたんじゃないかと思います. 良かったね. 来月の関数型まつりにも参加するので (登壇はしませんが), TypeScript でのエフェクト周りのあれこれについてなどはまたバトルしてください &gt; 各位 あとこの場を借りて運営の方々に感謝を申し上げておきます. 前回の TSKaigi Kansai では運営をしていたのですが, 今回登壇者として参…</div><div class="ui-feed-item__date" title="2025-05-30 12:45:30">8ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://susisu.hatenablog.com/entry/2025/05/28/133921"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://susisu.hatenablog.com/entry/2025/05/28/133921">「君だけのオリジナル async / await を作ろう」スピーカーノート &amp; 補足</a><div class="ui-feed-item__blog-title">Object.create(null)</div><div class="ui-feed-item__summary">
TSKaigi 2025 での登壇「君だけのオリジナル async / await を作ろう」のスピーカーノートと補足です. (TSKaigi 2025 自体の感想や面白かった発表の話なんかはまた別途書きます.) スピーカーノート &amp; 補足 参考文献 スピーカーノート &amp; 補足 「君だけのオリジナル async / await を作ろう」というタイトルで発表します. susisu ですよろしくおねがいします. 今日, 特に最後の方は多少抽象度が高い話題を扱うので, もしかしたらちょっと難しい話になってしまうかもなんですが, 最終的に私が一番伝えたいのは「TypeScript 面白い」ということ…</div><div class="ui-feed-item__date" title="2025-05-28 04:39:21">8ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://susisu.hatenablog.com/entry/2025/04/28/202020"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://susisu.hatenablog.com/entry/2025/04/28/202020">Effective TypeScript 読んだ / 郷に入っては郷に従う</a><div class="ui-feed-item__blog-title">Object.create(null)</div><div class="ui-feed-item__summary">
Effective TypeScript (第2版) を読んだ なんらか他の人に読んでおくと良いよと紹介できる本があると良いなと思って読みました. 2020 年以降に TypeScript を書く上での常識が概ね網羅されていると思うので, そういった前提知識に自信をつけたいならおすすめです. www.oreilly.co.jp ただ「項目18 推論可能な型でコードを乱雑にしない」で, 関数の戻り値の型アノテーションをデフォルトで省略するよう推奨していることについては明確に反対したい. より正確には, コールバックなど再利用を想定しない関数についてはデフォルトで省略してもよいが, 通常関数は再利…</div><div class="ui-feed-item__date" title="2025-04-28 11:20:20">9ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://susisu.hatenablog.com/entry/2025/03/30/153957"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://susisu.hatenablog.com/entry/2025/03/30/153957">ESLint の Flat Config を書く時に読んでほしい記事 (2025-03版)</a><div class="ui-feed-item__blog-title">Object.create(null)</div><div class="ui-feed-item__summary">
この記事は以下の記事の改訂版です. susisu.hatenablog.com ESLint v9 から Flat Config がデフォルトの設定ファイルの形式となり, 徐々に対応しているプラグインも増えて移行が進みつつありますが, 実際に移行したプロジェクトを見ているとしばしば勘違いなどから誤った設定をしている事例を目にします. ということで, Flat Config を書くにあたっていくつか知っておいて欲しいことや, よく見かけるミスをまとめてみました. この記事では網羅的な説明はしませんので, ESLint や typescript-eslint の公式ドキュメントを前提として, 副読…</div><div class="ui-feed-item__date" title="2025-03-30 06:39:57">10ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://susisu.hatenablog.com/entry/2025/02/08/160003"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://susisu.hatenablog.com/entry/2025/02/08/160003">then() を export した結果ｗｗｗ</a><div class="ui-feed-item__blog-title">Object.create(null)</div><div class="ui-feed-item__summary">
Promise と Thenable Promise が ECMAScript の言語仕様に追加されたのは ES2015 ですが, Promise ライクなオブジェクトはそれ以前からも広く使われてきました (jQuery の Deferred など). そういった Promise ライクなオブジェクトとの互換性のため, Promise の仕様は本物の Promise と Promise ライクなオブジェクトを混ぜて使えるようになっています. 具体的には, Promise ライクなオブジェクトは一般に Thenable という共通のインターフェースを持つことになっています. オブジェクトが Th…</div><div class="ui-feed-item__date" title="2025-02-08 07:00:03">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://susisu.hatenablog.com/entry/2025/01/25/152042"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://susisu.hatenablog.com/entry/2025/01/25/152042">Reusable Workflows と Composite Actions の使い分け</a><div class="ui-feed-item__blog-title">Object.create(null)</div><div class="ui-feed-item__summary">
個人の見解です. GitHub Actions 内の実行単位 GitHub Actions で基本となる実行単位は workflow ですが, その中に job, さらにその中に step という階層構造があるということをまずは理解しておきましょう. workflow トップレベルの実行単位 job workflow の中で並列に実行される (直列に実行したい場合は needs で依存関係を持たせる) runner (VM) は job ごとに用意される step job の中で直列に実行される Reusable workflows と composite actions GitHub から公…</div><div class="ui-feed-item__date" title="2025-01-25 06:20:42">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://susisu.hatenablog.com/entry/2025/01/24/210536"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://susisu.hatenablog.com/entry/2025/01/24/210536">ラベル付きタプル型で遊ぼう</a><div class="ui-feed-item__blog-title">Object.create(null)</div><div class="ui-feed-item__summary">
ラベル付きタプル型とは TypeScript には配列型 (Array) のサブセットとしてタプル型がありますが, その各要素にはラベルをつけることができます (参考). // 通常のタプル型 type Tuple = [number, string]; // ラベル付きのタプル型 type LabeledTuple = [foo: number, bar: string]; ちなみにタプル型には可変長の部分を 1 つまで含めることができますが, そこにもラベルがつけられます. type LabeledVariadicTuple = [foo: number, ...bar: string[]…</div><div class="ui-feed-item__date" title="2025-01-24 12:05:36">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://susisu.hatenablog.com/entry/2025/01/03/180241"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://susisu.hatenablog.com/entry/2025/01/03/180241">N 文字以上なら省略表示</a><div class="ui-feed-item__blog-title">Object.create(null)</div><div class="ui-feed-item__summary">
「N 文字以上 / 以内」みたいなことを言われたときに考えること. 「文字」とは? 単に「文字」と言っても, それが指しているものが何かは自明ではない. 符号単位 (code unit) JavaScript の場合, 文字列は UTF-16 としてエンコードされている*1ので, そのエンコードの単位である 16 bit ごとに分割するというのがこの方法. .length で取得できるのはこの符号単位の数で, .slice() に与えるのも符号単位で数えたインデックスとなっている. &gt; &quot;あいうえおABCDE&quot;.length 10 &gt; &quot;あいうえおABCDE&quot;.slice(0, 5) &quot;あいう…</div><div class="ui-feed-item__date" title="2025-01-03 09:02:41">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://susisu.hatenablog.com/entry/2025/01/01/223348"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://susisu.hatenablog.com/entry/2025/01/01/223348">N 行以上なら省略表示</a><div class="ui-feed-item__blog-title">Object.create(null)</div><div class="ui-feed-item__summary">
N 行以上なら省略表示したい 所感: LGTM import { FC, ReactNode, CSSProperties } from &quot;react&quot;; import styles from &quot;./LineClampingBox.module.scss&quot;; /** 指定した行数以上なら省略表示する */ export const LineClampingBox: FC&lt;{ /** 最大行数 */ maxLines: number; children: ReactNode; }&gt; = ({ maxLines, children }) =&gt; { return ( &lt;div className={…</div><div class="ui-feed-item__date" title="2025-01-01 13:33:48">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://susisu.hatenablog.com/entry/2024/12/04/210921"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://susisu.hatenablog.com/entry/2024/12/04/210921">Data types à la carte in TypeScript</a><div class="ui-feed-item__blog-title">Object.create(null)</div><div class="ui-feed-item__summary">
この記事は はてなエンジニア Advent Calendar 2024 の 4 日目の記事です. 昨日は id:onk さんの コミュニティ生活で大切な三つの袋 - id:onk のはてなブログ でした. ところで皆さん TypeScript は書いていますか書いていますよねそうですよね. そんな皆さんに TypeScript の表現力の高さを改めて実感してもらうべく, この記事では Data types à la carte という論文で紹介されている抽象データ型の拡張性に関する問題を, TypeScript ではどのように解決できるかを紹介します. 抽象データ型の拡張性の問題 まずは論文で…</div><div class="ui-feed-item__date" title="2024-12-04 12:09:21">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://susisu.hatenablog.com/entry/2024/10/23/114656"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://susisu.hatenablog.com/entry/2024/10/23/114656">package.json の Conditional Exports では順序が意味を持つ</a><div class="ui-feed-item__blog-title">Object.create(null)</div><div class="ui-feed-item__summary">
Conditional Exports とは package.json 内の exports フィールドには, 以下のように条件付きでエクスポートするファイルを指定できる (conditional exports). { &quot;name&quot;: &quot;@susisu/example&quot;, &quot;type&quot;: &quot;module&quot;, &quot;exports&quot;: { &quot;.&quot;: { &quot;require&quot;: &quot;./lib/index.cjs&quot;, &quot;default&quot;: &quot;./lib/index.js&quot; } } } たとえばこの例では CommonJS ファイル内から require(&quot;@susisu/example&quot;) のように参照…</div><div class="ui-feed-item__date" title="2024-10-23 02:46:56">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://susisu.hatenablog.com/entry/2024/09/07/213747"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://susisu.hatenablog.com/entry/2024/09/07/213747">null or undefined #kyotoasterisk とその補足など</a><div class="ui-feed-item__blog-title">Object.create(null)</div><div class="ui-feed-item__summary">
Kyoto.なんか #6 で発表しました. speakerdeck.com 以下はその補足情報など. 仕様書中の出現頻度 null と undefined がそれぞれの仕様でどの程度使われているのかは, 仕様書中の出現頻度を見るだけでもある程度わかりりそうです. ということで ECMAScript 2024 と WHATWG の標準 (2024-09-07 時点) のうちいくつかの仕様書の中での出現頻度を見てみましょう. Spec #null #undefined ES2024 300 939 DOM 368 120 Fetch 276 10 HTML 1778 275 URL 98 9 見て…</div><div class="ui-feed-item__date" title="2024-09-07 12:37:47">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://susisu.hatenablog.com/entry/2024/08/14/233156"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://susisu.hatenablog.com/entry/2024/08/14/233156">ESLint の Flat Config を書く時に読んでほしい記事 (2024-08版)</a><div class="ui-feed-item__blog-title">Object.create(null)</div><div class="ui-feed-item__summary">
2025-03-30 追記: 改訂版を書きました. susisu.hatenablog.com ESLint v9 から Flat Config がデフォルトの設定ファイルの形式となり, 徐々に対応しているプラグインも増えて移行が進みつつありますが, 実際に移行したプロジェクトを見ているとしばしば勘違いなどから誤った設定をしている事例を目にします. ということで, Flat Config を書くにあたっていくつか知っておいて欲しいことや, よく見かけるミスをまとめてみました. この記事では網羅的な説明はしませんので, ESLint や typescript-eslint の公式ドキュメントを前…</div><div class="ui-feed-item__date" title="2024-08-14 14:31:56">1年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://susisu.hatenablog.com/entry/2024/07/06/030744"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://susisu.hatenablog.com/entry/2024/07/06/030744">Object.groupBy で作られるオブジェクトの prototype は null</a><div class="ui-feed-item__blog-title">Object.create(null)</div><div class="ui-feed-item__summary">
おさらい: prototype JavaScript のオブジェクトはみんな prototype というのを持っていて, この prototype からプロパティを継承, より正確には, プロパティアクセス時にそのプロパティがオブジェクトに存在しなければ prototype を辿って見つけにいくことになっている. あるオブジェクトを prototype とした別のオブジェクトを作るには Object.create を使う (あるいは new 演算子や __proto__ を使っても良い). const x = {}; x.foo = &quot;foo&quot;; const y = Object.create…</div><div class="ui-feed-item__date" title="2024-07-05 18:07:44">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://susisu.hatenablog.com/entry/2024/06/23/194206"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://susisu.hatenablog.com/entry/2024/06/23/194206">ドメインモデリングにエフェクトを使う思考実験</a><div class="ui-feed-item__blog-title">Object.create(null)</div><div class="ui-feed-item__summary">
TypeScript でエフェクトを使う話の続き. あるいは DI 手法の話でエフェクトを使うのを半ば冗談として書いていたのを, より具体的な状況を想定してもう少し真面目に考えてみる. ドメイン層と永続化 ドメイン層においては永続化のための具体的な技術については関心を持ちませんが, 永続化すること自体に関心を持たないわけではありません. リポジトリというドメイン層に用意されたインターフェースを使って保存や検索を行いつつ, 具体的な技術はドメイン層の外にあるインターフェースの実装に任せるというのが典型例です. これは永続化以外にも, 例えばイベントの送信などについても同様のことが言えます. (な…</div><div class="ui-feed-item__date" title="2024-06-23 10:42:06">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://susisu.hatenablog.com/entry/2024/06/15/215546"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://susisu.hatenablog.com/entry/2024/06/15/215546">エフェクトとジェネレーターと</a><div class="ui-feed-item__blog-title">Object.create(null)</div><div class="ui-feed-item__summary">
2 年前に作って放置していたライブラリを最近ちょっと整理したのでその話. エフェクト プログラム中に登場する関数のことを考えてみましょう. 関数は引数を与えるとなんらかの計算を行い, 戻り値を返してくれます. もし関数が純粋な (数学的な意味での) 関数であれば, 関数の入出力は引数と戻り値だけです. つまり, 引数以外の入力 (例えば時刻) によって出力が変わることもなければ, 戻り値以外の出力 (例えば光や音) が得られることもありません. 一方で実用的な価値のあるプログラムというのは時刻に応じて光や音を発生させるようなものであり, これらは純粋な関数だけを組み合わせていては作ることができ…</div><div class="ui-feed-item__date" title="2024-06-15 12:55:46">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://susisu.hatenablog.com/entry/2024/05/12/182739"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://susisu.hatenablog.com/entry/2024/05/12/182739">TypeScript 版 Mackerel API クライアントライブラリを作った</a><div class="ui-feed-item__blog-title">Object.create(null)</div><div class="ui-feed-item__summary">
作りました. jsr.io リポジトリはこっち. github.com (2024-05-12 現在, 筆者は Mackerel を開発している株式会社はてなの社員ですが, これは個人プロジェクトで, API ドキュメントなどの公開されている情報に基づいて作成されています.) なぜ JSR になんか publish したくなった 乗るしかないこのビッグウェーブ TypeScript で Mackerel を操作するちょっとしたスクリプトを書きたかったが, 意外とクライアントライブラリがなかった 単に JSON を fetch してくるだけなら簡単だが, それだけでは型もないし使いづらい 使い方…</div><div class="ui-feed-item__date" title="2024-05-12 09:27:39">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://susisu.hatenablog.com/entry/2024/04/15/011331"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://susisu.hatenablog.com/entry/2024/04/15/011331">Brainfuck 実装で学ぶ TypeScript 型レベルプログラミング</a><div class="ui-feed-item__blog-title">Object.create(null)</div><div class="ui-feed-item__summary">
およそ 4 年前に「TypeScript で型レベル Brainfuck」という記事を書きました. susisu.hatenablog.com それから 4 年間の間に TypeScript も進化し, 型レベルプログラミングの技法にも大きな変化がありました. 特に顕著な影響があったものでは, TypeScript 4.0 のタプル型の改善 TypeScript 4.1 のテンプレートリテラル型や条件型での再帰 TypeScript 4.5 の条件型での末尾再帰の除去と, 再帰の上限の緩和 などがあります. こういった変化も踏まえた上で, いまから TypeScript の型レベルプログラミン…</div><div class="ui-feed-item__date" title="2024-04-14 16:13:31">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://susisu.hatenablog.com/entry/2024/02/13/014740"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://susisu.hatenablog.com/entry/2024/02/13/014740">ESLint の設定をエディタ補完や型検査つきで書く</a><div class="ui-feed-item__blog-title">Object.create(null)</div><div class="ui-feed-item__summary">
ESLint の設定に関する TypeScript の型情報を提供してくれる eslint-define-config (ESLint 非公式プロジェクト) のご紹介. github.com 使い方 eslintrc の場合は defineConfig, Flat Config の場合は defineFlatConfig で設定を囲むだけで VSCode などエディタ上で補完が効くようになります. これらの関数の実体はただの恒等関数なので, 型情報を提供する以上のことは何もしません (つまり何も気にせず追加できます). import { defineFlatConfig } from &quot;esl…</div><div class="ui-feed-item__date" title="2024-02-12 16:47:40">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://susisu.hatenablog.com/entry/2024/02/01/042346"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://susisu.hatenablog.com/entry/2024/02/01/042346">Pull Request を作るのに一時間以上かかったら捨ててる</a><div class="ui-feed-item__blog-title">Object.create(null)</div><div class="ui-feed-item__summary">
一時間は大体の目安でちゃんと測ってない. PR の作成に時間がかかるときは, 何らか良くないことが起きている可能性が高い 試行錯誤を繰り返している 変更の規模が過大になっている 良くないことが起きているなら, そのまま続けて余計なコストをかけるよりも捨てた方が良い 試行錯誤を繰り返していたなら, そこまでは勉強か練習だと思って捨てる 変更の規模が過大になっていたなら, 分割して作り直すために捨てる 捨てることを躊躇わない 時間をかけるほど引き返しづらくなるので, 一時間くらいで打ち切る 一時間の手戻りなら一時間で取り返せる. なんなら知識が増えている分もっと短くて済む 思ったより進んでいなくて…</div><div class="ui-feed-item__date" title="2024-01-31 19:23:46">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://susisu.hatenablog.com/entry/2023/12/18/191710"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://susisu.hatenablog.com/entry/2023/12/18/191710">Node.js パッケージから自分自身を参照する</a><div class="ui-feed-item__blog-title">Object.create(null)</div><div class="ui-feed-item__summary">
例えばサンプルコードを同梱したい場合や, コンパイラのセルフホストのような場合など, Node.js パッケージの内部でそのパッケージ自身を参照したくなることがあります. あるか? このときの方法がいくつかあるので軽くまとめます. ここでは例として以下のようなディレクトリ構造になっている mypackage パッケージを仮定して, examples/ 以下のサンプルコードからパッケージ自身を参照することを考えます. CommonJS と ES modules で挙動が異なるので, どちらの形式であるかを明示するために拡張子には常に .cjs か .mjs を使います. +-- package.…</div><div class="ui-feed-item__date" title="2023-12-18 10:17:10">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://susisu.hatenablog.com/entry/2023/12/09/140332"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://susisu.hatenablog.com/entry/2023/12/09/140332">最</a><div class="ui-feed-item__blog-title">Object.create(null)</div><div class="ui-feed-item__summary">
ふと「最寄り」のように「最」と書いて「も」と読ませる語に異常性を感じたので, すべての「最」を集めたくなりました. 昨日のことです. 集めるとはいっても, 脳内を検索しているだけでは, 最上 (もがみ) 最中 (もなか) 最早 (もはや) 最寄り (もより) くらいしか思い当たりません. 直感的に異常性を感じるくらいには珍しいので当然です. ということで衝動買いした広辞苑がこちら. 一般的な語を探すのであればひとまずこれで十分でしょう. このためだけに購入 あとなぜかこれが二つついてきたので, 欲しい方がいたら片方差し上げます. 合計 2,400 万部の実績 そんな広辞苑によれば, 「最」とは…</div><div class="ui-feed-item__date" title="2023-12-09 05:03:32">2年前</div></div></div></div></div></section></main><footer role="contentinfo" class="ui-section-footer"><div class="ui-layout-container"><div class="ui-layout-column-6 ui-layout-column-center"><div class="ui-component-cta ui-layout-flex ui-section-footer__site-info"><p class="ui-text-note">このサイトは<br>記事を読んでその企業の技術・カルチャーを知れることや<br>質の高い技術情報を得られることを目的としています。</p><p class="ui-text-note">追加したいブログがある場合は<br><a href="https://github.com/jser/watch-list-rss#%E3%82%B5%E3%82%A4%E3%83%88%E3%81%AE%E8%BF%BD%E5%8A%A0%E6%96%B9%E6%B3%95" target="_blank">サイトの追加方法</a> をご参照ください。</p></div></div></div><div class="ui-layout-container"><div 
class="ui-section-footer__layout ui-layout-flex"><p class="ui-section-footer--copyright ui-text-note"><a class="ui-text-note" href="https://github.com/jser/" target="_blank"><small>@jser</small></a></p><a href="https://github.com/jser/watch-list-rss/" role="link" aria-label="#" class="ui-text-note" target="_blank"><small>GitHub</small></a></div></div></footer></body></html>