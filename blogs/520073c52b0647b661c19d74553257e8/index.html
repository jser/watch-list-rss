<!doctype html><html lang="ja"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="JSer.infoの情報源となるサイトのRSSフィードをまとめたサイトです。JavaScriptの情報源を集めることを目的としています。"><meta name="author" content="jser"><meta name="robots" content="index, follow"><meta property="og:url" content="https://jser.info/watch-list-rss/"><meta property="og:title" content="Colin McDonnell @colinhacksのフィード｜JSer.info Watch List RSS"><meta property="og:image" content="https://jser.info/watch-list-rss/images/og-image.png?hash=c56ba3x"><meta property="og:description" content="JSer.infoの情報源となるサイトのRSSフィードをまとめたサイトです。JavaScriptの情報源を集めることを目的としています。"><meta property="og:type" content="website"><meta property="og:site_name" content="JSer.info Watch List RSS"><meta property="og:locale" content="ja_JP"><meta name="twitter:card" content="summary"><meta property="twitter:domain" content="https://jser.info/watch-list-rss/"><meta property="twitter:url" 
content="https://jser.info/watch-list-rss/"><meta name="twitter:title" content="Colin McDonnell @colinhacksのフィード｜JSer.info Watch List RSS"><meta name="twitter:description" content="JSer.infoの情報源となるサイトのRSSフィードをまとめたサイトです。JavaScriptの情報源を集めることを目的としています。"><meta name="twitter:image" content="https://jser.info/watch-list-rss/images/og-image.png?hash=c56ba3x"><meta name="thumbnail" content="https://jser.info/watch-list-rss/images/og-image.png?hash=c56ba3x"><link rel="preload" href="../../styles/bundle.css" as="style"><link rel="shortcut icon" href="../../images/favicon.ico"><link rel="apple-touch-icon" href="../../images/apple-icon.png"><link rel="alternate" type="application/atom+xml" title="Atom Feed" href="../../feeds/atom.xml"><link rel="alternate" type="application/rss+xml" title="RSS2.0" href="../../feeds/rss.xml"><link rel="alternate" type="application/json" href="../../feeds/feed.json"><link rel="stylesheet" type="text/css" href="../../styles/bundle.css"><script async 
src="https://www.googletagmanager.com/gtag/js?id=G-Q66PHF829Y"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-Q66PHF829Y")</script><title>Colin McDonnell @colinhacksのフィード｜JSer.info Watch List RSS</title></head><body><header role="banner" class="ui-section-header"><div class="ui-layout-container"><div class="ui-section-header__layout ui-layout-flex"><a href="https://jser.info/watch-list-rss/" role="link" aria-label="#"><img src="../../images/icon.png" alt="サイトロゴ" loading="eager" width="96" height="96"> <span class="ui-section-header__title">JSer.info Watch List RSS</span> </a><a href="https://github.com/jser/watch-list-rss/" role="link" aria-label="#"><img src="../../images/github-mark.png" alt="GitHubロゴ" loading="eager" width="96" height="96"></a></div></div></header><main role="main"><nav class="ui-nav"><div class="ui-layout-container"><div class="ui-section-nav__layout ui-layout-flex"><a 
class="ui-section-nav__link" href="../../">フィード</a> <a class="ui-section-nav__link" href="../../hot/">人気フィード</a> <a class="ui-section-nav__link" href="../../blogs/">ブログ一覧</a></div></div></nav><section class="ui-section-content ui-section-feed"><div class="ui-layout-container"><h2 class="ui-typography-heading">Colin McDonnell @colinhacks</h2><div class="ui-container-blog-summary"><div class="ui-blog-summary"><a class="ui-blog-summary__link" href="https://colinhacks.com">https://colinhacks.com</a><p class="ui-blog-summary__description">Founder of Bagel Health, creator of Zod, open-sourcer, poptimist, movie buff. Wanna go to Taco Bell?</p></div></div><h3 class="ui-typography-heading">フィード</h3><div class="ui-section-content--feature ui-layout-grid ui-layout-grid-3 ui-container-feed ui-container-feed--no-image"><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://colinhacks.com/essays/live-types-typescript-monorepo"><img src="../../images/alternate-feed-image.png" 
loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://colinhacks.com/essays/live-types-typescript-monorepo">Live types in a TypeScript monorepo</a><div class="ui-feed-item__blog-title">Colin McDonnell @colinhacks</div><div class="ui-feed-item__summary">
EDIT: A previous version of this post recommended publishConfig, operating under the mistaken belief that it could be used to override &quot;exports&quot; during npm publish. As it turns out, npm only uses &quot;publishConfig&quot; to override certain .npmrc fields like registry and tag, whereas pnpm has expanded its use to override package metadata like &quot;main&quot;, &quot;types&quot;, and &quot;exports&quot;. There are a number of reasons you may not wish to strongly couple your deployment logic to pnpm (detailed in the publishConfig section below). My updated recommendation is to use a custom export condition plus customConditions in tsconfig.json.Jump into the code: https://github.com/colinhacks/live-typescript-monorepoIn development, your TypeScript code should feel &quot;alive&quot;. When you update your code in one file, the effects of that change should propagate to all files that import it instantaneously, with no build step. This is true even for monorepos, where you may not be importing things from a file, but from a local packag
</div><div class="ui-feed-item__date" title="2024-05-30 21:59:04">5ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://colinhacks.com/essays/reasonable-email-regex"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://colinhacks.com/essays/reasonable-email-regex">An email regex for reasonable people</a><div class="ui-feed-item__blog-title">Colin McDonnell @colinhacks</div><div class="ui-feed-item__summary">
I maintain Zod, which is a schema library. Zod let&#39;s people declare an email schema like this:import {z} from &#39;zod&#39;;z.string().email();A lot of people think every technically valid email address should pass validation by that schema. I used to think that too.Over the years I&#39;ve merged several PRs to make the email regex more &quot;technically correct&quot;. Most recently, I merged a PR that adds support for IPv6 addresses as the domain part of an email. They look like this and I hate them:jonny@[ipv6:7e95:0559:10f2:21e9:9dab:7309:c116:ca3b]Turns out that PR also broke plain old subdomains: user@subdomain.domain.com. That means Zod currently fails to parse my mom&#39;s current email address but Jonny up there can parse his freakish IPv6 email.This caused a spiritual crisis and made me re-evaluate my whole stance on what z.string().email() should do. Zod&#39;s users are mostly engineers who are building apps. When you&#39;re building an app, you want to make sure your users are providing normal-ass email addr
</div><div class="ui-feed-item__date" title="2023-03-08 06:13:36">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://colinhacks.com/essays/docs-the-smart-way"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://colinhacks.com/essays/docs-the-smart-way">From README to documentation site in 10 minutes</a><div class="ui-feed-item__blog-title">Colin McDonnell @colinhacks</div><div class="ui-feed-item__summary">
Spoiler alert: GitHub Pages and GitHub actions are not involved.I recently set out to build a proper documentation site for Zod with a short and eminently reasonable list of goals:The site should be generated from the README. Zod&#39;s README.md is the &quot;source of truth&quot;.The site should automatically update whenever the master branch is updated.I didn&#39;t want to worry about building or maintaining a complex build workflow in GitHub Actions, if possible.Despite the eminent reasonability, I had a hard time finding a simple solution. After a lot of research and false starts, I&#39;ve found what I think is the lowest-effort, highest-reward way to publish a documentation site for your GitHub-hosted project.Let&#39;s jump in.1. Add this index.html to your repoCreate a file called index.html in your project root and paste the following contents into it.Replace all occurrences of user/repo with your project&#39;s name. And maybe write up a slightly more detailed meta description :)&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;
</div><div class="ui-feed-item__date" title="2022-05-13 03:46:51">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://colinhacks.com/essays/painless-typesafety"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://colinhacks.com/essays/painless-typesafety">Building an end-to-end typesafe API — without GraphQL</a><div class="ui-feed-item__blog-title">Colin McDonnell @colinhacks</div><div class="ui-feed-item__summary">
In the mid-2010s, the pendulum of web development swung massively in the direction of increased type safety.First, we all switched back to relational DBs after recovering from an embarrassingly long collective delusion that NoSQL was cool. Then TypeScript started its meteoric rise after years of quiet development. Shortly thereafter GraphQL was announced and quickly became the de facto way to implement typesafe APIs.TLDR: I published a new library called tRPC that makes it easy to build end-to-end typesafe APIs without code generation, by leveraging the power of modern TypeScript. To jump straight to the tRPC walkthrough, click here.GraphQL&#39;s TypeScript problemGraphQL&#39;s biggest competitive advantage is that it&#39;s a spec, not a library. It&#39;s designed to be universal and language-agnostic. If you use different languages for your client and server, then by all means stick with GraphQL! It remains the best language-agnostic way to build typesafe data layers.But the vast majority of projects
</div><div class="ui-feed-item__date" title="2021-06-13 14:41:14">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://colinhacks.com/essays/why-zod-2-isnt-leaving-beta"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://colinhacks.com/essays/why-zod-2-isnt-leaving-beta">Why Zod 2 isn&#39;t leaving beta</a><div class="ui-feed-item__blog-title">Colin McDonnell @colinhacks</div><div class="ui-feed-item__summary">
Zod&#39;s v2 has been in beta since September 2020 (around 3 months as of this writing). The people are starting to talk.The backgroundThe reason Zod 2 has been in beta for so long (well, one of the reasons anyway!) is that I’ve been increasingly unsatisfied with Zod’s implementation of transformers. Transformers are a mechanism within Zod to convert data from one type to another. For the sake of rigor, I decided it was paramount for transformers to encapsulate both pre- and post-transform validation; to create one, you gave it an input schema A, and output schema B, and a transformation function (arg: A)=&gt;B.Multiple issues have cropped up that have led me to re-evaluate the current approach. At best, transformers are a huge footgun and at worst they’re fundamentally flawed.ContextIn version 1, a Zod schema simply let you define a data type you&#39;d like to validate. Under the hood, it magically inferred the static TypeScript type for your schema. More technically, there is a base class (ZodT
</div><div class="ui-feed-item__date" title="2020-12-08 07:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://colinhacks.com/essays/vercel-nextjs-spa"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://colinhacks.com/essays/vercel-nextjs-spa">Next.js, nested routes, and the war on SPAs</a><div class="ui-feed-item__blog-title">Colin McDonnell @colinhacks</div><div class="ui-feed-item__summary">
Edit: 2022 The issues described here have been largely solved by layouts in Next.js 13.I recently set out to implement a single-page application (SPA) on top of Next.js.To clarify, I&#39;m using the term &quot;SPA&quot; in a very specific way. I&#39;m referring to the &quot;classical&quot; SPA model: an application that handles all data fetching, rendering, and routing entirely client-side.Turns out, Next.js does not make this easy.To actually learn how to build a single-page application on top of Next.js, checkout my tutorial! Building a single-page application with Next.js.Why not use Next&#39;s routerNext&#39;s built-in router isn&#39;t as flexible as React Router! React Router lets you nest routers hierarchically in a flexible way. It&#39;s easy for any &quot;parent&quot; router to share data and provide an outer layout to its &quot;child&quot; routes. This is true for both top-level routes (e.g. /about and /team) and nested routes (e.g. /settings/team and /settings/user).This isn&#39;t possible with Next&#39;s built-in router! Instead, all shared stat
</div><div class="ui-feed-item__date" title="2020-10-29 21:04:40">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://colinhacks.com/essays/building-a-spa-with-nextjs"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://colinhacks.com/essays/building-a-spa-with-nextjs">Building a single-page application with Next.js and React Router</a><div class="ui-feed-item__blog-title">Colin McDonnell @colinhacks</div><div class="ui-feed-item__summary">
Update 2023 — Updated for Next.js 13, React Router 6, and React 18.Update 2022 — Next.js 13 now supports nested routes via the /app directory. However, it requires a server to render React Server Components, and thus doesn&#39;t qualify as a &quot;single-page application&quot; as defined in this post.I recently set out to implement a single-page application (SPA) on top of Next.js.To clarify, I&#39;m using the term &quot;SPA&quot; in a very specific way. I&#39;m referring to the &quot;old school&quot; SPA model: an application that handles all data fetching, rendering, and routing entirely client-side.Turns out, Next.js does not make this easy.Why not use Next.js routing?Next.js is not as flexible as React Router! React Router lets you nest routers hierarchically in a flexible way. It&#39;s easy for any &quot;parent&quot; router to share data with all of its &quot;child&quot; routes. This is true for both top-level routes (e.g. /about and /team) and nested routes (e.g. /settings/team and /settings/user).This isn&#39;t possible with Next&#39;s built-in router
</div><div class="ui-feed-item__date" title="2020-10-29 05:51:10">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://colinhacks.com/essays/nextjs-firebase-authentication"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://colinhacks.com/essays/nextjs-firebase-authentication">Authenticated server-side rendering with Next.js and Firebase</a><div class="ui-feed-item__blog-title">Colin McDonnell @colinhacks</div><div class="ui-feed-item__summary">
**Update: November 29, 2020**&gt;&gt; I have an idea for a SaaS product related to Next.js and authentication, and I&#39;m looking for a co-founder! Ideally you&#39;d be intimately familiar with Next.js, TypeScript, and SQL, and perhaps have some previous entrepreneurial experience. I&#39;m an open-source maintainer and a previous YC founder, and I feel strongly about finding the right partner before starting a new endeavor. If you&#39;re interested shoot me an email at colin@colinhacks.com with a bit about yourself! --&gt; Feb 24, 2021: a previous version of this post contained a bug where a new cookie would be created each time you signed out and back in again. These (identical) cookies would stack up cause problems. If you&#39;re having issues, pass the { path: &#39;/&#39; } option to nookies.set call — details below.I had a hell of a time figuring out how to get Firebase Auth, Next.js, tokens, cookies, and getServerSideProps to play nice together. I&#39;m hoping this breakdown will spare you the same suffering!To jump str
</div><div class="ui-feed-item__date" title="2020-08-09 20:52:24">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://colinhacks.com/essays/a-new-funding-model-for-open-source-software"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://colinhacks.com/essays/a-new-funding-model-for-open-source-software">Sponsor pools: a new funding model for open source software</a><div class="ui-feed-item__blog-title">Colin McDonnell @colinhacks</div><div class="ui-feed-item__summary">
Check out the HN discussion here.This article has been translated into Japanese and Russian.The existing open-source funding models don&#39;t work well for small projects.Big projects — operating systems, frameworks, CMSs, or fully self-hostable applications — are in a privileged position to extract more value from their users, especially corporate ones. Since entire APIs and products are built on top of them, they inspire enough appreciation (or, more likely, fear of obsolescence!) to net a sustainable income from one-off or monthly donations.¹But most OSS projects aren&#39;t big. The typical project on GitHub is better described as a utility — an apt term, given the infrastructural role these projects play in the world. It is a small tool that does one thing really well. Over the course of building a complex application, you may end up using dozens of these utilities — and they&#39;ll save you hundreds of hours of development time.Unfortunately, utilities like these rarely bring in any meaningfu
</div><div class="ui-feed-item__date" title="2020-07-29 09:43:15">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://colinhacks.com/essays/emotion-core-vs-vanilla-emotion"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://colinhacks.com/essays/emotion-core-vs-vanilla-emotion">Why you shouldn&#39;t use @emotion/core</a><div class="ui-feed-item__blog-title">Colin McDonnell @colinhacks</div><div class="ui-feed-item__summary">
A maintainer of Emotion published a very thoughtful response to a version of this post! I encourage you to check that out here. The essay below has modified to address some of his points.Emotion is my favorite CSS-in-JS library.It&#39;s easy to define style classes — both inline or in separate files. You can powerfully compose classes in powerful ways with the cx utility (the Emotion equivalent of Jed Watson&#39;s classnames). You sprinkle in your styles using the standard className attribute. There&#39;s no need to modify your markup/JSX — as it should be! You only need to install a single module (yarn add emotion). And there&#39;s no complicated Babel plugin or config file to set up.import { css, cs } from &#39;emotion&#39;;const redBorder = css({ border: &#39;1px solid red&#39; });const blueText = css({ color: &#39;blue&#39; });const MyComp = () =&gt; { return &lt;div className={cx(redBorder, blueText)}&gt;hello&lt;/div&gt;;};I&#39;m currently building a Tailwind-style CSS-in-JS utility styling library with a maniacal focus on brevity and d
</div><div class="ui-feed-item__date" title="2020-06-07 02:27:58">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://colinhacks.com/essays/devii"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://colinhacks.com/essays/devii">Choosing a tech stack for my personal dev blog in 2020</a><div class="ui-feed-item__blog-title">Colin McDonnell @colinhacks</div><div class="ui-feed-item__summary">
Check out the HN roast discussion here! 🤗This article has been translated into Russian.I recently set out to build my personal website — the one you&#39;re reading now, as it happens!Surprisingly, it was harder than expected assemble a &quot;tech stack&quot; that met my criteria. My criteria are pretty straightforward; I would expect most React devs to have a similar list. Yet it was surprisingly hard to put all these pieces together.Given the lack of a decent out-of-the-box solution, I worry that many developers are settling for static-site generators that place limits on the interactivity and flexibility of your website. We can do better.tl;dr https://github.com/colinhacks/devii.Let&#39;s quickly run through my list of design goals:React (+ TypeScript)I want to build the site in React and TypeScript. I love them both wholeheartedly, I use them for my day job, and they&#39;re gonna be around for a long time. Plus writing untyped JS makes me feel dirty.I don&#39;t want limitations on what my personal website c...
</div><div class="ui-feed-item__date" title="2020-05-26 03:18:56">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://colinhacks.com/essays/zod"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://colinhacks.com/essays/zod">Designing the perfect Typescript schema validation library</a><div class="ui-feed-item__blog-title">Colin McDonnell @colinhacks</div><div class="ui-feed-item__summary">
Update 2023 — Many of the problems with other libraries have been solved since this post was originally published.There are a handful of wildly popular validation libraries in the Javascript ecosystem with thousands of stars on GitHub.When I started my quest to find the ideal schema declaration/validation library, I assumed the hardest part would be identifying the Most Great option from a sea of excellent ones.But as I dug deeper into the many beloved tools in the ecosystem, I was surprised that none of them could provide the features and developer experience I was looking for.tl;dr: I made a new Typescript validation library that has static type inference and the best DX this side of the Mississippi. To jump straight to README, head over to https://github.com/colinhacks/zodA pinch of contextI&#39;m building an API for a healthcare application with Typescript. Naturally I want this mission-critical medical software to be rock-solid, so my goal is to build a fully end-to-end typesafe data
</div><div class="ui-feed-item__date" title="2020-03-08 08:00:00">5年前</div></div></div></div></div></section></main><footer role="contentinfo" class="ui-section-footer"><div class="ui-layout-container"><div class="ui-layout-column-6 ui-layout-column-center"><div class="ui-component-cta ui-layout-flex ui-section-footer__site-info"><p class="ui-text-note">このサイトはJSer.infoの情報源となるサイトの更新を一覧できる目的で作成されたものです。<br>一つのRSSフィードを購読するだけで、複数のサイトの更新情報を取得できます。</p><p class="ui-text-note">このサイトの仕組みは、<a href="https://github.com/jser/watch-list-rss/">GitHubのREADME</a>で公開されています。</p></div></div></div><div class="ui-layout-container"><div class="ui-section-footer__layout ui-layout-flex"><p class="ui-section-footer--copyright ui-text-note"><a class="ui-text-note" href="https://github.com/jser/"><small>@jser</small></a></p><a href="https://github.com/jser/watch-list-rss/" role="link" aria-label="#" class="ui-text-note"><small>GitHub</small></a></div></div></footer></body></html>