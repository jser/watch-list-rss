<!doctype html><html lang="ja"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="JSer.infoの情報源となるサイトのRSSフィードをまとめたサイトです。JavaScriptの情報源を集めることを目的としています。"><meta name="author" content="jser"><meta name="robots" content="index, follow"><meta property="og:url" content="https://jser.info/watch-list-rss/"><meta property="og:title" content="Marcelo Lazaroniのフィード｜JSer.info Watch List RSS"><meta property="og:image" content="https://jser.info/watch-list-rss/images/og-image.png"><meta property="og:description" content="JSer.infoの情報源となるサイトのRSSフィードをまとめたサイトです。JavaScriptの情報源を集めることを目的としています。"><meta property="og:type" content="website"><meta property="og:site_name" content="JSer.info Watch List RSS"><meta property="og:locale" content="ja_JP"><meta name="twitter:card" content="summary"><meta property="twitter:domain" content="https://jser.info/watch-list-rss/"><meta property="twitter:url" 
content="https://jser.info/watch-list-rss/"><meta name="twitter:title" content="Marcelo Lazaroniのフィード｜JSer.info Watch List RSS"><meta name="twitter:description" content="JSer.infoの情報源となるサイトのRSSフィードをまとめたサイトです。JavaScriptの情報源を集めることを目的としています。"><meta name="twitter:image" content="https://jser.info/watch-list-rss/images/og-image.png"><meta name="thumbnail" content="https://jser.info/watch-list-rss/images/og-image.png"><link rel="preload" href="../../styles/bundle.css" as="style"><link rel="shortcut icon" href="../../images/favicon.ico"><link rel="apple-touch-icon" href="../../images/apple-icon.png"><link rel="alternate" type="application/atom+xml" title="Atom Feed" href="../../feeds/atom.xml"><link rel="alternate" type="application/rss+xml" title="RSS2.0" href="../../feeds/rss.xml"><link rel="alternate" type="application/json" href="../../feeds/feed.json"><link rel="stylesheet" type="text/css" href="../../styles/bundle.css"><title>Marcelo Lazaroniのフィード｜JSer.info Watch List RSS</title></head>
<body><header role="banner" class="ui-section-header"><div class="ui-layout-container"><div class="ui-section-header__layout ui-layout-flex"><a href="https://jser.info/watch-list-rss/" role="link" aria-label="#"><img src="../../images/icon.png" alt="サイトロゴ" loading="eager" width="96" height="96"> <span class="ui-section-header__title">JSer.info Watch List RSS</span></a><div class="ui-section-header__links"><a href="https://github.com/jser/watch-list-rss/" role="link" aria-label="#" target="_blank"><img src="../../images/icon-github.png" alt="GitHubロゴ" loading="eager" width="96" height="96"> </a><a href="https://x.com/jser_info" role="link" aria-label="#" target="_blank"><img src="../../images/icon-x.png" alt="Xロゴ" loading="eager" width="96" height="96"></a></div></div></div></header><main role="main"><nav class="ui-nav"><div class="ui-layout-container"><div class="ui-section-nav__layout ui-layout-flex"><a class="ui-section-nav__link" href="../../">フィード</a> <a 
class="ui-section-nav__link" href="../../hot/">人気フィード</a> <a class="ui-section-nav__link" href="../../blogs/">ブログ一覧</a></div></div></nav><section class="ui-section-content ui-section-feed"><div class="ui-layout-container"><h2 class="ui-typography-heading">Marcelo Lazaroni</h2><div class="ui-container-blog-summary"><div class="ui-blog-summary"><a class="ui-blog-summary__link" href="https://lazamar.github.io">https://lazamar.github.io</a><p class="ui-blog-summary__description">Developing for the Interwebs</p></div></div><h3 class="ui-typography-heading">フィード</h3><div class="ui-section-content--feature ui-layout-grid ui-layout-grid-3 ui-container-feed ui-container-feed--no-image"><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://lazamar.github.io/haskell-data-compression-with-huffman-codes/"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a 
class="ui-feed-item__title" href="https://lazamar.github.io/haskell-data-compression-with-huffman-codes/">Building a data compression utility in Haskell using Huffman codes</a><div class="ui-feed-item__blog-title">Marcelo Lazaroni</div><div class="ui-feed-item__summary">
In this post we will implement a data compression program in about 150 lines of Haskell.It will use Huffman coding and handle arbitrary binary files using constant memory for encoding and decoding.The plan is:We briefly cover what Huffman codes are and how they can be used for data compression.We write a coder capable of compressing text.In the last step we use this coder to compress any file at all.We will leverage laziness to keep our memory footprint constant while the code remains modular. A good example of Why Functional Programming Matters.The full code is available here.Crash course on Huffman codesThe idea is straightforward:Map each character to a unique sequence of bits.Choose the bit sequences such that common characters map to shorter bit sequences and rare characters map to longer ones.Compression is achieved by the most common characters using fewer bits than their uncompressed representation.I say characters here, but we could really map anything to bits; like whole word
</div><div class="ui-feed-item__date" title="2024-06-15 00:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://lazamar.github.io/virtual-dom/"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://lazamar.github.io/virtual-dom/">A virtual DOM in 200 lines of JavaScript</a><div class="ui-feed-item__blog-title">Marcelo Lazaroni</div><div class="ui-feed-item__summary">
In this post I’ll walk through the full implementation of a Virtual DOM in a bit over 200 lines of JavaScript.The result is a full-featured and sufficiently performant virtual DOM library (demos).It’s available on NPM as the smvc package.The main goal is to illustrate the fundamental technique behind tools like React.React, Vue and the Elm language all simplify the creation of interactive webpages by allowing you to describe how you’d like the page to look like, and notworry about adding/removing elements to get there.They do that through a Virtual DOM.The goal of a virtual DOMIt’s not about performance.A Virtual DOM is an abstraction to simplify the act of modifying a UI.You describe how you would like your page to look like and the library takes care of taking the DOMfrom its current state, to the state you want it to be in.The key ideaThe library will take over a single DOM element and operate inside of it.This element should be initially empty, and we operate under the assumption t
</div><div class="ui-feed-item__date" title="2024-05-19 00:00:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://lazamar.github.io/haskell-documentation-in-the-command-line/"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://lazamar.github.io/haskell-documentation-in-the-command-line/">Browse Hackage from the terminal ⚡</a><div class="ui-feed-item__blog-title">Marcelo Lazaroni</div><div class="ui-feed-item__summary">
The Haskell ecosystem has great facilities for searching and navigating package documentation using the browser. haskell-docs-cli allows you to do that much faster without leaving the terminal.Jump to demoThe problemSwitching focus from the editor to the browser when searching for something on Hoogle or reading a piece of documentation on Hackage is not an ideal workflow. Even having Hoogle as a custom search engine on Chrome and using Vimium to avoid the mouse, the path to the module documentation page requires too many key presses.Here is an example. Imagine I’m using the Prettyprinter module (from the prettyprinter package) and want to find out what function will concatenate documents vertically. The best way to do that is to open up the module documentation page and search for the word ‘vertical’.Here is the how to do that in the browser. I’m assuming that a browser window is already open:Cmd+Tab - Switch to browser windowCmd+T - New tabh Prettyprint - Search Hoogle using a custom
</div><div class="ui-feed-item__date" title="2021-09-19 00:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://lazamar.github.io/download-specific-package-version-with-nix/"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://lazamar.github.io/download-specific-package-version-with-nix/">Searching and installing old versions of Nix packages</a><div class="ui-feed-item__blog-title">Marcelo Lazaroni</div><div class="ui-feed-item__summary">
TL;DR: There is no Nix-native way of doing that. In this post I describe the process that led to the creation of Nix Package Versions, the tool that provides this functionality.The problemThe Nix package manager allows one to easily install and remove different versions of the same package. With nix-shell one can even start a shell environment with a different version of a package that is already installed.This is extremely useful and one of Nix’s killer features.Some time ago I noticed that my version of Neovim had a bug. This seemed like an easy fix, I just needed to install a previous version of the same package.Searching locally with nix-env -qa neovim revealed that my revision had only one version of the package, which was the same as the one available at https://search.nixos.org/packages. After some more research I discovered that there is currently no Nix-native way to search through previous revisions for older versions of a package. In fact there is a very long discussion span
</div><div class="ui-feed-item__date" title="2020-08-31 00:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://lazamar.github.io/deploying-statically-linked-haskell-to-lambda/"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://lazamar.github.io/deploying-statically-linked-haskell-to-lambda/">Deploying statically-linked Haskell to Lambda</a><div class="ui-feed-item__blog-title">Marcelo Lazaroni</div><div class="ui-feed-item__summary">
In his post about a Telegram botJoachim Breitner mentions compiling his program into a static binary to have it run in Amazon’s version ofLinux without needing to build it inside a container. I was interested in experimenting withAmazon Lambda and having statically linked Haskell programs sounded like a great idea too, so thisis a write-up of what it took to get those things working.In the end we will have a Haskell program compiling to a statically linked binary, being builtquickly by making use of Nix and Cachix and automatically deployed to Amazon Lambda using GitHubActions.The code for this post can be found at lazamar/lambda-haskell.In Lambda we need a special wrapping layer to run Haskell code. I’m usingaws-lambda-haskell-runtimefor that. I wanted to see what data from the request Amazon was making available, so theprogram will simply get a request as a JSON, prettify it and return that. This is Main.hs,the only Haskell file.{-# LANGUAGE DeriveGeneric #-}{-# LANGUAGE DeriveAnyCla
</div><div class="ui-feed-item__date" title="2020-06-24 00:00:00">6年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://lazamar.github.io/download-images-snippet/"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://lazamar.github.io/download-images-snippet/">Download images from a page</a><div class="ui-feed-item__blog-title">Marcelo Lazaroni</div><div class="ui-feed-item__summary">
Often I need to download many images from a web page and end up trying and adjusting far too many snippets from Stack Overflow.Here is a snippet that works. Give it two strings to download an image.async function download(url, name) { const res = await fetch(url); const blob = await res.blob(); const blobUrl = URL.createObjectURL(blob); const a = document.createElement(&quot;a&quot;); a.href = blobUrl a.download = name; document.body.appendChild(a); a.click(); document.body.removeChild(a);}The browser doesn’t handle downloading many images at once very well. I find that adding a timeout is enough to make things work.function downloadWithTimeout(url, index) { const f = () =&gt; download(url, `image-${index}.jpg`); setTimeout(f, index * 500);}// Use like thismyUrls.forEach(downloadWithTimeout)</div><div class="ui-feed-item__date" title="2020-03-15 00:00:00">6年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" 
href="https://lazamar.github.io/fast-parsing-of-string-sets-in-elm/"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://lazamar.github.io/fast-parsing-of-string-sets-in-elm/">Fast parsing of String Sets in Elm</a><div class="ui-feed-item__blog-title">Marcelo Lazaroni</div><div class="ui-feed-item__summary">
Imagine you want to write a parser to match any of a set of strings that you know beforehand.In Elm’s standard parsing library you would use Parser.oneOf. Like this:import Parser exposing (Parser, oneOf, backtrackable, token, getChompedString)friendName : Parser StringfriendName =oneOf[ backtrackable &lt;| token &quot;joe&quot;, backtrackable &lt;| token &quot;joey&quot;, backtrackable &lt;| token &quot;john&quot;]|&gt; getChompedStringNow we can parse the name of our friends. However this parser has a few problems:It is inefficientIf the string we are matching against is &quot;lisa&quot;, for example, this parser will perform the following steps:Look at the first three characters in our parsed string and check whether they are equal to &quot;joe&quot;. They aren’t.Look at the first four characters in our parsed string and check whether they are equal to &quot;joey&quot;. They aren’tLook at the first four characters in our parsed string and check whether they are equal to &quot;john&quot;. They aren’tFailOohf, that’s not very good. From the first time we looked at t
</div><div class="ui-feed-item__date" title="2020-03-10 00:00:00">6年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://lazamar.github.io/recursion-patterns/"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://lazamar.github.io/recursion-patterns/">Recursion Patterns - Getting rid of stack overflows</a><div class="ui-feed-item__blog-title">Marcelo Lazaroni</div><div class="ui-feed-item__summary">
In functional programming languages you may find yourself overflowing the stack. This post describes techniques to achieve unbounded recursion without fear of the stack.TL;DRThe name of the game is staying tail recursiveEnable tail recursion by passing down computed valuesStick to one recursive call at a time by passing down a list of recursions to be doneIf we reach a stack overflow it is because we are not taking advantage of tail recursion. The fix is: use tail recursion. How to do that, however, is not always very clear.Tail recursionQuick recapitulation: If the very last thing our function does is to return the recursive call, it qualifies for tail call optimisation. This optimisation makes the recursive call take the place of the invoking function in the stack, allowing us to recurse without growing the stack size. This eliminates the risk of a stack overflow.This function is tail recursive (examples are in Elm):-- Pauses execution for n loops of the runtimesleep n =if n &gt; 0 then
</div><div class="ui-feed-item__date" title="2019-03-23 00:00:00">7年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://lazamar.github.io/making-blue-green-deployments-dead-simple/"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://lazamar.github.io/making-blue-green-deployments-dead-simple/">Zero downtime - Making Blue-Green deployments dead simple</a><div class="ui-feed-item__blog-title">Marcelo Lazaroni</div><div class="ui-feed-item__summary">
At the current state of web technologies, having our application be unavailable during every upgrade is not acceptable anymore. And if you are updating your application often, which you should, being available during updates is even more important. In this post I will walk you through hot-swapping docker containers without letting any request drop with just one command.Blue-Green deployment is the technique we will use. It involves running your new and old server versions in parallel and having a proxy redirect new requests to the new version. Once the old version is finished answering all its remaining requests it can be shut down safely. There you go, version swap with no downtime.It’s easier said than done, though. Even though everyone seems to be able to explain it very well it was hard to find someone actually showing how to do it.The setup is not complicated, but can be tricky to get right. We will use a small tool to do the heavy-lifting. I will do the explanation first and the
</div><div class="ui-feed-item__date" title="2017-10-07 00:00:00">8年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://lazamar.github.io/faster-and-safer-haskell-accumulating-parameter/"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://lazamar.github.io/faster-and-safer-haskell-accumulating-parameter/">Faster and safer Haskell - benchmarks for the accumulating parameter</a><div class="ui-feed-item__blog-title">Marcelo Lazaroni</div><div class="ui-feed-item__summary">
Haskell’s laziness can cause problems with recursive functions if they are not handled properly. In some cases this can be dealt with by using an accumulating parameter. Haskell’s wiki page on the subject does a great job in explaining how that works. Here I register some benchmarks on the wiki’s examples so we can see how much that matters.I won’t go into details as to why one implementation performs better than the other as the wiki’s article is already very clear and concise. I will stick to showing the code and the benchmarks.The task in our hands is to calculate the length of a list. To make sure this is working we will print the length of a really long one.main = print $ len [1..1000000000] -- 1 BillionVery lazy implementationThis is our first and very naive implementation.len :: [a] -&gt; Intlen [] = 0len (x:xs) = len xs + 1In this implementation memory usage grew very quickly and we also hit a stack overflow in less than 10 seconds.Tail recursive implementationIn this implementati
</div><div class="ui-feed-item__date" title="2017-09-09 00:00:00">8年前</div></div></div></div></div></section></main><footer role="contentinfo" class="ui-section-footer"><div class="ui-layout-container"><div class="ui-layout-column-6 ui-layout-column-center"><div class="ui-component-cta ui-layout-flex ui-section-footer__site-info"><p class="ui-text-note">このサイトは<br>記事を読んでその企業の技術・カルチャーを知れることや<br>質の高い技術情報を得られることを目的としています。</p><p class="ui-text-note">追加したいブログがある場合は<br><a href="https://github.com/jser/watch-list-rss#%E3%82%B5%E3%82%A4%E3%83%88%E3%81%AE%E8%BF%BD%E5%8A%A0%E6%96%B9%E6%B3%95" target="_blank">サイトの追加方法</a> をご参照ください。</p></div></div></div><div class="ui-layout-container"><div class="ui-section-footer__layout ui-layout-flex"><p class="ui-section-footer--copyright ui-text-note"><a class="ui-text-note" href="https://github.com/jser/" target="_blank"><small>@jser</small></a></p><a href="https://github.com/jser/watch-list-rss/" role="link" aria-label="#" class="ui-text-note" 
target="_blank"><small>GitHub</small></a></div></div></footer></body></html>